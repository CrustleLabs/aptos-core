// -- Model dump before env processor pipeline:
module 0xcffa::m {
    struct Test1 {
        a: u8,
    }
    struct Test2 {
        a: vector<u8>,
    }
    public fun eq1(x: u64,y: u64): u64 {
        if Eq<u64>(x, y) {
          x
        } else {
          y
        }
    }
    public fun eq10(x: Test2,y: Test2): bool {
        Eq<Test2>(x, y)
    }
    public fun eq2(x: u64,y: u64): bool {
        Eq<u64>(Borrow(Immutable)(x), Borrow(Immutable)(y))
    }
    public fun eq3<T>(x: T,y: T): bool {
        Eq<T>(x, y)
    }
    public fun eq4<T>(x: T,y: T): bool {
        Eq<T>(Borrow(Immutable)(x), Borrow(Immutable)(y))
    }
    public fun eq5(x: bool,y: bool): bool {
        Eq<bool>(x, y)
    }
    public fun eq6(x: address,y: address): bool {
        Eq<address>(x, y)
    }
    public fun eq7(x: vector<u8>,y: vector<u8>): bool {
        Eq<vector<u8>>(x, y)
    }
    public fun eq8(x: vector<vector<u8>>,y: vector<vector<u8>>): bool {
        Eq<vector<vector<u8>>>(x, y)
    }
    public fun eq9(x: Test1,y: Test1): bool {
        Eq<Test1>(x, y)
    }
    public fun neq1(x: u64,y: u64): bool {
        Neq<u64>(x, y)
    }
    public fun neq10(x: Test2,y: Test2): bool {
        Neq<Test2>(x, y)
    }
    public fun neq2(x: u64,y: u64): bool {
        Neq<u64>(Borrow(Immutable)(x), Borrow(Immutable)(y))
    }
    public fun neq3<T>(x: T,y: T): bool {
        Neq<T>(x, y)
    }
    public fun neq4<T>(x: T,y: T): bool {
        Neq<T>(Borrow(Immutable)(x), Borrow(Immutable)(y))
    }
    public fun neq5(x: bool,y: bool): bool {
        Neq<bool>(x, y)
    }
    public fun neq6(x: address,y: address): bool {
        Neq<address>(x, y)
    }
    public fun neq7(x: vector<u8>,y: vector<u8>): bool {
        Neq<vector<u8>>(x, y)
    }
    public fun neq8(x: vector<vector<u8>>,y: vector<vector<u8>>): bool {
        Neq<vector<vector<u8>>>(x, y)
    }
    public fun neq9(x: Test1,y: Test1): bool {
        Neq<Test1>(x, y)
    }
} // end 0xcffa::m


// -- Model dump after env processor unused checks:
module 0xcffa::m {
    struct Test1 {
        a: u8,
    }
    struct Test2 {
        a: vector<u8>,
    }
    public fun eq1(x: u64,y: u64): u64 {
        if Eq<u64>(x, y) {
          x
        } else {
          y
        }
    }
    public fun eq10(x: Test2,y: Test2): bool {
        Eq<Test2>(x, y)
    }
    public fun eq2(x: u64,y: u64): bool {
        Eq<u64>(Borrow(Immutable)(x), Borrow(Immutable)(y))
    }
    public fun eq3<T>(x: T,y: T): bool {
        Eq<T>(x, y)
    }
    public fun eq4<T>(x: T,y: T): bool {
        Eq<T>(Borrow(Immutable)(x), Borrow(Immutable)(y))
    }
    public fun eq5(x: bool,y: bool): bool {
        Eq<bool>(x, y)
    }
    public fun eq6(x: address,y: address): bool {
        Eq<address>(x, y)
    }
    public fun eq7(x: vector<u8>,y: vector<u8>): bool {
        Eq<vector<u8>>(x, y)
    }
    public fun eq8(x: vector<vector<u8>>,y: vector<vector<u8>>): bool {
        Eq<vector<vector<u8>>>(x, y)
    }
    public fun eq9(x: Test1,y: Test1): bool {
        Eq<Test1>(x, y)
    }
    public fun neq1(x: u64,y: u64): bool {
        Neq<u64>(x, y)
    }
    public fun neq10(x: Test2,y: Test2): bool {
        Neq<Test2>(x, y)
    }
    public fun neq2(x: u64,y: u64): bool {
        Neq<u64>(Borrow(Immutable)(x), Borrow(Immutable)(y))
    }
    public fun neq3<T>(x: T,y: T): bool {
        Neq<T>(x, y)
    }
    public fun neq4<T>(x: T,y: T): bool {
        Neq<T>(Borrow(Immutable)(x), Borrow(Immutable)(y))
    }
    public fun neq5(x: bool,y: bool): bool {
        Neq<bool>(x, y)
    }
    public fun neq6(x: address,y: address): bool {
        Neq<address>(x, y)
    }
    public fun neq7(x: vector<u8>,y: vector<u8>): bool {
        Neq<vector<u8>>(x, y)
    }
    public fun neq8(x: vector<vector<u8>>,y: vector<vector<u8>>): bool {
        Neq<vector<vector<u8>>>(x, y)
    }
    public fun neq9(x: Test1,y: Test1): bool {
        Neq<Test1>(x, y)
    }
} // end 0xcffa::m


// -- Model dump after env processor type parameter check:
module 0xcffa::m {
    struct Test1 {
        a: u8,
    }
    struct Test2 {
        a: vector<u8>,
    }
    public fun eq1(x: u64,y: u64): u64 {
        if Eq<u64>(x, y) {
          x
        } else {
          y
        }
    }
    public fun eq10(x: Test2,y: Test2): bool {
        Eq<Test2>(x, y)
    }
    public fun eq2(x: u64,y: u64): bool {
        Eq<u64>(Borrow(Immutable)(x), Borrow(Immutable)(y))
    }
    public fun eq3<T>(x: T,y: T): bool {
        Eq<T>(x, y)
    }
    public fun eq4<T>(x: T,y: T): bool {
        Eq<T>(Borrow(Immutable)(x), Borrow(Immutable)(y))
    }
    public fun eq5(x: bool,y: bool): bool {
        Eq<bool>(x, y)
    }
    public fun eq6(x: address,y: address): bool {
        Eq<address>(x, y)
    }
    public fun eq7(x: vector<u8>,y: vector<u8>): bool {
        Eq<vector<u8>>(x, y)
    }
    public fun eq8(x: vector<vector<u8>>,y: vector<vector<u8>>): bool {
        Eq<vector<vector<u8>>>(x, y)
    }
    public fun eq9(x: Test1,y: Test1): bool {
        Eq<Test1>(x, y)
    }
    public fun neq1(x: u64,y: u64): bool {
        Neq<u64>(x, y)
    }
    public fun neq10(x: Test2,y: Test2): bool {
        Neq<Test2>(x, y)
    }
    public fun neq2(x: u64,y: u64): bool {
        Neq<u64>(Borrow(Immutable)(x), Borrow(Immutable)(y))
    }
    public fun neq3<T>(x: T,y: T): bool {
        Neq<T>(x, y)
    }
    public fun neq4<T>(x: T,y: T): bool {
        Neq<T>(Borrow(Immutable)(x), Borrow(Immutable)(y))
    }
    public fun neq5(x: bool,y: bool): bool {
        Neq<bool>(x, y)
    }
    public fun neq6(x: address,y: address): bool {
        Neq<address>(x, y)
    }
    public fun neq7(x: vector<u8>,y: vector<u8>): bool {
        Neq<vector<u8>>(x, y)
    }
    public fun neq8(x: vector<vector<u8>>,y: vector<vector<u8>>): bool {
        Neq<vector<vector<u8>>>(x, y)
    }
    public fun neq9(x: Test1,y: Test1): bool {
        Neq<Test1>(x, y)
    }
} // end 0xcffa::m


// -- Model dump after env processor check recursive struct definition:
module 0xcffa::m {
    struct Test1 {
        a: u8,
    }
    struct Test2 {
        a: vector<u8>,
    }
    public fun eq1(x: u64,y: u64): u64 {
        if Eq<u64>(x, y) {
          x
        } else {
          y
        }
    }
    public fun eq10(x: Test2,y: Test2): bool {
        Eq<Test2>(x, y)
    }
    public fun eq2(x: u64,y: u64): bool {
        Eq<u64>(Borrow(Immutable)(x), Borrow(Immutable)(y))
    }
    public fun eq3<T>(x: T,y: T): bool {
        Eq<T>(x, y)
    }
    public fun eq4<T>(x: T,y: T): bool {
        Eq<T>(Borrow(Immutable)(x), Borrow(Immutable)(y))
    }
    public fun eq5(x: bool,y: bool): bool {
        Eq<bool>(x, y)
    }
    public fun eq6(x: address,y: address): bool {
        Eq<address>(x, y)
    }
    public fun eq7(x: vector<u8>,y: vector<u8>): bool {
        Eq<vector<u8>>(x, y)
    }
    public fun eq8(x: vector<vector<u8>>,y: vector<vector<u8>>): bool {
        Eq<vector<vector<u8>>>(x, y)
    }
    public fun eq9(x: Test1,y: Test1): bool {
        Eq<Test1>(x, y)
    }
    public fun neq1(x: u64,y: u64): bool {
        Neq<u64>(x, y)
    }
    public fun neq10(x: Test2,y: Test2): bool {
        Neq<Test2>(x, y)
    }
    public fun neq2(x: u64,y: u64): bool {
        Neq<u64>(Borrow(Immutable)(x), Borrow(Immutable)(y))
    }
    public fun neq3<T>(x: T,y: T): bool {
        Neq<T>(x, y)
    }
    public fun neq4<T>(x: T,y: T): bool {
        Neq<T>(Borrow(Immutable)(x), Borrow(Immutable)(y))
    }
    public fun neq5(x: bool,y: bool): bool {
        Neq<bool>(x, y)
    }
    public fun neq6(x: address,y: address): bool {
        Neq<address>(x, y)
    }
    public fun neq7(x: vector<u8>,y: vector<u8>): bool {
        Neq<vector<u8>>(x, y)
    }
    public fun neq8(x: vector<vector<u8>>,y: vector<vector<u8>>): bool {
        Neq<vector<vector<u8>>>(x, y)
    }
    public fun neq9(x: Test1,y: Test1): bool {
        Neq<Test1>(x, y)
    }
} // end 0xcffa::m


// -- Model dump after env processor check cyclic type instantiation:
module 0xcffa::m {
    struct Test1 {
        a: u8,
    }
    struct Test2 {
        a: vector<u8>,
    }
    public fun eq1(x: u64,y: u64): u64 {
        if Eq<u64>(x, y) {
          x
        } else {
          y
        }
    }
    public fun eq10(x: Test2,y: Test2): bool {
        Eq<Test2>(x, y)
    }
    public fun eq2(x: u64,y: u64): bool {
        Eq<u64>(Borrow(Immutable)(x), Borrow(Immutable)(y))
    }
    public fun eq3<T>(x: T,y: T): bool {
        Eq<T>(x, y)
    }
    public fun eq4<T>(x: T,y: T): bool {
        Eq<T>(Borrow(Immutable)(x), Borrow(Immutable)(y))
    }
    public fun eq5(x: bool,y: bool): bool {
        Eq<bool>(x, y)
    }
    public fun eq6(x: address,y: address): bool {
        Eq<address>(x, y)
    }
    public fun eq7(x: vector<u8>,y: vector<u8>): bool {
        Eq<vector<u8>>(x, y)
    }
    public fun eq8(x: vector<vector<u8>>,y: vector<vector<u8>>): bool {
        Eq<vector<vector<u8>>>(x, y)
    }
    public fun eq9(x: Test1,y: Test1): bool {
        Eq<Test1>(x, y)
    }
    public fun neq1(x: u64,y: u64): bool {
        Neq<u64>(x, y)
    }
    public fun neq10(x: Test2,y: Test2): bool {
        Neq<Test2>(x, y)
    }
    public fun neq2(x: u64,y: u64): bool {
        Neq<u64>(Borrow(Immutable)(x), Borrow(Immutable)(y))
    }
    public fun neq3<T>(x: T,y: T): bool {
        Neq<T>(x, y)
    }
    public fun neq4<T>(x: T,y: T): bool {
        Neq<T>(Borrow(Immutable)(x), Borrow(Immutable)(y))
    }
    public fun neq5(x: bool,y: bool): bool {
        Neq<bool>(x, y)
    }
    public fun neq6(x: address,y: address): bool {
        Neq<address>(x, y)
    }
    public fun neq7(x: vector<u8>,y: vector<u8>): bool {
        Neq<vector<u8>>(x, y)
    }
    public fun neq8(x: vector<vector<u8>>,y: vector<vector<u8>>): bool {
        Neq<vector<vector<u8>>>(x, y)
    }
    public fun neq9(x: Test1,y: Test1): bool {
        Neq<Test1>(x, y)
    }
} // end 0xcffa::m


// -- Model dump after env processor unused struct params check:
module 0xcffa::m {
    struct Test1 {
        a: u8,
    }
    struct Test2 {
        a: vector<u8>,
    }
    public fun eq1(x: u64,y: u64): u64 {
        if Eq<u64>(x, y) {
          x
        } else {
          y
        }
    }
    public fun eq10(x: Test2,y: Test2): bool {
        Eq<Test2>(x, y)
    }
    public fun eq2(x: u64,y: u64): bool {
        Eq<u64>(Borrow(Immutable)(x), Borrow(Immutable)(y))
    }
    public fun eq3<T>(x: T,y: T): bool {
        Eq<T>(x, y)
    }
    public fun eq4<T>(x: T,y: T): bool {
        Eq<T>(Borrow(Immutable)(x), Borrow(Immutable)(y))
    }
    public fun eq5(x: bool,y: bool): bool {
        Eq<bool>(x, y)
    }
    public fun eq6(x: address,y: address): bool {
        Eq<address>(x, y)
    }
    public fun eq7(x: vector<u8>,y: vector<u8>): bool {
        Eq<vector<u8>>(x, y)
    }
    public fun eq8(x: vector<vector<u8>>,y: vector<vector<u8>>): bool {
        Eq<vector<vector<u8>>>(x, y)
    }
    public fun eq9(x: Test1,y: Test1): bool {
        Eq<Test1>(x, y)
    }
    public fun neq1(x: u64,y: u64): bool {
        Neq<u64>(x, y)
    }
    public fun neq10(x: Test2,y: Test2): bool {
        Neq<Test2>(x, y)
    }
    public fun neq2(x: u64,y: u64): bool {
        Neq<u64>(Borrow(Immutable)(x), Borrow(Immutable)(y))
    }
    public fun neq3<T>(x: T,y: T): bool {
        Neq<T>(x, y)
    }
    public fun neq4<T>(x: T,y: T): bool {
        Neq<T>(Borrow(Immutable)(x), Borrow(Immutable)(y))
    }
    public fun neq5(x: bool,y: bool): bool {
        Neq<bool>(x, y)
    }
    public fun neq6(x: address,y: address): bool {
        Neq<address>(x, y)
    }
    public fun neq7(x: vector<u8>,y: vector<u8>): bool {
        Neq<vector<u8>>(x, y)
    }
    public fun neq8(x: vector<vector<u8>>,y: vector<vector<u8>>): bool {
        Neq<vector<vector<u8>>>(x, y)
    }
    public fun neq9(x: Test1,y: Test1): bool {
        Neq<Test1>(x, y)
    }
} // end 0xcffa::m


// -- Model dump after env processor access and use check before inlining:
module 0xcffa::m {
    struct Test1 {
        a: u8,
    }
    struct Test2 {
        a: vector<u8>,
    }
    public fun eq1(x: u64,y: u64): u64 {
        if Eq<u64>(x, y) {
          x
        } else {
          y
        }
    }
    public fun eq10(x: Test2,y: Test2): bool {
        Eq<Test2>(x, y)
    }
    public fun eq2(x: u64,y: u64): bool {
        Eq<u64>(Borrow(Immutable)(x), Borrow(Immutable)(y))
    }
    public fun eq3<T>(x: T,y: T): bool {
        Eq<T>(x, y)
    }
    public fun eq4<T>(x: T,y: T): bool {
        Eq<T>(Borrow(Immutable)(x), Borrow(Immutable)(y))
    }
    public fun eq5(x: bool,y: bool): bool {
        Eq<bool>(x, y)
    }
    public fun eq6(x: address,y: address): bool {
        Eq<address>(x, y)
    }
    public fun eq7(x: vector<u8>,y: vector<u8>): bool {
        Eq<vector<u8>>(x, y)
    }
    public fun eq8(x: vector<vector<u8>>,y: vector<vector<u8>>): bool {
        Eq<vector<vector<u8>>>(x, y)
    }
    public fun eq9(x: Test1,y: Test1): bool {
        Eq<Test1>(x, y)
    }
    public fun neq1(x: u64,y: u64): bool {
        Neq<u64>(x, y)
    }
    public fun neq10(x: Test2,y: Test2): bool {
        Neq<Test2>(x, y)
    }
    public fun neq2(x: u64,y: u64): bool {
        Neq<u64>(Borrow(Immutable)(x), Borrow(Immutable)(y))
    }
    public fun neq3<T>(x: T,y: T): bool {
        Neq<T>(x, y)
    }
    public fun neq4<T>(x: T,y: T): bool {
        Neq<T>(Borrow(Immutable)(x), Borrow(Immutable)(y))
    }
    public fun neq5(x: bool,y: bool): bool {
        Neq<bool>(x, y)
    }
    public fun neq6(x: address,y: address): bool {
        Neq<address>(x, y)
    }
    public fun neq7(x: vector<u8>,y: vector<u8>): bool {
        Neq<vector<u8>>(x, y)
    }
    public fun neq8(x: vector<vector<u8>>,y: vector<vector<u8>>): bool {
        Neq<vector<vector<u8>>>(x, y)
    }
    public fun neq9(x: Test1,y: Test1): bool {
        Neq<Test1>(x, y)
    }
} // end 0xcffa::m


// -- Model dump after env processor inlining:
module 0xcffa::m {
    struct Test1 {
        a: u8,
    }
    struct Test2 {
        a: vector<u8>,
    }
    public fun eq1(x: u64,y: u64): u64 {
        if Eq<u64>(x, y) {
          x
        } else {
          y
        }
    }
    public fun eq10(x: Test2,y: Test2): bool {
        Eq<Test2>(x, y)
    }
    public fun eq2(x: u64,y: u64): bool {
        Eq<u64>(Borrow(Immutable)(x), Borrow(Immutable)(y))
    }
    public fun eq3<T>(x: T,y: T): bool {
        Eq<T>(x, y)
    }
    public fun eq4<T>(x: T,y: T): bool {
        Eq<T>(Borrow(Immutable)(x), Borrow(Immutable)(y))
    }
    public fun eq5(x: bool,y: bool): bool {
        Eq<bool>(x, y)
    }
    public fun eq6(x: address,y: address): bool {
        Eq<address>(x, y)
    }
    public fun eq7(x: vector<u8>,y: vector<u8>): bool {
        Eq<vector<u8>>(x, y)
    }
    public fun eq8(x: vector<vector<u8>>,y: vector<vector<u8>>): bool {
        Eq<vector<vector<u8>>>(x, y)
    }
    public fun eq9(x: Test1,y: Test1): bool {
        Eq<Test1>(x, y)
    }
    public fun neq1(x: u64,y: u64): bool {
        Neq<u64>(x, y)
    }
    public fun neq10(x: Test2,y: Test2): bool {
        Neq<Test2>(x, y)
    }
    public fun neq2(x: u64,y: u64): bool {
        Neq<u64>(Borrow(Immutable)(x), Borrow(Immutable)(y))
    }
    public fun neq3<T>(x: T,y: T): bool {
        Neq<T>(x, y)
    }
    public fun neq4<T>(x: T,y: T): bool {
        Neq<T>(Borrow(Immutable)(x), Borrow(Immutable)(y))
    }
    public fun neq5(x: bool,y: bool): bool {
        Neq<bool>(x, y)
    }
    public fun neq6(x: address,y: address): bool {
        Neq<address>(x, y)
    }
    public fun neq7(x: vector<u8>,y: vector<u8>): bool {
        Neq<vector<u8>>(x, y)
    }
    public fun neq8(x: vector<vector<u8>>,y: vector<vector<u8>>): bool {
        Neq<vector<vector<u8>>>(x, y)
    }
    public fun neq9(x: Test1,y: Test1): bool {
        Neq<Test1>(x, y)
    }
} // end 0xcffa::m


// -- Model dump after env processor access and use check after inlining:
module 0xcffa::m {
    struct Test1 {
        a: u8,
    }
    struct Test2 {
        a: vector<u8>,
    }
    public fun eq1(x: u64,y: u64): u64 {
        if Eq<u64>(x, y) {
          x
        } else {
          y
        }
    }
    public fun eq10(x: Test2,y: Test2): bool {
        Eq<Test2>(x, y)
    }
    public fun eq2(x: u64,y: u64): bool {
        Eq<u64>(Borrow(Immutable)(x), Borrow(Immutable)(y))
    }
    public fun eq3<T>(x: T,y: T): bool {
        Eq<T>(x, y)
    }
    public fun eq4<T>(x: T,y: T): bool {
        Eq<T>(Borrow(Immutable)(x), Borrow(Immutable)(y))
    }
    public fun eq5(x: bool,y: bool): bool {
        Eq<bool>(x, y)
    }
    public fun eq6(x: address,y: address): bool {
        Eq<address>(x, y)
    }
    public fun eq7(x: vector<u8>,y: vector<u8>): bool {
        Eq<vector<u8>>(x, y)
    }
    public fun eq8(x: vector<vector<u8>>,y: vector<vector<u8>>): bool {
        Eq<vector<vector<u8>>>(x, y)
    }
    public fun eq9(x: Test1,y: Test1): bool {
        Eq<Test1>(x, y)
    }
    public fun neq1(x: u64,y: u64): bool {
        Neq<u64>(x, y)
    }
    public fun neq10(x: Test2,y: Test2): bool {
        Neq<Test2>(x, y)
    }
    public fun neq2(x: u64,y: u64): bool {
        Neq<u64>(Borrow(Immutable)(x), Borrow(Immutable)(y))
    }
    public fun neq3<T>(x: T,y: T): bool {
        Neq<T>(x, y)
    }
    public fun neq4<T>(x: T,y: T): bool {
        Neq<T>(Borrow(Immutable)(x), Borrow(Immutable)(y))
    }
    public fun neq5(x: bool,y: bool): bool {
        Neq<bool>(x, y)
    }
    public fun neq6(x: address,y: address): bool {
        Neq<address>(x, y)
    }
    public fun neq7(x: vector<u8>,y: vector<u8>): bool {
        Neq<vector<u8>>(x, y)
    }
    public fun neq8(x: vector<vector<u8>>,y: vector<vector<u8>>): bool {
        Neq<vector<vector<u8>>>(x, y)
    }
    public fun neq9(x: Test1,y: Test1): bool {
        Neq<Test1>(x, y)
    }
} // end 0xcffa::m


// -- Model dump after env processor acquires check:
module 0xcffa::m {
    struct Test1 {
        a: u8,
    }
    struct Test2 {
        a: vector<u8>,
    }
    public fun eq1(x: u64,y: u64): u64 {
        if Eq<u64>(x, y) {
          x
        } else {
          y
        }
    }
    public fun eq10(x: Test2,y: Test2): bool {
        Eq<Test2>(x, y)
    }
    public fun eq2(x: u64,y: u64): bool {
        Eq<u64>(Borrow(Immutable)(x), Borrow(Immutable)(y))
    }
    public fun eq3<T>(x: T,y: T): bool {
        Eq<T>(x, y)
    }
    public fun eq4<T>(x: T,y: T): bool {
        Eq<T>(Borrow(Immutable)(x), Borrow(Immutable)(y))
    }
    public fun eq5(x: bool,y: bool): bool {
        Eq<bool>(x, y)
    }
    public fun eq6(x: address,y: address): bool {
        Eq<address>(x, y)
    }
    public fun eq7(x: vector<u8>,y: vector<u8>): bool {
        Eq<vector<u8>>(x, y)
    }
    public fun eq8(x: vector<vector<u8>>,y: vector<vector<u8>>): bool {
        Eq<vector<vector<u8>>>(x, y)
    }
    public fun eq9(x: Test1,y: Test1): bool {
        Eq<Test1>(x, y)
    }
    public fun neq1(x: u64,y: u64): bool {
        Neq<u64>(x, y)
    }
    public fun neq10(x: Test2,y: Test2): bool {
        Neq<Test2>(x, y)
    }
    public fun neq2(x: u64,y: u64): bool {
        Neq<u64>(Borrow(Immutable)(x), Borrow(Immutable)(y))
    }
    public fun neq3<T>(x: T,y: T): bool {
        Neq<T>(x, y)
    }
    public fun neq4<T>(x: T,y: T): bool {
        Neq<T>(Borrow(Immutable)(x), Borrow(Immutable)(y))
    }
    public fun neq5(x: bool,y: bool): bool {
        Neq<bool>(x, y)
    }
    public fun neq6(x: address,y: address): bool {
        Neq<address>(x, y)
    }
    public fun neq7(x: vector<u8>,y: vector<u8>): bool {
        Neq<vector<u8>>(x, y)
    }
    public fun neq8(x: vector<vector<u8>>,y: vector<vector<u8>>): bool {
        Neq<vector<vector<u8>>>(x, y)
    }
    public fun neq9(x: Test1,y: Test1): bool {
        Neq<Test1>(x, y)
    }
} // end 0xcffa::m


// -- Model dump after env processor specification checker:
module 0xcffa::m {
    struct Test1 {
        a: u8,
    }
    struct Test2 {
        a: vector<u8>,
    }
    public fun eq1(x: u64,y: u64): u64 {
        if Eq<u64>(x, y) {
          x
        } else {
          y
        }
    }
    public fun eq10(x: Test2,y: Test2): bool {
        Eq<Test2>(x, y)
    }
    public fun eq2(x: u64,y: u64): bool {
        Eq<u64>(Borrow(Immutable)(x), Borrow(Immutable)(y))
    }
    public fun eq3<T>(x: T,y: T): bool {
        Eq<T>(x, y)
    }
    public fun eq4<T>(x: T,y: T): bool {
        Eq<T>(Borrow(Immutable)(x), Borrow(Immutable)(y))
    }
    public fun eq5(x: bool,y: bool): bool {
        Eq<bool>(x, y)
    }
    public fun eq6(x: address,y: address): bool {
        Eq<address>(x, y)
    }
    public fun eq7(x: vector<u8>,y: vector<u8>): bool {
        Eq<vector<u8>>(x, y)
    }
    public fun eq8(x: vector<vector<u8>>,y: vector<vector<u8>>): bool {
        Eq<vector<vector<u8>>>(x, y)
    }
    public fun eq9(x: Test1,y: Test1): bool {
        Eq<Test1>(x, y)
    }
    public fun neq1(x: u64,y: u64): bool {
        Neq<u64>(x, y)
    }
    public fun neq10(x: Test2,y: Test2): bool {
        Neq<Test2>(x, y)
    }
    public fun neq2(x: u64,y: u64): bool {
        Neq<u64>(Borrow(Immutable)(x), Borrow(Immutable)(y))
    }
    public fun neq3<T>(x: T,y: T): bool {
        Neq<T>(x, y)
    }
    public fun neq4<T>(x: T,y: T): bool {
        Neq<T>(Borrow(Immutable)(x), Borrow(Immutable)(y))
    }
    public fun neq5(x: bool,y: bool): bool {
        Neq<bool>(x, y)
    }
    public fun neq6(x: address,y: address): bool {
        Neq<address>(x, y)
    }
    public fun neq7(x: vector<u8>,y: vector<u8>): bool {
        Neq<vector<u8>>(x, y)
    }
    public fun neq8(x: vector<vector<u8>>,y: vector<vector<u8>>): bool {
        Neq<vector<vector<u8>>>(x, y)
    }
    public fun neq9(x: Test1,y: Test1): bool {
        Neq<Test1>(x, y)
    }
} // end 0xcffa::m


// -- Model dump after env processor specification rewriter:
module 0xcffa::m {
    struct Test1 {
        a: u8,
    }
    struct Test2 {
        a: vector<u8>,
    }
    public fun eq1(x: u64,y: u64): u64 {
        if Eq<u64>(x, y) {
          x
        } else {
          y
        }
    }
    public fun eq10(x: Test2,y: Test2): bool {
        Eq<Test2>(x, y)
    }
    public fun eq2(x: u64,y: u64): bool {
        Eq<u64>(Borrow(Immutable)(x), Borrow(Immutable)(y))
    }
    public fun eq3<T>(x: T,y: T): bool {
        Eq<T>(x, y)
    }
    public fun eq4<T>(x: T,y: T): bool {
        Eq<T>(Borrow(Immutable)(x), Borrow(Immutable)(y))
    }
    public fun eq5(x: bool,y: bool): bool {
        Eq<bool>(x, y)
    }
    public fun eq6(x: address,y: address): bool {
        Eq<address>(x, y)
    }
    public fun eq7(x: vector<u8>,y: vector<u8>): bool {
        Eq<vector<u8>>(x, y)
    }
    public fun eq8(x: vector<vector<u8>>,y: vector<vector<u8>>): bool {
        Eq<vector<vector<u8>>>(x, y)
    }
    public fun eq9(x: Test1,y: Test1): bool {
        Eq<Test1>(x, y)
    }
    public fun neq1(x: u64,y: u64): bool {
        Neq<u64>(x, y)
    }
    public fun neq10(x: Test2,y: Test2): bool {
        Neq<Test2>(x, y)
    }
    public fun neq2(x: u64,y: u64): bool {
        Neq<u64>(Borrow(Immutable)(x), Borrow(Immutable)(y))
    }
    public fun neq3<T>(x: T,y: T): bool {
        Neq<T>(x, y)
    }
    public fun neq4<T>(x: T,y: T): bool {
        Neq<T>(Borrow(Immutable)(x), Borrow(Immutable)(y))
    }
    public fun neq5(x: bool,y: bool): bool {
        Neq<bool>(x, y)
    }
    public fun neq6(x: address,y: address): bool {
        Neq<address>(x, y)
    }
    public fun neq7(x: vector<u8>,y: vector<u8>): bool {
        Neq<vector<u8>>(x, y)
    }
    public fun neq8(x: vector<vector<u8>>,y: vector<vector<u8>>): bool {
        Neq<vector<vector<u8>>>(x, y)
    }
    public fun neq9(x: Test1,y: Test1): bool {
        Neq<Test1>(x, y)
    }
} // end 0xcffa::m


============ bytecode before first stackless bytecode pipeline ================

[variant baseline]
public fun m::eq1($t0: u64, $t1: u64): u64 {
     var $t2: u64
     var $t3: bool
     var $t4: u64
  0: $t4 := infer($t0)
  1: $t3 := ==($t4, $t1)
  2: if ($t3) goto 3 else goto 6
  3: label L0
  4: $t2 := infer($t0)
  5: goto 8
  6: label L1
  7: $t2 := infer($t1)
  8: label L2
  9: return $t2
}


[variant baseline]
public fun m::eq10($t0: 0xcffa::m::Test2, $t1: 0xcffa::m::Test2): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test2
  0: $t3 := infer($t0)
  1: $t2 := ==($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::eq2($t0: u64, $t1: u64): bool {
     var $t2: bool
     var $t3: &u64
     var $t4: &u64
  0: $t3 := borrow_local($t0)
  1: $t4 := borrow_local($t1)
  2: $t2 := ==($t3, $t4)
  3: return $t2
}


[variant baseline]
public fun m::eq3<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: #0
  0: $t3 := infer($t0)
  1: $t2 := ==($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::eq4<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: &#0
     var $t4: &#0
  0: $t3 := borrow_local($t0)
  1: $t4 := borrow_local($t1)
  2: $t2 := ==($t3, $t4)
  3: return $t2
}


[variant baseline]
public fun m::eq5($t0: bool, $t1: bool): bool {
     var $t2: bool
     var $t3: bool
  0: $t3 := infer($t0)
  1: $t2 := ==($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::eq6($t0: address, $t1: address): bool {
     var $t2: bool
     var $t3: address
  0: $t3 := infer($t0)
  1: $t2 := ==($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::eq7($t0: vector<u8>, $t1: vector<u8>): bool {
     var $t2: bool
     var $t3: vector<u8>
  0: $t3 := infer($t0)
  1: $t2 := ==($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::eq8($t0: vector<vector<u8>>, $t1: vector<vector<u8>>): bool {
     var $t2: bool
     var $t3: vector<vector<u8>>
  0: $t3 := infer($t0)
  1: $t2 := ==($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::eq9($t0: 0xcffa::m::Test1, $t1: 0xcffa::m::Test1): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test1
  0: $t3 := infer($t0)
  1: $t2 := ==($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq1($t0: u64, $t1: u64): bool {
     var $t2: bool
     var $t3: u64
  0: $t3 := infer($t0)
  1: $t2 := !=($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq10($t0: 0xcffa::m::Test2, $t1: 0xcffa::m::Test2): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test2
  0: $t3 := infer($t0)
  1: $t2 := !=($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq2($t0: u64, $t1: u64): bool {
     var $t2: bool
     var $t3: &u64
     var $t4: &u64
  0: $t3 := borrow_local($t0)
  1: $t4 := borrow_local($t1)
  2: $t2 := !=($t3, $t4)
  3: return $t2
}


[variant baseline]
public fun m::neq3<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: #0
  0: $t3 := infer($t0)
  1: $t2 := !=($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq4<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: &#0
     var $t4: &#0
  0: $t3 := borrow_local($t0)
  1: $t4 := borrow_local($t1)
  2: $t2 := !=($t3, $t4)
  3: return $t2
}


[variant baseline]
public fun m::neq5($t0: bool, $t1: bool): bool {
     var $t2: bool
     var $t3: bool
  0: $t3 := infer($t0)
  1: $t2 := !=($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq6($t0: address, $t1: address): bool {
     var $t2: bool
     var $t3: address
  0: $t3 := infer($t0)
  1: $t2 := !=($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq7($t0: vector<u8>, $t1: vector<u8>): bool {
     var $t2: bool
     var $t3: vector<u8>
  0: $t3 := infer($t0)
  1: $t2 := !=($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq8($t0: vector<vector<u8>>, $t1: vector<vector<u8>>): bool {
     var $t2: bool
     var $t3: vector<vector<u8>>
  0: $t3 := infer($t0)
  1: $t2 := !=($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq9($t0: 0xcffa::m::Test1, $t1: 0xcffa::m::Test1): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test1
  0: $t3 := infer($t0)
  1: $t2 := !=($t3, $t1)
  2: return $t2
}

============ after SplitCriticalEdgesProcessor: ================

[variant baseline]
public fun m::eq1($t0: u64, $t1: u64): u64 {
     var $t2: u64
     var $t3: bool
     var $t4: u64
  0: $t4 := infer($t0)
  1: $t3 := ==($t4, $t1)
  2: if ($t3) goto 3 else goto 6
  3: label L0
  4: $t2 := infer($t0)
  5: goto 8
  6: label L1
  7: $t2 := infer($t1)
  8: label L2
  9: return $t2
}


[variant baseline]
public fun m::eq10($t0: 0xcffa::m::Test2, $t1: 0xcffa::m::Test2): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test2
  0: $t3 := infer($t0)
  1: $t2 := ==($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::eq2($t0: u64, $t1: u64): bool {
     var $t2: bool
     var $t3: &u64
     var $t4: &u64
  0: $t3 := borrow_local($t0)
  1: $t4 := borrow_local($t1)
  2: $t2 := ==($t3, $t4)
  3: return $t2
}


[variant baseline]
public fun m::eq3<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: #0
  0: $t3 := infer($t0)
  1: $t2 := ==($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::eq4<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: &#0
     var $t4: &#0
  0: $t3 := borrow_local($t0)
  1: $t4 := borrow_local($t1)
  2: $t2 := ==($t3, $t4)
  3: return $t2
}


[variant baseline]
public fun m::eq5($t0: bool, $t1: bool): bool {
     var $t2: bool
     var $t3: bool
  0: $t3 := infer($t0)
  1: $t2 := ==($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::eq6($t0: address, $t1: address): bool {
     var $t2: bool
     var $t3: address
  0: $t3 := infer($t0)
  1: $t2 := ==($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::eq7($t0: vector<u8>, $t1: vector<u8>): bool {
     var $t2: bool
     var $t3: vector<u8>
  0: $t3 := infer($t0)
  1: $t2 := ==($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::eq8($t0: vector<vector<u8>>, $t1: vector<vector<u8>>): bool {
     var $t2: bool
     var $t3: vector<vector<u8>>
  0: $t3 := infer($t0)
  1: $t2 := ==($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::eq9($t0: 0xcffa::m::Test1, $t1: 0xcffa::m::Test1): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test1
  0: $t3 := infer($t0)
  1: $t2 := ==($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq1($t0: u64, $t1: u64): bool {
     var $t2: bool
     var $t3: u64
  0: $t3 := infer($t0)
  1: $t2 := !=($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq10($t0: 0xcffa::m::Test2, $t1: 0xcffa::m::Test2): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test2
  0: $t3 := infer($t0)
  1: $t2 := !=($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq2($t0: u64, $t1: u64): bool {
     var $t2: bool
     var $t3: &u64
     var $t4: &u64
  0: $t3 := borrow_local($t0)
  1: $t4 := borrow_local($t1)
  2: $t2 := !=($t3, $t4)
  3: return $t2
}


[variant baseline]
public fun m::neq3<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: #0
  0: $t3 := infer($t0)
  1: $t2 := !=($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq4<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: &#0
     var $t4: &#0
  0: $t3 := borrow_local($t0)
  1: $t4 := borrow_local($t1)
  2: $t2 := !=($t3, $t4)
  3: return $t2
}


[variant baseline]
public fun m::neq5($t0: bool, $t1: bool): bool {
     var $t2: bool
     var $t3: bool
  0: $t3 := infer($t0)
  1: $t2 := !=($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq6($t0: address, $t1: address): bool {
     var $t2: bool
     var $t3: address
  0: $t3 := infer($t0)
  1: $t2 := !=($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq7($t0: vector<u8>, $t1: vector<u8>): bool {
     var $t2: bool
     var $t3: vector<u8>
  0: $t3 := infer($t0)
  1: $t2 := !=($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq8($t0: vector<vector<u8>>, $t1: vector<vector<u8>>): bool {
     var $t2: bool
     var $t3: vector<vector<u8>>
  0: $t3 := infer($t0)
  1: $t2 := !=($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq9($t0: 0xcffa::m::Test1, $t1: 0xcffa::m::Test1): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test1
  0: $t3 := infer($t0)
  1: $t2 := !=($t3, $t1)
  2: return $t2
}

============ after uninitialized_use_checker: ================

[variant baseline]
public fun m::eq1($t0: u64, $t1: u64): u64 {
     var $t2: u64
     var $t3: bool
     var $t4: u64
  0: $t4 := infer($t0)
  1: $t3 := ==($t4, $t1)
  2: if ($t3) goto 3 else goto 6
  3: label L0
  4: $t2 := infer($t0)
  5: goto 8
  6: label L1
  7: $t2 := infer($t1)
  8: label L2
  9: return $t2
}


[variant baseline]
public fun m::eq10($t0: 0xcffa::m::Test2, $t1: 0xcffa::m::Test2): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test2
  0: $t3 := infer($t0)
  1: $t2 := ==($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::eq2($t0: u64, $t1: u64): bool {
     var $t2: bool
     var $t3: &u64
     var $t4: &u64
  0: $t3 := borrow_local($t0)
  1: $t4 := borrow_local($t1)
  2: $t2 := ==($t3, $t4)
  3: return $t2
}


[variant baseline]
public fun m::eq3<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: #0
  0: $t3 := infer($t0)
  1: $t2 := ==($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::eq4<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: &#0
     var $t4: &#0
  0: $t3 := borrow_local($t0)
  1: $t4 := borrow_local($t1)
  2: $t2 := ==($t3, $t4)
  3: return $t2
}


[variant baseline]
public fun m::eq5($t0: bool, $t1: bool): bool {
     var $t2: bool
     var $t3: bool
  0: $t3 := infer($t0)
  1: $t2 := ==($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::eq6($t0: address, $t1: address): bool {
     var $t2: bool
     var $t3: address
  0: $t3 := infer($t0)
  1: $t2 := ==($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::eq7($t0: vector<u8>, $t1: vector<u8>): bool {
     var $t2: bool
     var $t3: vector<u8>
  0: $t3 := infer($t0)
  1: $t2 := ==($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::eq8($t0: vector<vector<u8>>, $t1: vector<vector<u8>>): bool {
     var $t2: bool
     var $t3: vector<vector<u8>>
  0: $t3 := infer($t0)
  1: $t2 := ==($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::eq9($t0: 0xcffa::m::Test1, $t1: 0xcffa::m::Test1): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test1
  0: $t3 := infer($t0)
  1: $t2 := ==($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq1($t0: u64, $t1: u64): bool {
     var $t2: bool
     var $t3: u64
  0: $t3 := infer($t0)
  1: $t2 := !=($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq10($t0: 0xcffa::m::Test2, $t1: 0xcffa::m::Test2): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test2
  0: $t3 := infer($t0)
  1: $t2 := !=($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq2($t0: u64, $t1: u64): bool {
     var $t2: bool
     var $t3: &u64
     var $t4: &u64
  0: $t3 := borrow_local($t0)
  1: $t4 := borrow_local($t1)
  2: $t2 := !=($t3, $t4)
  3: return $t2
}


[variant baseline]
public fun m::neq3<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: #0
  0: $t3 := infer($t0)
  1: $t2 := !=($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq4<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: &#0
     var $t4: &#0
  0: $t3 := borrow_local($t0)
  1: $t4 := borrow_local($t1)
  2: $t2 := !=($t3, $t4)
  3: return $t2
}


[variant baseline]
public fun m::neq5($t0: bool, $t1: bool): bool {
     var $t2: bool
     var $t3: bool
  0: $t3 := infer($t0)
  1: $t2 := !=($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq6($t0: address, $t1: address): bool {
     var $t2: bool
     var $t3: address
  0: $t3 := infer($t0)
  1: $t2 := !=($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq7($t0: vector<u8>, $t1: vector<u8>): bool {
     var $t2: bool
     var $t3: vector<u8>
  0: $t3 := infer($t0)
  1: $t2 := !=($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq8($t0: vector<vector<u8>>, $t1: vector<vector<u8>>): bool {
     var $t2: bool
     var $t3: vector<vector<u8>>
  0: $t3 := infer($t0)
  1: $t2 := !=($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq9($t0: 0xcffa::m::Test1, $t1: 0xcffa::m::Test1): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test1
  0: $t3 := infer($t0)
  1: $t2 := !=($t3, $t1)
  2: return $t2
}

============ after LiveVarAnalysisProcessor: ================

[variant baseline]
public fun m::eq1($t0: u64, $t1: u64): u64 {
     var $t2: u64
     var $t3: bool
     var $t4: u64
     # live vars: $t0, $t1
  0: $t4 := infer($t0)
     # live vars: $t0, $t1, $t4
  1: $t3 := ==($t4, $t1)
     # live vars: $t0, $t1, $t3
  2: if ($t3) goto 3 else goto 6
     # live vars: $t0, $t1
  3: label L0
     # live vars: $t0
  4: $t2 := infer($t0)
     # live vars: $t2
  5: goto 8
     # live vars: $t0, $t1
  6: label L1
     # live vars: $t1
  7: $t2 := infer($t1)
     # live vars: $t2
  8: label L2
     # live vars: $t2
  9: return $t2
}


[variant baseline]
public fun m::eq10($t0: 0xcffa::m::Test2, $t1: 0xcffa::m::Test2): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test2
     # live vars: $t0, $t1
  0: $t3 := infer($t0)
     # live vars: $t1, $t3
  1: $t2 := ==($t3, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::eq2($t0: u64, $t1: u64): bool {
     var $t2: bool
     var $t3: &u64
     var $t4: &u64
     # live vars: $t0, $t1
  0: $t3 := borrow_local($t0)
     # live vars: $t1, $t3
  1: $t4 := borrow_local($t1)
     # live vars: $t3, $t4
  2: $t2 := ==($t3, $t4)
     # live vars: $t2
  3: return $t2
}


[variant baseline]
public fun m::eq3<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: #0
     # live vars: $t0, $t1
  0: $t3 := infer($t0)
     # live vars: $t1, $t3
  1: $t2 := ==($t3, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::eq4<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: &#0
     var $t4: &#0
     # live vars: $t0, $t1
  0: $t3 := borrow_local($t0)
     # live vars: $t1, $t3
  1: $t4 := borrow_local($t1)
     # live vars: $t3, $t4
  2: $t2 := ==($t3, $t4)
     # live vars: $t2
  3: return $t2
}


[variant baseline]
public fun m::eq5($t0: bool, $t1: bool): bool {
     var $t2: bool
     var $t3: bool
     # live vars: $t0, $t1
  0: $t3 := infer($t0)
     # live vars: $t1, $t3
  1: $t2 := ==($t3, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::eq6($t0: address, $t1: address): bool {
     var $t2: bool
     var $t3: address
     # live vars: $t0, $t1
  0: $t3 := infer($t0)
     # live vars: $t1, $t3
  1: $t2 := ==($t3, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::eq7($t0: vector<u8>, $t1: vector<u8>): bool {
     var $t2: bool
     var $t3: vector<u8>
     # live vars: $t0, $t1
  0: $t3 := infer($t0)
     # live vars: $t1, $t3
  1: $t2 := ==($t3, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::eq8($t0: vector<vector<u8>>, $t1: vector<vector<u8>>): bool {
     var $t2: bool
     var $t3: vector<vector<u8>>
     # live vars: $t0, $t1
  0: $t3 := infer($t0)
     # live vars: $t1, $t3
  1: $t2 := ==($t3, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::eq9($t0: 0xcffa::m::Test1, $t1: 0xcffa::m::Test1): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test1
     # live vars: $t0, $t1
  0: $t3 := infer($t0)
     # live vars: $t1, $t3
  1: $t2 := ==($t3, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::neq1($t0: u64, $t1: u64): bool {
     var $t2: bool
     var $t3: u64
     # live vars: $t0, $t1
  0: $t3 := infer($t0)
     # live vars: $t1, $t3
  1: $t2 := !=($t3, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::neq10($t0: 0xcffa::m::Test2, $t1: 0xcffa::m::Test2): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test2
     # live vars: $t0, $t1
  0: $t3 := infer($t0)
     # live vars: $t1, $t3
  1: $t2 := !=($t3, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::neq2($t0: u64, $t1: u64): bool {
     var $t2: bool
     var $t3: &u64
     var $t4: &u64
     # live vars: $t0, $t1
  0: $t3 := borrow_local($t0)
     # live vars: $t1, $t3
  1: $t4 := borrow_local($t1)
     # live vars: $t3, $t4
  2: $t2 := !=($t3, $t4)
     # live vars: $t2
  3: return $t2
}


[variant baseline]
public fun m::neq3<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: #0
     # live vars: $t0, $t1
  0: $t3 := infer($t0)
     # live vars: $t1, $t3
  1: $t2 := !=($t3, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::neq4<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: &#0
     var $t4: &#0
     # live vars: $t0, $t1
  0: $t3 := borrow_local($t0)
     # live vars: $t1, $t3
  1: $t4 := borrow_local($t1)
     # live vars: $t3, $t4
  2: $t2 := !=($t3, $t4)
     # live vars: $t2
  3: return $t2
}


[variant baseline]
public fun m::neq5($t0: bool, $t1: bool): bool {
     var $t2: bool
     var $t3: bool
     # live vars: $t0, $t1
  0: $t3 := infer($t0)
     # live vars: $t1, $t3
  1: $t2 := !=($t3, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::neq6($t0: address, $t1: address): bool {
     var $t2: bool
     var $t3: address
     # live vars: $t0, $t1
  0: $t3 := infer($t0)
     # live vars: $t1, $t3
  1: $t2 := !=($t3, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::neq7($t0: vector<u8>, $t1: vector<u8>): bool {
     var $t2: bool
     var $t3: vector<u8>
     # live vars: $t0, $t1
  0: $t3 := infer($t0)
     # live vars: $t1, $t3
  1: $t2 := !=($t3, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::neq8($t0: vector<vector<u8>>, $t1: vector<vector<u8>>): bool {
     var $t2: bool
     var $t3: vector<vector<u8>>
     # live vars: $t0, $t1
  0: $t3 := infer($t0)
     # live vars: $t1, $t3
  1: $t2 := !=($t3, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::neq9($t0: 0xcffa::m::Test1, $t1: 0xcffa::m::Test1): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test1
     # live vars: $t0, $t1
  0: $t3 := infer($t0)
     # live vars: $t1, $t3
  1: $t2 := !=($t3, $t1)
     # live vars: $t2
  2: return $t2
}

============ after UnusedAssignmentChecker: ================

[variant baseline]
public fun m::eq1($t0: u64, $t1: u64): u64 {
     var $t2: u64
     var $t3: bool
     var $t4: u64
     # live vars: $t0, $t1
  0: $t4 := infer($t0)
     # live vars: $t0, $t1, $t4
  1: $t3 := ==($t4, $t1)
     # live vars: $t0, $t1, $t3
  2: if ($t3) goto 3 else goto 6
     # live vars: $t0, $t1
  3: label L0
     # live vars: $t0
  4: $t2 := infer($t0)
     # live vars: $t2
  5: goto 8
     # live vars: $t0, $t1
  6: label L1
     # live vars: $t1
  7: $t2 := infer($t1)
     # live vars: $t2
  8: label L2
     # live vars: $t2
  9: return $t2
}


[variant baseline]
public fun m::eq10($t0: 0xcffa::m::Test2, $t1: 0xcffa::m::Test2): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test2
     # live vars: $t0, $t1
  0: $t3 := infer($t0)
     # live vars: $t1, $t3
  1: $t2 := ==($t3, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::eq2($t0: u64, $t1: u64): bool {
     var $t2: bool
     var $t3: &u64
     var $t4: &u64
     # live vars: $t0, $t1
  0: $t3 := borrow_local($t0)
     # live vars: $t1, $t3
  1: $t4 := borrow_local($t1)
     # live vars: $t3, $t4
  2: $t2 := ==($t3, $t4)
     # live vars: $t2
  3: return $t2
}


[variant baseline]
public fun m::eq3<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: #0
     # live vars: $t0, $t1
  0: $t3 := infer($t0)
     # live vars: $t1, $t3
  1: $t2 := ==($t3, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::eq4<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: &#0
     var $t4: &#0
     # live vars: $t0, $t1
  0: $t3 := borrow_local($t0)
     # live vars: $t1, $t3
  1: $t4 := borrow_local($t1)
     # live vars: $t3, $t4
  2: $t2 := ==($t3, $t4)
     # live vars: $t2
  3: return $t2
}


[variant baseline]
public fun m::eq5($t0: bool, $t1: bool): bool {
     var $t2: bool
     var $t3: bool
     # live vars: $t0, $t1
  0: $t3 := infer($t0)
     # live vars: $t1, $t3
  1: $t2 := ==($t3, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::eq6($t0: address, $t1: address): bool {
     var $t2: bool
     var $t3: address
     # live vars: $t0, $t1
  0: $t3 := infer($t0)
     # live vars: $t1, $t3
  1: $t2 := ==($t3, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::eq7($t0: vector<u8>, $t1: vector<u8>): bool {
     var $t2: bool
     var $t3: vector<u8>
     # live vars: $t0, $t1
  0: $t3 := infer($t0)
     # live vars: $t1, $t3
  1: $t2 := ==($t3, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::eq8($t0: vector<vector<u8>>, $t1: vector<vector<u8>>): bool {
     var $t2: bool
     var $t3: vector<vector<u8>>
     # live vars: $t0, $t1
  0: $t3 := infer($t0)
     # live vars: $t1, $t3
  1: $t2 := ==($t3, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::eq9($t0: 0xcffa::m::Test1, $t1: 0xcffa::m::Test1): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test1
     # live vars: $t0, $t1
  0: $t3 := infer($t0)
     # live vars: $t1, $t3
  1: $t2 := ==($t3, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::neq1($t0: u64, $t1: u64): bool {
     var $t2: bool
     var $t3: u64
     # live vars: $t0, $t1
  0: $t3 := infer($t0)
     # live vars: $t1, $t3
  1: $t2 := !=($t3, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::neq10($t0: 0xcffa::m::Test2, $t1: 0xcffa::m::Test2): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test2
     # live vars: $t0, $t1
  0: $t3 := infer($t0)
     # live vars: $t1, $t3
  1: $t2 := !=($t3, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::neq2($t0: u64, $t1: u64): bool {
     var $t2: bool
     var $t3: &u64
     var $t4: &u64
     # live vars: $t0, $t1
  0: $t3 := borrow_local($t0)
     # live vars: $t1, $t3
  1: $t4 := borrow_local($t1)
     # live vars: $t3, $t4
  2: $t2 := !=($t3, $t4)
     # live vars: $t2
  3: return $t2
}


[variant baseline]
public fun m::neq3<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: #0
     # live vars: $t0, $t1
  0: $t3 := infer($t0)
     # live vars: $t1, $t3
  1: $t2 := !=($t3, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::neq4<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: &#0
     var $t4: &#0
     # live vars: $t0, $t1
  0: $t3 := borrow_local($t0)
     # live vars: $t1, $t3
  1: $t4 := borrow_local($t1)
     # live vars: $t3, $t4
  2: $t2 := !=($t3, $t4)
     # live vars: $t2
  3: return $t2
}


[variant baseline]
public fun m::neq5($t0: bool, $t1: bool): bool {
     var $t2: bool
     var $t3: bool
     # live vars: $t0, $t1
  0: $t3 := infer($t0)
     # live vars: $t1, $t3
  1: $t2 := !=($t3, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::neq6($t0: address, $t1: address): bool {
     var $t2: bool
     var $t3: address
     # live vars: $t0, $t1
  0: $t3 := infer($t0)
     # live vars: $t1, $t3
  1: $t2 := !=($t3, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::neq7($t0: vector<u8>, $t1: vector<u8>): bool {
     var $t2: bool
     var $t3: vector<u8>
     # live vars: $t0, $t1
  0: $t3 := infer($t0)
     # live vars: $t1, $t3
  1: $t2 := !=($t3, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::neq8($t0: vector<vector<u8>>, $t1: vector<vector<u8>>): bool {
     var $t2: bool
     var $t3: vector<vector<u8>>
     # live vars: $t0, $t1
  0: $t3 := infer($t0)
     # live vars: $t1, $t3
  1: $t2 := !=($t3, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::neq9($t0: 0xcffa::m::Test1, $t1: 0xcffa::m::Test1): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test1
     # live vars: $t0, $t1
  0: $t3 := infer($t0)
     # live vars: $t1, $t3
  1: $t2 := !=($t3, $t1)
     # live vars: $t2
  2: return $t2
}

============ after LiveVarAnalysisProcessor: ================

[variant baseline]
public fun m::eq1($t0: u64, $t1: u64): u64 {
     var $t2: u64
     var $t3: bool
     var $t4: u64
     # live vars: $t0, $t1
  0: $t4 := infer($t0)
     # live vars: $t0, $t1, $t4
  1: $t3 := ==($t4, $t1)
     # live vars: $t0, $t1, $t3
  2: if ($t3) goto 3 else goto 6
     # live vars: $t0, $t1
  3: label L0
     # live vars: $t0
  4: $t2 := infer($t0)
     # live vars: $t2
  5: goto 8
     # live vars: $t0, $t1
  6: label L1
     # live vars: $t1
  7: $t2 := infer($t1)
     # live vars: $t2
  8: label L2
     # live vars: $t2
  9: return $t2
}


[variant baseline]
public fun m::eq10($t0: 0xcffa::m::Test2, $t1: 0xcffa::m::Test2): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test2
     # live vars: $t0, $t1
  0: $t3 := infer($t0)
     # live vars: $t1, $t3
  1: $t2 := ==($t3, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::eq2($t0: u64, $t1: u64): bool {
     var $t2: bool
     var $t3: &u64
     var $t4: &u64
     # live vars: $t0, $t1
  0: $t3 := borrow_local($t0)
     # live vars: $t1, $t3
  1: $t4 := borrow_local($t1)
     # live vars: $t3, $t4
  2: $t2 := ==($t3, $t4)
     # live vars: $t2
  3: return $t2
}


[variant baseline]
public fun m::eq3<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: #0
     # live vars: $t0, $t1
  0: $t3 := infer($t0)
     # live vars: $t1, $t3
  1: $t2 := ==($t3, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::eq4<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: &#0
     var $t4: &#0
     # live vars: $t0, $t1
  0: $t3 := borrow_local($t0)
     # live vars: $t1, $t3
  1: $t4 := borrow_local($t1)
     # live vars: $t3, $t4
  2: $t2 := ==($t3, $t4)
     # live vars: $t2
  3: return $t2
}


[variant baseline]
public fun m::eq5($t0: bool, $t1: bool): bool {
     var $t2: bool
     var $t3: bool
     # live vars: $t0, $t1
  0: $t3 := infer($t0)
     # live vars: $t1, $t3
  1: $t2 := ==($t3, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::eq6($t0: address, $t1: address): bool {
     var $t2: bool
     var $t3: address
     # live vars: $t0, $t1
  0: $t3 := infer($t0)
     # live vars: $t1, $t3
  1: $t2 := ==($t3, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::eq7($t0: vector<u8>, $t1: vector<u8>): bool {
     var $t2: bool
     var $t3: vector<u8>
     # live vars: $t0, $t1
  0: $t3 := infer($t0)
     # live vars: $t1, $t3
  1: $t2 := ==($t3, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::eq8($t0: vector<vector<u8>>, $t1: vector<vector<u8>>): bool {
     var $t2: bool
     var $t3: vector<vector<u8>>
     # live vars: $t0, $t1
  0: $t3 := infer($t0)
     # live vars: $t1, $t3
  1: $t2 := ==($t3, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::eq9($t0: 0xcffa::m::Test1, $t1: 0xcffa::m::Test1): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test1
     # live vars: $t0, $t1
  0: $t3 := infer($t0)
     # live vars: $t1, $t3
  1: $t2 := ==($t3, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::neq1($t0: u64, $t1: u64): bool {
     var $t2: bool
     var $t3: u64
     # live vars: $t0, $t1
  0: $t3 := infer($t0)
     # live vars: $t1, $t3
  1: $t2 := !=($t3, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::neq10($t0: 0xcffa::m::Test2, $t1: 0xcffa::m::Test2): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test2
     # live vars: $t0, $t1
  0: $t3 := infer($t0)
     # live vars: $t1, $t3
  1: $t2 := !=($t3, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::neq2($t0: u64, $t1: u64): bool {
     var $t2: bool
     var $t3: &u64
     var $t4: &u64
     # live vars: $t0, $t1
  0: $t3 := borrow_local($t0)
     # live vars: $t1, $t3
  1: $t4 := borrow_local($t1)
     # live vars: $t3, $t4
  2: $t2 := !=($t3, $t4)
     # live vars: $t2
  3: return $t2
}


[variant baseline]
public fun m::neq3<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: #0
     # live vars: $t0, $t1
  0: $t3 := infer($t0)
     # live vars: $t1, $t3
  1: $t2 := !=($t3, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::neq4<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: &#0
     var $t4: &#0
     # live vars: $t0, $t1
  0: $t3 := borrow_local($t0)
     # live vars: $t1, $t3
  1: $t4 := borrow_local($t1)
     # live vars: $t3, $t4
  2: $t2 := !=($t3, $t4)
     # live vars: $t2
  3: return $t2
}


[variant baseline]
public fun m::neq5($t0: bool, $t1: bool): bool {
     var $t2: bool
     var $t3: bool
     # live vars: $t0, $t1
  0: $t3 := infer($t0)
     # live vars: $t1, $t3
  1: $t2 := !=($t3, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::neq6($t0: address, $t1: address): bool {
     var $t2: bool
     var $t3: address
     # live vars: $t0, $t1
  0: $t3 := infer($t0)
     # live vars: $t1, $t3
  1: $t2 := !=($t3, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::neq7($t0: vector<u8>, $t1: vector<u8>): bool {
     var $t2: bool
     var $t3: vector<u8>
     # live vars: $t0, $t1
  0: $t3 := infer($t0)
     # live vars: $t1, $t3
  1: $t2 := !=($t3, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::neq8($t0: vector<vector<u8>>, $t1: vector<vector<u8>>): bool {
     var $t2: bool
     var $t3: vector<vector<u8>>
     # live vars: $t0, $t1
  0: $t3 := infer($t0)
     # live vars: $t1, $t3
  1: $t2 := !=($t3, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::neq9($t0: 0xcffa::m::Test1, $t1: 0xcffa::m::Test1): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test1
     # live vars: $t0, $t1
  0: $t3 := infer($t0)
     # live vars: $t1, $t3
  1: $t2 := !=($t3, $t1)
     # live vars: $t2
  2: return $t2
}

============ after ReferenceSafetyProcessor: ================

[variant baseline]
public fun m::eq1($t0: u64, $t1: u64): u64 {
     var $t2: u64
     var $t3: bool
     var $t4: u64
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t4 := infer($t0)
     # live vars: $t0, $t1, $t4
     # refs: []
     #
  1: $t3 := ==($t4, $t1)
     # live vars: $t0, $t1, $t3
     # refs: []
     #
  2: if ($t3) goto 3 else goto 6
     # live vars: $t0, $t1
     # refs: []
     #
  3: label L0
     # live vars: $t0
     # refs: []
     #
  4: $t2 := infer($t0)
     # live vars: $t2
     # refs: []
     #
  5: goto 8
     # live vars: $t0, $t1
     # refs: []
     #
  6: label L1
     # live vars: $t1
     # refs: []
     #
  7: $t2 := infer($t1)
     # live vars: $t2
     # refs: []
     #
  8: label L2
     # live vars: $t2
     # refs: []
     #
  9: return $t2
}


[variant baseline]
public fun m::eq10($t0: 0xcffa::m::Test2, $t1: 0xcffa::m::Test2): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test2
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t3 := infer($t0)
     # live vars: $t1, $t3
     # refs: []
     #
  1: $t2 := ==($t3, $t1)
     # live vars: $t2
     # refs: []
     #
  2: return $t2
}


[variant baseline]
public fun m::eq2($t0: u64, $t1: u64): bool {
     var $t2: bool
     var $t3: &u64
     var $t4: &u64
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t3 := borrow_local($t0)
     # live vars: $t1, $t3
     # refs: [$t3 => #3]
     # #3
     #   <no edges>
     # #root
     #   => #3 via [local `x`] at line 19
     #
  1: $t4 := borrow_local($t1)
     # live vars: $t3, $t4
     # refs: [$t3 => #3, $t4 => #4]
     # #3
     #   <no edges>
     # #4
     #   <no edges>
     # #root
     #   => #3 via [local `x`] at line 19
     #   => #4 via [local `y`] at line 19
     #
  2: $t2 := ==($t3, $t4)
     # live vars: $t2
     # refs: []
     #
  3: return $t2
}


[variant baseline]
public fun m::eq3<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: #0
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t3 := infer($t0)
     # live vars: $t1, $t3
     # refs: []
     #
  1: $t2 := ==($t3, $t1)
     # live vars: $t2
     # refs: []
     #
  2: return $t2
}


[variant baseline]
public fun m::eq4<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: &#0
     var $t4: &#0
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t3 := borrow_local($t0)
     # live vars: $t1, $t3
     # refs: [$t3 => #3]
     # #3
     #   <no edges>
     # #root
     #   => #3 via [local `x`] at line 27
     #
  1: $t4 := borrow_local($t1)
     # live vars: $t3, $t4
     # refs: [$t3 => #3, $t4 => #4]
     # #3
     #   <no edges>
     # #4
     #   <no edges>
     # #root
     #   => #3 via [local `x`] at line 27
     #   => #4 via [local `y`] at line 27
     #
  2: $t2 := ==($t3, $t4)
     # live vars: $t2
     # refs: []
     #
  3: return $t2
}


[variant baseline]
public fun m::eq5($t0: bool, $t1: bool): bool {
     var $t2: bool
     var $t3: bool
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t3 := infer($t0)
     # live vars: $t1, $t3
     # refs: []
     #
  1: $t2 := ==($t3, $t1)
     # live vars: $t2
     # refs: []
     #
  2: return $t2
}


[variant baseline]
public fun m::eq6($t0: address, $t1: address): bool {
     var $t2: bool
     var $t3: address
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t3 := infer($t0)
     # live vars: $t1, $t3
     # refs: []
     #
  1: $t2 := ==($t3, $t1)
     # live vars: $t2
     # refs: []
     #
  2: return $t2
}


[variant baseline]
public fun m::eq7($t0: vector<u8>, $t1: vector<u8>): bool {
     var $t2: bool
     var $t3: vector<u8>
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t3 := infer($t0)
     # live vars: $t1, $t3
     # refs: []
     #
  1: $t2 := ==($t3, $t1)
     # live vars: $t2
     # refs: []
     #
  2: return $t2
}


[variant baseline]
public fun m::eq8($t0: vector<vector<u8>>, $t1: vector<vector<u8>>): bool {
     var $t2: bool
     var $t3: vector<vector<u8>>
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t3 := infer($t0)
     # live vars: $t1, $t3
     # refs: []
     #
  1: $t2 := ==($t3, $t1)
     # live vars: $t2
     # refs: []
     #
  2: return $t2
}


[variant baseline]
public fun m::eq9($t0: 0xcffa::m::Test1, $t1: 0xcffa::m::Test1): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test1
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t3 := infer($t0)
     # live vars: $t1, $t3
     # refs: []
     #
  1: $t2 := ==($t3, $t1)
     # live vars: $t2
     # refs: []
     #
  2: return $t2
}


[variant baseline]
public fun m::neq1($t0: u64, $t1: u64): bool {
     var $t2: bool
     var $t3: u64
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t3 := infer($t0)
     # live vars: $t1, $t3
     # refs: []
     #
  1: $t2 := !=($t3, $t1)
     # live vars: $t2
     # refs: []
     #
  2: return $t2
}


[variant baseline]
public fun m::neq10($t0: 0xcffa::m::Test2, $t1: 0xcffa::m::Test2): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test2
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t3 := infer($t0)
     # live vars: $t1, $t3
     # refs: []
     #
  1: $t2 := !=($t3, $t1)
     # live vars: $t2
     # refs: []
     #
  2: return $t2
}


[variant baseline]
public fun m::neq2($t0: u64, $t1: u64): bool {
     var $t2: bool
     var $t3: &u64
     var $t4: &u64
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t3 := borrow_local($t0)
     # live vars: $t1, $t3
     # refs: [$t3 => #3]
     # #3
     #   <no edges>
     # #root
     #   => #3 via [local `x`] at line 59
     #
  1: $t4 := borrow_local($t1)
     # live vars: $t3, $t4
     # refs: [$t3 => #3, $t4 => #4]
     # #3
     #   <no edges>
     # #4
     #   <no edges>
     # #root
     #   => #3 via [local `x`] at line 59
     #   => #4 via [local `y`] at line 59
     #
  2: $t2 := !=($t3, $t4)
     # live vars: $t2
     # refs: []
     #
  3: return $t2
}


[variant baseline]
public fun m::neq3<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: #0
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t3 := infer($t0)
     # live vars: $t1, $t3
     # refs: []
     #
  1: $t2 := !=($t3, $t1)
     # live vars: $t2
     # refs: []
     #
  2: return $t2
}


[variant baseline]
public fun m::neq4<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: &#0
     var $t4: &#0
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t3 := borrow_local($t0)
     # live vars: $t1, $t3
     # refs: [$t3 => #3]
     # #3
     #   <no edges>
     # #root
     #   => #3 via [local `x`] at line 67
     #
  1: $t4 := borrow_local($t1)
     # live vars: $t3, $t4
     # refs: [$t3 => #3, $t4 => #4]
     # #3
     #   <no edges>
     # #4
     #   <no edges>
     # #root
     #   => #3 via [local `x`] at line 67
     #   => #4 via [local `y`] at line 67
     #
  2: $t2 := !=($t3, $t4)
     # live vars: $t2
     # refs: []
     #
  3: return $t2
}


[variant baseline]
public fun m::neq5($t0: bool, $t1: bool): bool {
     var $t2: bool
     var $t3: bool
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t3 := infer($t0)
     # live vars: $t1, $t3
     # refs: []
     #
  1: $t2 := !=($t3, $t1)
     # live vars: $t2
     # refs: []
     #
  2: return $t2
}


[variant baseline]
public fun m::neq6($t0: address, $t1: address): bool {
     var $t2: bool
     var $t3: address
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t3 := infer($t0)
     # live vars: $t1, $t3
     # refs: []
     #
  1: $t2 := !=($t3, $t1)
     # live vars: $t2
     # refs: []
     #
  2: return $t2
}


[variant baseline]
public fun m::neq7($t0: vector<u8>, $t1: vector<u8>): bool {
     var $t2: bool
     var $t3: vector<u8>
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t3 := infer($t0)
     # live vars: $t1, $t3
     # refs: []
     #
  1: $t2 := !=($t3, $t1)
     # live vars: $t2
     # refs: []
     #
  2: return $t2
}


[variant baseline]
public fun m::neq8($t0: vector<vector<u8>>, $t1: vector<vector<u8>>): bool {
     var $t2: bool
     var $t3: vector<vector<u8>>
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t3 := infer($t0)
     # live vars: $t1, $t3
     # refs: []
     #
  1: $t2 := !=($t3, $t1)
     # live vars: $t2
     # refs: []
     #
  2: return $t2
}


[variant baseline]
public fun m::neq9($t0: 0xcffa::m::Test1, $t1: 0xcffa::m::Test1): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test1
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t3 := infer($t0)
     # live vars: $t1, $t3
     # refs: []
     #
  1: $t2 := !=($t3, $t1)
     # live vars: $t2
     # refs: []
     #
  2: return $t2
}

============ after AbortAnalysisProcessor: ================

[variant baseline]
public fun m::eq1($t0: u64, $t1: u64): u64 {
     var $t2: u64
     var $t3: bool
     var $t4: u64
     # abort state: {returns}
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t4 := infer($t0)
     # abort state: {returns}
     # live vars: $t0, $t1, $t4
     # refs: []
     #
  1: $t3 := ==($t4, $t1)
     # abort state: {returns}
     # live vars: $t0, $t1, $t3
     # refs: []
     #
  2: if ($t3) goto 3 else goto 6
     # abort state: {returns}
     # live vars: $t0, $t1
     # refs: []
     #
  3: label L0
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
  4: $t2 := infer($t0)
     # abort state: {returns}
     # live vars: $t2
     # refs: []
     #
  5: goto 8
     # abort state: {returns}
     # live vars: $t0, $t1
     # refs: []
     #
  6: label L1
     # abort state: {returns}
     # live vars: $t1
     # refs: []
     #
  7: $t2 := infer($t1)
     # abort state: {returns}
     # live vars: $t2
     # refs: []
     #
  8: label L2
     # abort state: {returns}
     # live vars: $t2
     # refs: []
     #
  9: return $t2
}


[variant baseline]
public fun m::eq10($t0: 0xcffa::m::Test2, $t1: 0xcffa::m::Test2): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test2
     # abort state: {returns}
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t3 := infer($t0)
     # abort state: {returns}
     # live vars: $t1, $t3
     # refs: []
     #
  1: $t2 := ==($t3, $t1)
     # abort state: {returns}
     # live vars: $t2
     # refs: []
     #
  2: return $t2
}


[variant baseline]
public fun m::eq2($t0: u64, $t1: u64): bool {
     var $t2: bool
     var $t3: &u64
     var $t4: &u64
     # abort state: {returns}
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t3 := borrow_local($t0)
     # abort state: {returns}
     # live vars: $t1, $t3
     # refs: [$t3 => #3]
     # #3
     #   <no edges>
     # #root
     #   => #3 via [local `x`] at line 19
     #
  1: $t4 := borrow_local($t1)
     # abort state: {returns}
     # live vars: $t3, $t4
     # refs: [$t3 => #3, $t4 => #4]
     # #3
     #   <no edges>
     # #4
     #   <no edges>
     # #root
     #   => #3 via [local `x`] at line 19
     #   => #4 via [local `y`] at line 19
     #
  2: $t2 := ==($t3, $t4)
     # abort state: {returns}
     # live vars: $t2
     # refs: []
     #
  3: return $t2
}


[variant baseline]
public fun m::eq3<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: #0
     # abort state: {returns}
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t3 := infer($t0)
     # abort state: {returns}
     # live vars: $t1, $t3
     # refs: []
     #
  1: $t2 := ==($t3, $t1)
     # abort state: {returns}
     # live vars: $t2
     # refs: []
     #
  2: return $t2
}


[variant baseline]
public fun m::eq4<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: &#0
     var $t4: &#0
     # abort state: {returns}
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t3 := borrow_local($t0)
     # abort state: {returns}
     # live vars: $t1, $t3
     # refs: [$t3 => #3]
     # #3
     #   <no edges>
     # #root
     #   => #3 via [local `x`] at line 27
     #
  1: $t4 := borrow_local($t1)
     # abort state: {returns}
     # live vars: $t3, $t4
     # refs: [$t3 => #3, $t4 => #4]
     # #3
     #   <no edges>
     # #4
     #   <no edges>
     # #root
     #   => #3 via [local `x`] at line 27
     #   => #4 via [local `y`] at line 27
     #
  2: $t2 := ==($t3, $t4)
     # abort state: {returns}
     # live vars: $t2
     # refs: []
     #
  3: return $t2
}


[variant baseline]
public fun m::eq5($t0: bool, $t1: bool): bool {
     var $t2: bool
     var $t3: bool
     # abort state: {returns}
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t3 := infer($t0)
     # abort state: {returns}
     # live vars: $t1, $t3
     # refs: []
     #
  1: $t2 := ==($t3, $t1)
     # abort state: {returns}
     # live vars: $t2
     # refs: []
     #
  2: return $t2
}


[variant baseline]
public fun m::eq6($t0: address, $t1: address): bool {
     var $t2: bool
     var $t3: address
     # abort state: {returns}
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t3 := infer($t0)
     # abort state: {returns}
     # live vars: $t1, $t3
     # refs: []
     #
  1: $t2 := ==($t3, $t1)
     # abort state: {returns}
     # live vars: $t2
     # refs: []
     #
  2: return $t2
}


[variant baseline]
public fun m::eq7($t0: vector<u8>, $t1: vector<u8>): bool {
     var $t2: bool
     var $t3: vector<u8>
     # abort state: {returns}
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t3 := infer($t0)
     # abort state: {returns}
     # live vars: $t1, $t3
     # refs: []
     #
  1: $t2 := ==($t3, $t1)
     # abort state: {returns}
     # live vars: $t2
     # refs: []
     #
  2: return $t2
}


[variant baseline]
public fun m::eq8($t0: vector<vector<u8>>, $t1: vector<vector<u8>>): bool {
     var $t2: bool
     var $t3: vector<vector<u8>>
     # abort state: {returns}
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t3 := infer($t0)
     # abort state: {returns}
     # live vars: $t1, $t3
     # refs: []
     #
  1: $t2 := ==($t3, $t1)
     # abort state: {returns}
     # live vars: $t2
     # refs: []
     #
  2: return $t2
}


[variant baseline]
public fun m::eq9($t0: 0xcffa::m::Test1, $t1: 0xcffa::m::Test1): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test1
     # abort state: {returns}
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t3 := infer($t0)
     # abort state: {returns}
     # live vars: $t1, $t3
     # refs: []
     #
  1: $t2 := ==($t3, $t1)
     # abort state: {returns}
     # live vars: $t2
     # refs: []
     #
  2: return $t2
}


[variant baseline]
public fun m::neq1($t0: u64, $t1: u64): bool {
     var $t2: bool
     var $t3: u64
     # abort state: {returns}
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t3 := infer($t0)
     # abort state: {returns}
     # live vars: $t1, $t3
     # refs: []
     #
  1: $t2 := !=($t3, $t1)
     # abort state: {returns}
     # live vars: $t2
     # refs: []
     #
  2: return $t2
}


[variant baseline]
public fun m::neq10($t0: 0xcffa::m::Test2, $t1: 0xcffa::m::Test2): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test2
     # abort state: {returns}
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t3 := infer($t0)
     # abort state: {returns}
     # live vars: $t1, $t3
     # refs: []
     #
  1: $t2 := !=($t3, $t1)
     # abort state: {returns}
     # live vars: $t2
     # refs: []
     #
  2: return $t2
}


[variant baseline]
public fun m::neq2($t0: u64, $t1: u64): bool {
     var $t2: bool
     var $t3: &u64
     var $t4: &u64
     # abort state: {returns}
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t3 := borrow_local($t0)
     # abort state: {returns}
     # live vars: $t1, $t3
     # refs: [$t3 => #3]
     # #3
     #   <no edges>
     # #root
     #   => #3 via [local `x`] at line 59
     #
  1: $t4 := borrow_local($t1)
     # abort state: {returns}
     # live vars: $t3, $t4
     # refs: [$t3 => #3, $t4 => #4]
     # #3
     #   <no edges>
     # #4
     #   <no edges>
     # #root
     #   => #3 via [local `x`] at line 59
     #   => #4 via [local `y`] at line 59
     #
  2: $t2 := !=($t3, $t4)
     # abort state: {returns}
     # live vars: $t2
     # refs: []
     #
  3: return $t2
}


[variant baseline]
public fun m::neq3<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: #0
     # abort state: {returns}
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t3 := infer($t0)
     # abort state: {returns}
     # live vars: $t1, $t3
     # refs: []
     #
  1: $t2 := !=($t3, $t1)
     # abort state: {returns}
     # live vars: $t2
     # refs: []
     #
  2: return $t2
}


[variant baseline]
public fun m::neq4<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: &#0
     var $t4: &#0
     # abort state: {returns}
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t3 := borrow_local($t0)
     # abort state: {returns}
     # live vars: $t1, $t3
     # refs: [$t3 => #3]
     # #3
     #   <no edges>
     # #root
     #   => #3 via [local `x`] at line 67
     #
  1: $t4 := borrow_local($t1)
     # abort state: {returns}
     # live vars: $t3, $t4
     # refs: [$t3 => #3, $t4 => #4]
     # #3
     #   <no edges>
     # #4
     #   <no edges>
     # #root
     #   => #3 via [local `x`] at line 67
     #   => #4 via [local `y`] at line 67
     #
  2: $t2 := !=($t3, $t4)
     # abort state: {returns}
     # live vars: $t2
     # refs: []
     #
  3: return $t2
}


[variant baseline]
public fun m::neq5($t0: bool, $t1: bool): bool {
     var $t2: bool
     var $t3: bool
     # abort state: {returns}
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t3 := infer($t0)
     # abort state: {returns}
     # live vars: $t1, $t3
     # refs: []
     #
  1: $t2 := !=($t3, $t1)
     # abort state: {returns}
     # live vars: $t2
     # refs: []
     #
  2: return $t2
}


[variant baseline]
public fun m::neq6($t0: address, $t1: address): bool {
     var $t2: bool
     var $t3: address
     # abort state: {returns}
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t3 := infer($t0)
     # abort state: {returns}
     # live vars: $t1, $t3
     # refs: []
     #
  1: $t2 := !=($t3, $t1)
     # abort state: {returns}
     # live vars: $t2
     # refs: []
     #
  2: return $t2
}


[variant baseline]
public fun m::neq7($t0: vector<u8>, $t1: vector<u8>): bool {
     var $t2: bool
     var $t3: vector<u8>
     # abort state: {returns}
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t3 := infer($t0)
     # abort state: {returns}
     # live vars: $t1, $t3
     # refs: []
     #
  1: $t2 := !=($t3, $t1)
     # abort state: {returns}
     # live vars: $t2
     # refs: []
     #
  2: return $t2
}


[variant baseline]
public fun m::neq8($t0: vector<vector<u8>>, $t1: vector<vector<u8>>): bool {
     var $t2: bool
     var $t3: vector<vector<u8>>
     # abort state: {returns}
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t3 := infer($t0)
     # abort state: {returns}
     # live vars: $t1, $t3
     # refs: []
     #
  1: $t2 := !=($t3, $t1)
     # abort state: {returns}
     # live vars: $t2
     # refs: []
     #
  2: return $t2
}


[variant baseline]
public fun m::neq9($t0: 0xcffa::m::Test1, $t1: 0xcffa::m::Test1): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test1
     # abort state: {returns}
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t3 := infer($t0)
     # abort state: {returns}
     # live vars: $t1, $t3
     # refs: []
     #
  1: $t2 := !=($t3, $t1)
     # abort state: {returns}
     # live vars: $t2
     # refs: []
     #
  2: return $t2
}

============ after AbilityProcessor: ================

[variant baseline]
public fun m::eq1($t0: u64, $t1: u64): u64 {
     var $t2: u64
     var $t3: bool
     var $t4: u64
  0: $t4 := copy($t0)
  1: $t3 := ==($t4, $t1)
  2: if ($t3) goto 3 else goto 6
  3: label L0
  4: $t2 := move($t0)
  5: goto 8
  6: label L1
  7: $t2 := move($t1)
  8: label L2
  9: return $t2
}


[variant baseline]
public fun m::eq10($t0: 0xcffa::m::Test2, $t1: 0xcffa::m::Test2): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test2
  0: $t3 := move($t0)
  1: $t2 := ==($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::eq2($t0: u64, $t1: u64): bool {
     var $t2: bool
     var $t3: &u64
     var $t4: &u64
  0: $t3 := borrow_local($t0)
  1: $t4 := borrow_local($t1)
  2: $t2 := ==($t3, $t4)
  3: return $t2
}


[variant baseline]
public fun m::eq3<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: #0
  0: $t3 := move($t0)
  1: $t2 := ==($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::eq4<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: &#0
     var $t4: &#0
  0: $t3 := borrow_local($t0)
  1: $t4 := borrow_local($t1)
  2: $t2 := ==($t3, $t4)
  3: return $t2
}


[variant baseline]
public fun m::eq5($t0: bool, $t1: bool): bool {
     var $t2: bool
     var $t3: bool
  0: $t3 := move($t0)
  1: $t2 := ==($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::eq6($t0: address, $t1: address): bool {
     var $t2: bool
     var $t3: address
  0: $t3 := move($t0)
  1: $t2 := ==($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::eq7($t0: vector<u8>, $t1: vector<u8>): bool {
     var $t2: bool
     var $t3: vector<u8>
  0: $t3 := move($t0)
  1: $t2 := ==($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::eq8($t0: vector<vector<u8>>, $t1: vector<vector<u8>>): bool {
     var $t2: bool
     var $t3: vector<vector<u8>>
  0: $t3 := move($t0)
  1: $t2 := ==($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::eq9($t0: 0xcffa::m::Test1, $t1: 0xcffa::m::Test1): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test1
  0: $t3 := move($t0)
  1: $t2 := ==($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq1($t0: u64, $t1: u64): bool {
     var $t2: bool
     var $t3: u64
  0: $t3 := move($t0)
  1: $t2 := !=($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq10($t0: 0xcffa::m::Test2, $t1: 0xcffa::m::Test2): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test2
  0: $t3 := move($t0)
  1: $t2 := !=($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq2($t0: u64, $t1: u64): bool {
     var $t2: bool
     var $t3: &u64
     var $t4: &u64
  0: $t3 := borrow_local($t0)
  1: $t4 := borrow_local($t1)
  2: $t2 := !=($t3, $t4)
  3: return $t2
}


[variant baseline]
public fun m::neq3<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: #0
  0: $t3 := move($t0)
  1: $t2 := !=($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq4<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: &#0
     var $t4: &#0
  0: $t3 := borrow_local($t0)
  1: $t4 := borrow_local($t1)
  2: $t2 := !=($t3, $t4)
  3: return $t2
}


[variant baseline]
public fun m::neq5($t0: bool, $t1: bool): bool {
     var $t2: bool
     var $t3: bool
  0: $t3 := move($t0)
  1: $t2 := !=($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq6($t0: address, $t1: address): bool {
     var $t2: bool
     var $t3: address
  0: $t3 := move($t0)
  1: $t2 := !=($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq7($t0: vector<u8>, $t1: vector<u8>): bool {
     var $t2: bool
     var $t3: vector<u8>
  0: $t3 := move($t0)
  1: $t2 := !=($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq8($t0: vector<vector<u8>>, $t1: vector<vector<u8>>): bool {
     var $t2: bool
     var $t3: vector<vector<u8>>
  0: $t3 := move($t0)
  1: $t2 := !=($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq9($t0: 0xcffa::m::Test1, $t1: 0xcffa::m::Test1): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test1
  0: $t3 := move($t0)
  1: $t2 := !=($t3, $t1)
  2: return $t2
}

// -- Model dump before env processor pipeline:
module 0xcffa::m {
    struct Test1 {
        a: u8,
    }
    struct Test2 {
        a: vector<u8>,
    }
    public fun eq1(x: u64,y: u64): u64 {
        if Eq<u64>(x, y) {
          x
        } else {
          y
        }
    }
    public fun eq10(x: Test2,y: Test2): bool {
        Eq<Test2>(x, y)
    }
    public fun eq2(x: u64,y: u64): bool {
        Eq<u64>(Borrow(Immutable)(x), Borrow(Immutable)(y))
    }
    public fun eq3<T>(x: T,y: T): bool {
        Eq<T>(x, y)
    }
    public fun eq4<T>(x: T,y: T): bool {
        Eq<T>(Borrow(Immutable)(x), Borrow(Immutable)(y))
    }
    public fun eq5(x: bool,y: bool): bool {
        Eq<bool>(x, y)
    }
    public fun eq6(x: address,y: address): bool {
        Eq<address>(x, y)
    }
    public fun eq7(x: vector<u8>,y: vector<u8>): bool {
        Eq<vector<u8>>(x, y)
    }
    public fun eq8(x: vector<vector<u8>>,y: vector<vector<u8>>): bool {
        Eq<vector<vector<u8>>>(x, y)
    }
    public fun eq9(x: Test1,y: Test1): bool {
        Eq<Test1>(x, y)
    }
    public fun neq1(x: u64,y: u64): bool {
        Neq<u64>(x, y)
    }
    public fun neq10(x: Test2,y: Test2): bool {
        Neq<Test2>(x, y)
    }
    public fun neq2(x: u64,y: u64): bool {
        Neq<u64>(Borrow(Immutable)(x), Borrow(Immutable)(y))
    }
    public fun neq3<T>(x: T,y: T): bool {
        Neq<T>(x, y)
    }
    public fun neq4<T>(x: T,y: T): bool {
        Neq<T>(Borrow(Immutable)(x), Borrow(Immutable)(y))
    }
    public fun neq5(x: bool,y: bool): bool {
        Neq<bool>(x, y)
    }
    public fun neq6(x: address,y: address): bool {
        Neq<address>(x, y)
    }
    public fun neq7(x: vector<u8>,y: vector<u8>): bool {
        Neq<vector<u8>>(x, y)
    }
    public fun neq8(x: vector<vector<u8>>,y: vector<vector<u8>>): bool {
        Neq<vector<vector<u8>>>(x, y)
    }
    public fun neq9(x: Test1,y: Test1): bool {
        Neq<Test1>(x, y)
    }
} // end 0xcffa::m


// -- Model dump after env processor simplifier:
module 0xcffa::m {
    struct Test1 {
        a: u8,
    }
    struct Test2 {
        a: vector<u8>,
    }
    public fun eq1(x: u64,y: u64): u64 {
        if Eq<u64>(x, y) {
          x
        } else {
          y
        }
    }
    public fun eq10(x: Test2,y: Test2): bool {
        Eq<Test2>(x, y)
    }
    public fun eq2(x: u64,y: u64): bool {
        Eq<u64>(Borrow(Immutable)(x), Borrow(Immutable)(y))
    }
    public fun eq3<T>(x: T,y: T): bool {
        Eq<T>(x, y)
    }
    public fun eq4<T>(x: T,y: T): bool {
        Eq<T>(Borrow(Immutable)(x), Borrow(Immutable)(y))
    }
    public fun eq5(x: bool,y: bool): bool {
        Eq<bool>(x, y)
    }
    public fun eq6(x: address,y: address): bool {
        Eq<address>(x, y)
    }
    public fun eq7(x: vector<u8>,y: vector<u8>): bool {
        Eq<vector<u8>>(x, y)
    }
    public fun eq8(x: vector<vector<u8>>,y: vector<vector<u8>>): bool {
        Eq<vector<vector<u8>>>(x, y)
    }
    public fun eq9(x: Test1,y: Test1): bool {
        Eq<Test1>(x, y)
    }
    public fun neq1(x: u64,y: u64): bool {
        Neq<u64>(x, y)
    }
    public fun neq10(x: Test2,y: Test2): bool {
        Neq<Test2>(x, y)
    }
    public fun neq2(x: u64,y: u64): bool {
        Neq<u64>(Borrow(Immutable)(x), Borrow(Immutable)(y))
    }
    public fun neq3<T>(x: T,y: T): bool {
        Neq<T>(x, y)
    }
    public fun neq4<T>(x: T,y: T): bool {
        Neq<T>(Borrow(Immutable)(x), Borrow(Immutable)(y))
    }
    public fun neq5(x: bool,y: bool): bool {
        Neq<bool>(x, y)
    }
    public fun neq6(x: address,y: address): bool {
        Neq<address>(x, y)
    }
    public fun neq7(x: vector<u8>,y: vector<u8>): bool {
        Neq<vector<u8>>(x, y)
    }
    public fun neq8(x: vector<vector<u8>>,y: vector<vector<u8>>): bool {
        Neq<vector<vector<u8>>>(x, y)
    }
    public fun neq9(x: Test1,y: Test1): bool {
        Neq<Test1>(x, y)
    }
} // end 0xcffa::m


============ bytecode before second stackless bytecode pipeline ================

[variant baseline]
public fun m::eq1($t0: u64, $t1: u64): u64 {
     var $t2: u64
     var $t3: bool
     var $t4: u64
  0: $t4 := infer($t0)
  1: $t3 := ==($t4, $t1)
  2: if ($t3) goto 3 else goto 6
  3: label L0
  4: $t2 := infer($t0)
  5: goto 8
  6: label L1
  7: $t2 := infer($t1)
  8: label L2
  9: return $t2
}


[variant baseline]
public fun m::eq10($t0: 0xcffa::m::Test2, $t1: 0xcffa::m::Test2): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test2
  0: $t3 := infer($t0)
  1: $t2 := ==($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::eq2($t0: u64, $t1: u64): bool {
     var $t2: bool
     var $t3: &u64
     var $t4: &u64
  0: $t3 := borrow_local($t0)
  1: $t4 := borrow_local($t1)
  2: $t2 := ==($t3, $t4)
  3: return $t2
}


[variant baseline]
public fun m::eq3<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: #0
  0: $t3 := infer($t0)
  1: $t2 := ==($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::eq4<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: &#0
     var $t4: &#0
  0: $t3 := borrow_local($t0)
  1: $t4 := borrow_local($t1)
  2: $t2 := ==($t3, $t4)
  3: return $t2
}


[variant baseline]
public fun m::eq5($t0: bool, $t1: bool): bool {
     var $t2: bool
     var $t3: bool
  0: $t3 := infer($t0)
  1: $t2 := ==($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::eq6($t0: address, $t1: address): bool {
     var $t2: bool
     var $t3: address
  0: $t3 := infer($t0)
  1: $t2 := ==($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::eq7($t0: vector<u8>, $t1: vector<u8>): bool {
     var $t2: bool
     var $t3: vector<u8>
  0: $t3 := infer($t0)
  1: $t2 := ==($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::eq8($t0: vector<vector<u8>>, $t1: vector<vector<u8>>): bool {
     var $t2: bool
     var $t3: vector<vector<u8>>
  0: $t3 := infer($t0)
  1: $t2 := ==($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::eq9($t0: 0xcffa::m::Test1, $t1: 0xcffa::m::Test1): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test1
  0: $t3 := infer($t0)
  1: $t2 := ==($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq1($t0: u64, $t1: u64): bool {
     var $t2: bool
     var $t3: u64
  0: $t3 := infer($t0)
  1: $t2 := !=($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq10($t0: 0xcffa::m::Test2, $t1: 0xcffa::m::Test2): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test2
  0: $t3 := infer($t0)
  1: $t2 := !=($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq2($t0: u64, $t1: u64): bool {
     var $t2: bool
     var $t3: &u64
     var $t4: &u64
  0: $t3 := borrow_local($t0)
  1: $t4 := borrow_local($t1)
  2: $t2 := !=($t3, $t4)
  3: return $t2
}


[variant baseline]
public fun m::neq3<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: #0
  0: $t3 := infer($t0)
  1: $t2 := !=($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq4<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: &#0
     var $t4: &#0
  0: $t3 := borrow_local($t0)
  1: $t4 := borrow_local($t1)
  2: $t2 := !=($t3, $t4)
  3: return $t2
}


[variant baseline]
public fun m::neq5($t0: bool, $t1: bool): bool {
     var $t2: bool
     var $t3: bool
  0: $t3 := infer($t0)
  1: $t2 := !=($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq6($t0: address, $t1: address): bool {
     var $t2: bool
     var $t3: address
  0: $t3 := infer($t0)
  1: $t2 := !=($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq7($t0: vector<u8>, $t1: vector<u8>): bool {
     var $t2: bool
     var $t3: vector<u8>
  0: $t3 := infer($t0)
  1: $t2 := !=($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq8($t0: vector<vector<u8>>, $t1: vector<vector<u8>>): bool {
     var $t2: bool
     var $t3: vector<vector<u8>>
  0: $t3 := infer($t0)
  1: $t2 := !=($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq9($t0: 0xcffa::m::Test1, $t1: 0xcffa::m::Test1): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test1
  0: $t3 := infer($t0)
  1: $t2 := !=($t3, $t1)
  2: return $t2
}

============ after SplitCriticalEdgesProcessor: ================

[variant baseline]
public fun m::eq1($t0: u64, $t1: u64): u64 {
     var $t2: u64
     var $t3: bool
     var $t4: u64
  0: $t4 := infer($t0)
  1: $t3 := ==($t4, $t1)
  2: if ($t3) goto 3 else goto 6
  3: label L0
  4: $t2 := infer($t0)
  5: goto 8
  6: label L1
  7: $t2 := infer($t1)
  8: label L2
  9: return $t2
}


[variant baseline]
public fun m::eq10($t0: 0xcffa::m::Test2, $t1: 0xcffa::m::Test2): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test2
  0: $t3 := infer($t0)
  1: $t2 := ==($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::eq2($t0: u64, $t1: u64): bool {
     var $t2: bool
     var $t3: &u64
     var $t4: &u64
  0: $t3 := borrow_local($t0)
  1: $t4 := borrow_local($t1)
  2: $t2 := ==($t3, $t4)
  3: return $t2
}


[variant baseline]
public fun m::eq3<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: #0
  0: $t3 := infer($t0)
  1: $t2 := ==($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::eq4<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: &#0
     var $t4: &#0
  0: $t3 := borrow_local($t0)
  1: $t4 := borrow_local($t1)
  2: $t2 := ==($t3, $t4)
  3: return $t2
}


[variant baseline]
public fun m::eq5($t0: bool, $t1: bool): bool {
     var $t2: bool
     var $t3: bool
  0: $t3 := infer($t0)
  1: $t2 := ==($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::eq6($t0: address, $t1: address): bool {
     var $t2: bool
     var $t3: address
  0: $t3 := infer($t0)
  1: $t2 := ==($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::eq7($t0: vector<u8>, $t1: vector<u8>): bool {
     var $t2: bool
     var $t3: vector<u8>
  0: $t3 := infer($t0)
  1: $t2 := ==($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::eq8($t0: vector<vector<u8>>, $t1: vector<vector<u8>>): bool {
     var $t2: bool
     var $t3: vector<vector<u8>>
  0: $t3 := infer($t0)
  1: $t2 := ==($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::eq9($t0: 0xcffa::m::Test1, $t1: 0xcffa::m::Test1): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test1
  0: $t3 := infer($t0)
  1: $t2 := ==($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq1($t0: u64, $t1: u64): bool {
     var $t2: bool
     var $t3: u64
  0: $t3 := infer($t0)
  1: $t2 := !=($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq10($t0: 0xcffa::m::Test2, $t1: 0xcffa::m::Test2): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test2
  0: $t3 := infer($t0)
  1: $t2 := !=($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq2($t0: u64, $t1: u64): bool {
     var $t2: bool
     var $t3: &u64
     var $t4: &u64
  0: $t3 := borrow_local($t0)
  1: $t4 := borrow_local($t1)
  2: $t2 := !=($t3, $t4)
  3: return $t2
}


[variant baseline]
public fun m::neq3<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: #0
  0: $t3 := infer($t0)
  1: $t2 := !=($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq4<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: &#0
     var $t4: &#0
  0: $t3 := borrow_local($t0)
  1: $t4 := borrow_local($t1)
  2: $t2 := !=($t3, $t4)
  3: return $t2
}


[variant baseline]
public fun m::neq5($t0: bool, $t1: bool): bool {
     var $t2: bool
     var $t3: bool
  0: $t3 := infer($t0)
  1: $t2 := !=($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq6($t0: address, $t1: address): bool {
     var $t2: bool
     var $t3: address
  0: $t3 := infer($t0)
  1: $t2 := !=($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq7($t0: vector<u8>, $t1: vector<u8>): bool {
     var $t2: bool
     var $t3: vector<u8>
  0: $t3 := infer($t0)
  1: $t2 := !=($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq8($t0: vector<vector<u8>>, $t1: vector<vector<u8>>): bool {
     var $t2: bool
     var $t3: vector<vector<u8>>
  0: $t3 := infer($t0)
  1: $t2 := !=($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq9($t0: 0xcffa::m::Test1, $t1: 0xcffa::m::Test1): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test1
  0: $t3 := infer($t0)
  1: $t2 := !=($t3, $t1)
  2: return $t2
}

============ after LiveVarAnalysisProcessor: ================

[variant baseline]
public fun m::eq1($t0: u64, $t1: u64): u64 {
     var $t2: u64
     var $t3: bool
     var $t4: u64
     # live vars: $t0, $t1
  0: $t4 := infer($t0)
     # live vars: $t0, $t1, $t4
  1: $t3 := ==($t4, $t1)
     # live vars: $t0, $t1, $t3
  2: if ($t3) goto 3 else goto 6
     # live vars: $t0, $t1
  3: label L0
     # live vars: $t0
  4: $t2 := infer($t0)
     # live vars: $t2
  5: goto 8
     # live vars: $t0, $t1
  6: label L1
     # live vars: $t1
  7: $t2 := infer($t1)
     # live vars: $t2
  8: label L2
     # live vars: $t2
  9: return $t2
}


[variant baseline]
public fun m::eq10($t0: 0xcffa::m::Test2, $t1: 0xcffa::m::Test2): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test2
     # live vars: $t0, $t1
  0: $t3 := infer($t0)
     # live vars: $t1, $t3
  1: $t2 := ==($t3, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::eq2($t0: u64, $t1: u64): bool {
     var $t2: bool
     var $t3: &u64
     var $t4: &u64
     # live vars: $t0, $t1
  0: $t3 := borrow_local($t0)
     # live vars: $t1, $t3
  1: $t4 := borrow_local($t1)
     # live vars: $t3, $t4
  2: $t2 := ==($t3, $t4)
     # live vars: $t2
  3: return $t2
}


[variant baseline]
public fun m::eq3<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: #0
     # live vars: $t0, $t1
  0: $t3 := infer($t0)
     # live vars: $t1, $t3
  1: $t2 := ==($t3, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::eq4<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: &#0
     var $t4: &#0
     # live vars: $t0, $t1
  0: $t3 := borrow_local($t0)
     # live vars: $t1, $t3
  1: $t4 := borrow_local($t1)
     # live vars: $t3, $t4
  2: $t2 := ==($t3, $t4)
     # live vars: $t2
  3: return $t2
}


[variant baseline]
public fun m::eq5($t0: bool, $t1: bool): bool {
     var $t2: bool
     var $t3: bool
     # live vars: $t0, $t1
  0: $t3 := infer($t0)
     # live vars: $t1, $t3
  1: $t2 := ==($t3, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::eq6($t0: address, $t1: address): bool {
     var $t2: bool
     var $t3: address
     # live vars: $t0, $t1
  0: $t3 := infer($t0)
     # live vars: $t1, $t3
  1: $t2 := ==($t3, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::eq7($t0: vector<u8>, $t1: vector<u8>): bool {
     var $t2: bool
     var $t3: vector<u8>
     # live vars: $t0, $t1
  0: $t3 := infer($t0)
     # live vars: $t1, $t3
  1: $t2 := ==($t3, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::eq8($t0: vector<vector<u8>>, $t1: vector<vector<u8>>): bool {
     var $t2: bool
     var $t3: vector<vector<u8>>
     # live vars: $t0, $t1
  0: $t3 := infer($t0)
     # live vars: $t1, $t3
  1: $t2 := ==($t3, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::eq9($t0: 0xcffa::m::Test1, $t1: 0xcffa::m::Test1): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test1
     # live vars: $t0, $t1
  0: $t3 := infer($t0)
     # live vars: $t1, $t3
  1: $t2 := ==($t3, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::neq1($t0: u64, $t1: u64): bool {
     var $t2: bool
     var $t3: u64
     # live vars: $t0, $t1
  0: $t3 := infer($t0)
     # live vars: $t1, $t3
  1: $t2 := !=($t3, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::neq10($t0: 0xcffa::m::Test2, $t1: 0xcffa::m::Test2): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test2
     # live vars: $t0, $t1
  0: $t3 := infer($t0)
     # live vars: $t1, $t3
  1: $t2 := !=($t3, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::neq2($t0: u64, $t1: u64): bool {
     var $t2: bool
     var $t3: &u64
     var $t4: &u64
     # live vars: $t0, $t1
  0: $t3 := borrow_local($t0)
     # live vars: $t1, $t3
  1: $t4 := borrow_local($t1)
     # live vars: $t3, $t4
  2: $t2 := !=($t3, $t4)
     # live vars: $t2
  3: return $t2
}


[variant baseline]
public fun m::neq3<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: #0
     # live vars: $t0, $t1
  0: $t3 := infer($t0)
     # live vars: $t1, $t3
  1: $t2 := !=($t3, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::neq4<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: &#0
     var $t4: &#0
     # live vars: $t0, $t1
  0: $t3 := borrow_local($t0)
     # live vars: $t1, $t3
  1: $t4 := borrow_local($t1)
     # live vars: $t3, $t4
  2: $t2 := !=($t3, $t4)
     # live vars: $t2
  3: return $t2
}


[variant baseline]
public fun m::neq5($t0: bool, $t1: bool): bool {
     var $t2: bool
     var $t3: bool
     # live vars: $t0, $t1
  0: $t3 := infer($t0)
     # live vars: $t1, $t3
  1: $t2 := !=($t3, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::neq6($t0: address, $t1: address): bool {
     var $t2: bool
     var $t3: address
     # live vars: $t0, $t1
  0: $t3 := infer($t0)
     # live vars: $t1, $t3
  1: $t2 := !=($t3, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::neq7($t0: vector<u8>, $t1: vector<u8>): bool {
     var $t2: bool
     var $t3: vector<u8>
     # live vars: $t0, $t1
  0: $t3 := infer($t0)
     # live vars: $t1, $t3
  1: $t2 := !=($t3, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::neq8($t0: vector<vector<u8>>, $t1: vector<vector<u8>>): bool {
     var $t2: bool
     var $t3: vector<vector<u8>>
     # live vars: $t0, $t1
  0: $t3 := infer($t0)
     # live vars: $t1, $t3
  1: $t2 := !=($t3, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::neq9($t0: 0xcffa::m::Test1, $t1: 0xcffa::m::Test1): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test1
     # live vars: $t0, $t1
  0: $t3 := infer($t0)
     # live vars: $t1, $t3
  1: $t2 := !=($t3, $t1)
     # live vars: $t2
  2: return $t2
}

============ after ReferenceSafetyProcessor: ================

[variant baseline]
public fun m::eq1($t0: u64, $t1: u64): u64 {
     var $t2: u64
     var $t3: bool
     var $t4: u64
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t4 := infer($t0)
     # live vars: $t0, $t1, $t4
     # refs: []
     #
  1: $t3 := ==($t4, $t1)
     # live vars: $t0, $t1, $t3
     # refs: []
     #
  2: if ($t3) goto 3 else goto 6
     # live vars: $t0, $t1
     # refs: []
     #
  3: label L0
     # live vars: $t0
     # refs: []
     #
  4: $t2 := infer($t0)
     # live vars: $t2
     # refs: []
     #
  5: goto 8
     # live vars: $t0, $t1
     # refs: []
     #
  6: label L1
     # live vars: $t1
     # refs: []
     #
  7: $t2 := infer($t1)
     # live vars: $t2
     # refs: []
     #
  8: label L2
     # live vars: $t2
     # refs: []
     #
  9: return $t2
}


[variant baseline]
public fun m::eq10($t0: 0xcffa::m::Test2, $t1: 0xcffa::m::Test2): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test2
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t3 := infer($t0)
     # live vars: $t1, $t3
     # refs: []
     #
  1: $t2 := ==($t3, $t1)
     # live vars: $t2
     # refs: []
     #
  2: return $t2
}


[variant baseline]
public fun m::eq2($t0: u64, $t1: u64): bool {
     var $t2: bool
     var $t3: &u64
     var $t4: &u64
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t3 := borrow_local($t0)
     # live vars: $t1, $t3
     # refs: [$t3 => #3]
     # #3
     #   <no edges>
     # #root
     #   => #3 via [local `x`] at line 19
     #
  1: $t4 := borrow_local($t1)
     # live vars: $t3, $t4
     # refs: [$t3 => #3, $t4 => #4]
     # #3
     #   <no edges>
     # #4
     #   <no edges>
     # #root
     #   => #3 via [local `x`] at line 19
     #   => #4 via [local `y`] at line 19
     #
  2: $t2 := ==($t3, $t4)
     # live vars: $t2
     # refs: []
     #
  3: return $t2
}


[variant baseline]
public fun m::eq3<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: #0
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t3 := infer($t0)
     # live vars: $t1, $t3
     # refs: []
     #
  1: $t2 := ==($t3, $t1)
     # live vars: $t2
     # refs: []
     #
  2: return $t2
}


[variant baseline]
public fun m::eq4<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: &#0
     var $t4: &#0
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t3 := borrow_local($t0)
     # live vars: $t1, $t3
     # refs: [$t3 => #3]
     # #3
     #   <no edges>
     # #root
     #   => #3 via [local `x`] at line 27
     #
  1: $t4 := borrow_local($t1)
     # live vars: $t3, $t4
     # refs: [$t3 => #3, $t4 => #4]
     # #3
     #   <no edges>
     # #4
     #   <no edges>
     # #root
     #   => #3 via [local `x`] at line 27
     #   => #4 via [local `y`] at line 27
     #
  2: $t2 := ==($t3, $t4)
     # live vars: $t2
     # refs: []
     #
  3: return $t2
}


[variant baseline]
public fun m::eq5($t0: bool, $t1: bool): bool {
     var $t2: bool
     var $t3: bool
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t3 := infer($t0)
     # live vars: $t1, $t3
     # refs: []
     #
  1: $t2 := ==($t3, $t1)
     # live vars: $t2
     # refs: []
     #
  2: return $t2
}


[variant baseline]
public fun m::eq6($t0: address, $t1: address): bool {
     var $t2: bool
     var $t3: address
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t3 := infer($t0)
     # live vars: $t1, $t3
     # refs: []
     #
  1: $t2 := ==($t3, $t1)
     # live vars: $t2
     # refs: []
     #
  2: return $t2
}


[variant baseline]
public fun m::eq7($t0: vector<u8>, $t1: vector<u8>): bool {
     var $t2: bool
     var $t3: vector<u8>
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t3 := infer($t0)
     # live vars: $t1, $t3
     # refs: []
     #
  1: $t2 := ==($t3, $t1)
     # live vars: $t2
     # refs: []
     #
  2: return $t2
}


[variant baseline]
public fun m::eq8($t0: vector<vector<u8>>, $t1: vector<vector<u8>>): bool {
     var $t2: bool
     var $t3: vector<vector<u8>>
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t3 := infer($t0)
     # live vars: $t1, $t3
     # refs: []
     #
  1: $t2 := ==($t3, $t1)
     # live vars: $t2
     # refs: []
     #
  2: return $t2
}


[variant baseline]
public fun m::eq9($t0: 0xcffa::m::Test1, $t1: 0xcffa::m::Test1): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test1
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t3 := infer($t0)
     # live vars: $t1, $t3
     # refs: []
     #
  1: $t2 := ==($t3, $t1)
     # live vars: $t2
     # refs: []
     #
  2: return $t2
}


[variant baseline]
public fun m::neq1($t0: u64, $t1: u64): bool {
     var $t2: bool
     var $t3: u64
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t3 := infer($t0)
     # live vars: $t1, $t3
     # refs: []
     #
  1: $t2 := !=($t3, $t1)
     # live vars: $t2
     # refs: []
     #
  2: return $t2
}


[variant baseline]
public fun m::neq10($t0: 0xcffa::m::Test2, $t1: 0xcffa::m::Test2): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test2
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t3 := infer($t0)
     # live vars: $t1, $t3
     # refs: []
     #
  1: $t2 := !=($t3, $t1)
     # live vars: $t2
     # refs: []
     #
  2: return $t2
}


[variant baseline]
public fun m::neq2($t0: u64, $t1: u64): bool {
     var $t2: bool
     var $t3: &u64
     var $t4: &u64
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t3 := borrow_local($t0)
     # live vars: $t1, $t3
     # refs: [$t3 => #3]
     # #3
     #   <no edges>
     # #root
     #   => #3 via [local `x`] at line 59
     #
  1: $t4 := borrow_local($t1)
     # live vars: $t3, $t4
     # refs: [$t3 => #3, $t4 => #4]
     # #3
     #   <no edges>
     # #4
     #   <no edges>
     # #root
     #   => #3 via [local `x`] at line 59
     #   => #4 via [local `y`] at line 59
     #
  2: $t2 := !=($t3, $t4)
     # live vars: $t2
     # refs: []
     #
  3: return $t2
}


[variant baseline]
public fun m::neq3<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: #0
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t3 := infer($t0)
     # live vars: $t1, $t3
     # refs: []
     #
  1: $t2 := !=($t3, $t1)
     # live vars: $t2
     # refs: []
     #
  2: return $t2
}


[variant baseline]
public fun m::neq4<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: &#0
     var $t4: &#0
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t3 := borrow_local($t0)
     # live vars: $t1, $t3
     # refs: [$t3 => #3]
     # #3
     #   <no edges>
     # #root
     #   => #3 via [local `x`] at line 67
     #
  1: $t4 := borrow_local($t1)
     # live vars: $t3, $t4
     # refs: [$t3 => #3, $t4 => #4]
     # #3
     #   <no edges>
     # #4
     #   <no edges>
     # #root
     #   => #3 via [local `x`] at line 67
     #   => #4 via [local `y`] at line 67
     #
  2: $t2 := !=($t3, $t4)
     # live vars: $t2
     # refs: []
     #
  3: return $t2
}


[variant baseline]
public fun m::neq5($t0: bool, $t1: bool): bool {
     var $t2: bool
     var $t3: bool
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t3 := infer($t0)
     # live vars: $t1, $t3
     # refs: []
     #
  1: $t2 := !=($t3, $t1)
     # live vars: $t2
     # refs: []
     #
  2: return $t2
}


[variant baseline]
public fun m::neq6($t0: address, $t1: address): bool {
     var $t2: bool
     var $t3: address
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t3 := infer($t0)
     # live vars: $t1, $t3
     # refs: []
     #
  1: $t2 := !=($t3, $t1)
     # live vars: $t2
     # refs: []
     #
  2: return $t2
}


[variant baseline]
public fun m::neq7($t0: vector<u8>, $t1: vector<u8>): bool {
     var $t2: bool
     var $t3: vector<u8>
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t3 := infer($t0)
     # live vars: $t1, $t3
     # refs: []
     #
  1: $t2 := !=($t3, $t1)
     # live vars: $t2
     # refs: []
     #
  2: return $t2
}


[variant baseline]
public fun m::neq8($t0: vector<vector<u8>>, $t1: vector<vector<u8>>): bool {
     var $t2: bool
     var $t3: vector<vector<u8>>
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t3 := infer($t0)
     # live vars: $t1, $t3
     # refs: []
     #
  1: $t2 := !=($t3, $t1)
     # live vars: $t2
     # refs: []
     #
  2: return $t2
}


[variant baseline]
public fun m::neq9($t0: 0xcffa::m::Test1, $t1: 0xcffa::m::Test1): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test1
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t3 := infer($t0)
     # live vars: $t1, $t3
     # refs: []
     #
  1: $t2 := !=($t3, $t1)
     # live vars: $t2
     # refs: []
     #
  2: return $t2
}

============ after AbortAnalysisProcessor: ================

[variant baseline]
public fun m::eq1($t0: u64, $t1: u64): u64 {
     var $t2: u64
     var $t3: bool
     var $t4: u64
     # abort state: {returns}
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t4 := infer($t0)
     # abort state: {returns}
     # live vars: $t0, $t1, $t4
     # refs: []
     #
  1: $t3 := ==($t4, $t1)
     # abort state: {returns}
     # live vars: $t0, $t1, $t3
     # refs: []
     #
  2: if ($t3) goto 3 else goto 6
     # abort state: {returns}
     # live vars: $t0, $t1
     # refs: []
     #
  3: label L0
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
  4: $t2 := infer($t0)
     # abort state: {returns}
     # live vars: $t2
     # refs: []
     #
  5: goto 8
     # abort state: {returns}
     # live vars: $t0, $t1
     # refs: []
     #
  6: label L1
     # abort state: {returns}
     # live vars: $t1
     # refs: []
     #
  7: $t2 := infer($t1)
     # abort state: {returns}
     # live vars: $t2
     # refs: []
     #
  8: label L2
     # abort state: {returns}
     # live vars: $t2
     # refs: []
     #
  9: return $t2
}


[variant baseline]
public fun m::eq10($t0: 0xcffa::m::Test2, $t1: 0xcffa::m::Test2): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test2
     # abort state: {returns}
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t3 := infer($t0)
     # abort state: {returns}
     # live vars: $t1, $t3
     # refs: []
     #
  1: $t2 := ==($t3, $t1)
     # abort state: {returns}
     # live vars: $t2
     # refs: []
     #
  2: return $t2
}


[variant baseline]
public fun m::eq2($t0: u64, $t1: u64): bool {
     var $t2: bool
     var $t3: &u64
     var $t4: &u64
     # abort state: {returns}
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t3 := borrow_local($t0)
     # abort state: {returns}
     # live vars: $t1, $t3
     # refs: [$t3 => #3]
     # #3
     #   <no edges>
     # #root
     #   => #3 via [local `x`] at line 19
     #
  1: $t4 := borrow_local($t1)
     # abort state: {returns}
     # live vars: $t3, $t4
     # refs: [$t3 => #3, $t4 => #4]
     # #3
     #   <no edges>
     # #4
     #   <no edges>
     # #root
     #   => #3 via [local `x`] at line 19
     #   => #4 via [local `y`] at line 19
     #
  2: $t2 := ==($t3, $t4)
     # abort state: {returns}
     # live vars: $t2
     # refs: []
     #
  3: return $t2
}


[variant baseline]
public fun m::eq3<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: #0
     # abort state: {returns}
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t3 := infer($t0)
     # abort state: {returns}
     # live vars: $t1, $t3
     # refs: []
     #
  1: $t2 := ==($t3, $t1)
     # abort state: {returns}
     # live vars: $t2
     # refs: []
     #
  2: return $t2
}


[variant baseline]
public fun m::eq4<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: &#0
     var $t4: &#0
     # abort state: {returns}
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t3 := borrow_local($t0)
     # abort state: {returns}
     # live vars: $t1, $t3
     # refs: [$t3 => #3]
     # #3
     #   <no edges>
     # #root
     #   => #3 via [local `x`] at line 27
     #
  1: $t4 := borrow_local($t1)
     # abort state: {returns}
     # live vars: $t3, $t4
     # refs: [$t3 => #3, $t4 => #4]
     # #3
     #   <no edges>
     # #4
     #   <no edges>
     # #root
     #   => #3 via [local `x`] at line 27
     #   => #4 via [local `y`] at line 27
     #
  2: $t2 := ==($t3, $t4)
     # abort state: {returns}
     # live vars: $t2
     # refs: []
     #
  3: return $t2
}


[variant baseline]
public fun m::eq5($t0: bool, $t1: bool): bool {
     var $t2: bool
     var $t3: bool
     # abort state: {returns}
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t3 := infer($t0)
     # abort state: {returns}
     # live vars: $t1, $t3
     # refs: []
     #
  1: $t2 := ==($t3, $t1)
     # abort state: {returns}
     # live vars: $t2
     # refs: []
     #
  2: return $t2
}


[variant baseline]
public fun m::eq6($t0: address, $t1: address): bool {
     var $t2: bool
     var $t3: address
     # abort state: {returns}
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t3 := infer($t0)
     # abort state: {returns}
     # live vars: $t1, $t3
     # refs: []
     #
  1: $t2 := ==($t3, $t1)
     # abort state: {returns}
     # live vars: $t2
     # refs: []
     #
  2: return $t2
}


[variant baseline]
public fun m::eq7($t0: vector<u8>, $t1: vector<u8>): bool {
     var $t2: bool
     var $t3: vector<u8>
     # abort state: {returns}
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t3 := infer($t0)
     # abort state: {returns}
     # live vars: $t1, $t3
     # refs: []
     #
  1: $t2 := ==($t3, $t1)
     # abort state: {returns}
     # live vars: $t2
     # refs: []
     #
  2: return $t2
}


[variant baseline]
public fun m::eq8($t0: vector<vector<u8>>, $t1: vector<vector<u8>>): bool {
     var $t2: bool
     var $t3: vector<vector<u8>>
     # abort state: {returns}
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t3 := infer($t0)
     # abort state: {returns}
     # live vars: $t1, $t3
     # refs: []
     #
  1: $t2 := ==($t3, $t1)
     # abort state: {returns}
     # live vars: $t2
     # refs: []
     #
  2: return $t2
}


[variant baseline]
public fun m::eq9($t0: 0xcffa::m::Test1, $t1: 0xcffa::m::Test1): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test1
     # abort state: {returns}
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t3 := infer($t0)
     # abort state: {returns}
     # live vars: $t1, $t3
     # refs: []
     #
  1: $t2 := ==($t3, $t1)
     # abort state: {returns}
     # live vars: $t2
     # refs: []
     #
  2: return $t2
}


[variant baseline]
public fun m::neq1($t0: u64, $t1: u64): bool {
     var $t2: bool
     var $t3: u64
     # abort state: {returns}
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t3 := infer($t0)
     # abort state: {returns}
     # live vars: $t1, $t3
     # refs: []
     #
  1: $t2 := !=($t3, $t1)
     # abort state: {returns}
     # live vars: $t2
     # refs: []
     #
  2: return $t2
}


[variant baseline]
public fun m::neq10($t0: 0xcffa::m::Test2, $t1: 0xcffa::m::Test2): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test2
     # abort state: {returns}
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t3 := infer($t0)
     # abort state: {returns}
     # live vars: $t1, $t3
     # refs: []
     #
  1: $t2 := !=($t3, $t1)
     # abort state: {returns}
     # live vars: $t2
     # refs: []
     #
  2: return $t2
}


[variant baseline]
public fun m::neq2($t0: u64, $t1: u64): bool {
     var $t2: bool
     var $t3: &u64
     var $t4: &u64
     # abort state: {returns}
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t3 := borrow_local($t0)
     # abort state: {returns}
     # live vars: $t1, $t3
     # refs: [$t3 => #3]
     # #3
     #   <no edges>
     # #root
     #   => #3 via [local `x`] at line 59
     #
  1: $t4 := borrow_local($t1)
     # abort state: {returns}
     # live vars: $t3, $t4
     # refs: [$t3 => #3, $t4 => #4]
     # #3
     #   <no edges>
     # #4
     #   <no edges>
     # #root
     #   => #3 via [local `x`] at line 59
     #   => #4 via [local `y`] at line 59
     #
  2: $t2 := !=($t3, $t4)
     # abort state: {returns}
     # live vars: $t2
     # refs: []
     #
  3: return $t2
}


[variant baseline]
public fun m::neq3<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: #0
     # abort state: {returns}
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t3 := infer($t0)
     # abort state: {returns}
     # live vars: $t1, $t3
     # refs: []
     #
  1: $t2 := !=($t3, $t1)
     # abort state: {returns}
     # live vars: $t2
     # refs: []
     #
  2: return $t2
}


[variant baseline]
public fun m::neq4<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: &#0
     var $t4: &#0
     # abort state: {returns}
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t3 := borrow_local($t0)
     # abort state: {returns}
     # live vars: $t1, $t3
     # refs: [$t3 => #3]
     # #3
     #   <no edges>
     # #root
     #   => #3 via [local `x`] at line 67
     #
  1: $t4 := borrow_local($t1)
     # abort state: {returns}
     # live vars: $t3, $t4
     # refs: [$t3 => #3, $t4 => #4]
     # #3
     #   <no edges>
     # #4
     #   <no edges>
     # #root
     #   => #3 via [local `x`] at line 67
     #   => #4 via [local `y`] at line 67
     #
  2: $t2 := !=($t3, $t4)
     # abort state: {returns}
     # live vars: $t2
     # refs: []
     #
  3: return $t2
}


[variant baseline]
public fun m::neq5($t0: bool, $t1: bool): bool {
     var $t2: bool
     var $t3: bool
     # abort state: {returns}
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t3 := infer($t0)
     # abort state: {returns}
     # live vars: $t1, $t3
     # refs: []
     #
  1: $t2 := !=($t3, $t1)
     # abort state: {returns}
     # live vars: $t2
     # refs: []
     #
  2: return $t2
}


[variant baseline]
public fun m::neq6($t0: address, $t1: address): bool {
     var $t2: bool
     var $t3: address
     # abort state: {returns}
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t3 := infer($t0)
     # abort state: {returns}
     # live vars: $t1, $t3
     # refs: []
     #
  1: $t2 := !=($t3, $t1)
     # abort state: {returns}
     # live vars: $t2
     # refs: []
     #
  2: return $t2
}


[variant baseline]
public fun m::neq7($t0: vector<u8>, $t1: vector<u8>): bool {
     var $t2: bool
     var $t3: vector<u8>
     # abort state: {returns}
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t3 := infer($t0)
     # abort state: {returns}
     # live vars: $t1, $t3
     # refs: []
     #
  1: $t2 := !=($t3, $t1)
     # abort state: {returns}
     # live vars: $t2
     # refs: []
     #
  2: return $t2
}


[variant baseline]
public fun m::neq8($t0: vector<vector<u8>>, $t1: vector<vector<u8>>): bool {
     var $t2: bool
     var $t3: vector<vector<u8>>
     # abort state: {returns}
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t3 := infer($t0)
     # abort state: {returns}
     # live vars: $t1, $t3
     # refs: []
     #
  1: $t2 := !=($t3, $t1)
     # abort state: {returns}
     # live vars: $t2
     # refs: []
     #
  2: return $t2
}


[variant baseline]
public fun m::neq9($t0: 0xcffa::m::Test1, $t1: 0xcffa::m::Test1): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test1
     # abort state: {returns}
     # live vars: $t0, $t1
     # refs: []
     #
  0: $t3 := infer($t0)
     # abort state: {returns}
     # live vars: $t1, $t3
     # refs: []
     #
  1: $t2 := !=($t3, $t1)
     # abort state: {returns}
     # live vars: $t2
     # refs: []
     #
  2: return $t2
}

============ after AbilityProcessor: ================

[variant baseline]
public fun m::eq1($t0: u64, $t1: u64): u64 {
     var $t2: u64
     var $t3: bool
     var $t4: u64
  0: $t4 := copy($t0)
  1: $t3 := ==($t4, $t1)
  2: if ($t3) goto 3 else goto 6
  3: label L0
  4: $t2 := move($t0)
  5: goto 8
  6: label L1
  7: $t2 := move($t1)
  8: label L2
  9: return $t2
}


[variant baseline]
public fun m::eq10($t0: 0xcffa::m::Test2, $t1: 0xcffa::m::Test2): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test2
  0: $t3 := move($t0)
  1: $t2 := ==($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::eq2($t0: u64, $t1: u64): bool {
     var $t2: bool
     var $t3: &u64
     var $t4: &u64
  0: $t3 := borrow_local($t0)
  1: $t4 := borrow_local($t1)
  2: $t2 := ==($t3, $t4)
  3: return $t2
}


[variant baseline]
public fun m::eq3<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: #0
  0: $t3 := move($t0)
  1: $t2 := ==($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::eq4<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: &#0
     var $t4: &#0
  0: $t3 := borrow_local($t0)
  1: $t4 := borrow_local($t1)
  2: $t2 := ==($t3, $t4)
  3: return $t2
}


[variant baseline]
public fun m::eq5($t0: bool, $t1: bool): bool {
     var $t2: bool
     var $t3: bool
  0: $t3 := move($t0)
  1: $t2 := ==($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::eq6($t0: address, $t1: address): bool {
     var $t2: bool
     var $t3: address
  0: $t3 := move($t0)
  1: $t2 := ==($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::eq7($t0: vector<u8>, $t1: vector<u8>): bool {
     var $t2: bool
     var $t3: vector<u8>
  0: $t3 := move($t0)
  1: $t2 := ==($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::eq8($t0: vector<vector<u8>>, $t1: vector<vector<u8>>): bool {
     var $t2: bool
     var $t3: vector<vector<u8>>
  0: $t3 := move($t0)
  1: $t2 := ==($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::eq9($t0: 0xcffa::m::Test1, $t1: 0xcffa::m::Test1): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test1
  0: $t3 := move($t0)
  1: $t2 := ==($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq1($t0: u64, $t1: u64): bool {
     var $t2: bool
     var $t3: u64
  0: $t3 := move($t0)
  1: $t2 := !=($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq10($t0: 0xcffa::m::Test2, $t1: 0xcffa::m::Test2): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test2
  0: $t3 := move($t0)
  1: $t2 := !=($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq2($t0: u64, $t1: u64): bool {
     var $t2: bool
     var $t3: &u64
     var $t4: &u64
  0: $t3 := borrow_local($t0)
  1: $t4 := borrow_local($t1)
  2: $t2 := !=($t3, $t4)
  3: return $t2
}


[variant baseline]
public fun m::neq3<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: #0
  0: $t3 := move($t0)
  1: $t2 := !=($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq4<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: &#0
     var $t4: &#0
  0: $t3 := borrow_local($t0)
  1: $t4 := borrow_local($t1)
  2: $t2 := !=($t3, $t4)
  3: return $t2
}


[variant baseline]
public fun m::neq5($t0: bool, $t1: bool): bool {
     var $t2: bool
     var $t3: bool
  0: $t3 := move($t0)
  1: $t2 := !=($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq6($t0: address, $t1: address): bool {
     var $t2: bool
     var $t3: address
  0: $t3 := move($t0)
  1: $t2 := !=($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq7($t0: vector<u8>, $t1: vector<u8>): bool {
     var $t2: bool
     var $t3: vector<u8>
  0: $t3 := move($t0)
  1: $t2 := !=($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq8($t0: vector<vector<u8>>, $t1: vector<vector<u8>>): bool {
     var $t2: bool
     var $t3: vector<vector<u8>>
  0: $t3 := move($t0)
  1: $t2 := !=($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq9($t0: 0xcffa::m::Test1, $t1: 0xcffa::m::Test1): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test1
  0: $t3 := move($t0)
  1: $t2 := !=($t3, $t1)
  2: return $t2
}

============ after ControlFlowGraphSimplifier: ================

[variant baseline]
public fun m::eq1($t0: u64, $t1: u64): u64 {
     var $t2: u64
     var $t3: bool
     var $t4: u64
  0: $t4 := copy($t0)
  1: $t3 := ==($t4, $t1)
  2: if ($t3) goto 3 else goto 7
  3: label L0
  4: $t2 := move($t0)
  5: label L2
  6: return $t2
  7: label L1
  8: $t2 := move($t1)
  9: goto 5
}


[variant baseline]
public fun m::eq10($t0: 0xcffa::m::Test2, $t1: 0xcffa::m::Test2): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test2
  0: $t3 := move($t0)
  1: $t2 := ==($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::eq2($t0: u64, $t1: u64): bool {
     var $t2: bool
     var $t3: &u64
     var $t4: &u64
  0: $t3 := borrow_local($t0)
  1: $t4 := borrow_local($t1)
  2: $t2 := ==($t3, $t4)
  3: return $t2
}


[variant baseline]
public fun m::eq3<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: #0
  0: $t3 := move($t0)
  1: $t2 := ==($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::eq4<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: &#0
     var $t4: &#0
  0: $t3 := borrow_local($t0)
  1: $t4 := borrow_local($t1)
  2: $t2 := ==($t3, $t4)
  3: return $t2
}


[variant baseline]
public fun m::eq5($t0: bool, $t1: bool): bool {
     var $t2: bool
     var $t3: bool
  0: $t3 := move($t0)
  1: $t2 := ==($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::eq6($t0: address, $t1: address): bool {
     var $t2: bool
     var $t3: address
  0: $t3 := move($t0)
  1: $t2 := ==($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::eq7($t0: vector<u8>, $t1: vector<u8>): bool {
     var $t2: bool
     var $t3: vector<u8>
  0: $t3 := move($t0)
  1: $t2 := ==($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::eq8($t0: vector<vector<u8>>, $t1: vector<vector<u8>>): bool {
     var $t2: bool
     var $t3: vector<vector<u8>>
  0: $t3 := move($t0)
  1: $t2 := ==($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::eq9($t0: 0xcffa::m::Test1, $t1: 0xcffa::m::Test1): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test1
  0: $t3 := move($t0)
  1: $t2 := ==($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq1($t0: u64, $t1: u64): bool {
     var $t2: bool
     var $t3: u64
  0: $t3 := move($t0)
  1: $t2 := !=($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq10($t0: 0xcffa::m::Test2, $t1: 0xcffa::m::Test2): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test2
  0: $t3 := move($t0)
  1: $t2 := !=($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq2($t0: u64, $t1: u64): bool {
     var $t2: bool
     var $t3: &u64
     var $t4: &u64
  0: $t3 := borrow_local($t0)
  1: $t4 := borrow_local($t1)
  2: $t2 := !=($t3, $t4)
  3: return $t2
}


[variant baseline]
public fun m::neq3<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: #0
  0: $t3 := move($t0)
  1: $t2 := !=($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq4<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: &#0
     var $t4: &#0
  0: $t3 := borrow_local($t0)
  1: $t4 := borrow_local($t1)
  2: $t2 := !=($t3, $t4)
  3: return $t2
}


[variant baseline]
public fun m::neq5($t0: bool, $t1: bool): bool {
     var $t2: bool
     var $t3: bool
  0: $t3 := move($t0)
  1: $t2 := !=($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq6($t0: address, $t1: address): bool {
     var $t2: bool
     var $t3: address
  0: $t3 := move($t0)
  1: $t2 := !=($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq7($t0: vector<u8>, $t1: vector<u8>): bool {
     var $t2: bool
     var $t3: vector<u8>
  0: $t3 := move($t0)
  1: $t2 := !=($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq8($t0: vector<vector<u8>>, $t1: vector<vector<u8>>): bool {
     var $t2: bool
     var $t3: vector<vector<u8>>
  0: $t3 := move($t0)
  1: $t2 := !=($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq9($t0: 0xcffa::m::Test1, $t1: 0xcffa::m::Test1): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test1
  0: $t3 := move($t0)
  1: $t2 := !=($t3, $t1)
  2: return $t2
}

============ after SplitCriticalEdgesProcessor: ================

[variant baseline]
public fun m::eq1($t0: u64, $t1: u64): u64 {
     var $t2: u64
     var $t3: bool
     var $t4: u64
  0: $t4 := copy($t0)
  1: $t3 := ==($t4, $t1)
  2: if ($t3) goto 3 else goto 7
  3: label L0
  4: $t2 := move($t0)
  5: label L2
  6: return $t2
  7: label L1
  8: $t2 := move($t1)
  9: goto 5
}


[variant baseline]
public fun m::eq10($t0: 0xcffa::m::Test2, $t1: 0xcffa::m::Test2): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test2
  0: $t3 := move($t0)
  1: $t2 := ==($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::eq2($t0: u64, $t1: u64): bool {
     var $t2: bool
     var $t3: &u64
     var $t4: &u64
  0: $t3 := borrow_local($t0)
  1: $t4 := borrow_local($t1)
  2: $t2 := ==($t3, $t4)
  3: return $t2
}


[variant baseline]
public fun m::eq3<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: #0
  0: $t3 := move($t0)
  1: $t2 := ==($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::eq4<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: &#0
     var $t4: &#0
  0: $t3 := borrow_local($t0)
  1: $t4 := borrow_local($t1)
  2: $t2 := ==($t3, $t4)
  3: return $t2
}


[variant baseline]
public fun m::eq5($t0: bool, $t1: bool): bool {
     var $t2: bool
     var $t3: bool
  0: $t3 := move($t0)
  1: $t2 := ==($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::eq6($t0: address, $t1: address): bool {
     var $t2: bool
     var $t3: address
  0: $t3 := move($t0)
  1: $t2 := ==($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::eq7($t0: vector<u8>, $t1: vector<u8>): bool {
     var $t2: bool
     var $t3: vector<u8>
  0: $t3 := move($t0)
  1: $t2 := ==($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::eq8($t0: vector<vector<u8>>, $t1: vector<vector<u8>>): bool {
     var $t2: bool
     var $t3: vector<vector<u8>>
  0: $t3 := move($t0)
  1: $t2 := ==($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::eq9($t0: 0xcffa::m::Test1, $t1: 0xcffa::m::Test1): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test1
  0: $t3 := move($t0)
  1: $t2 := ==($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq1($t0: u64, $t1: u64): bool {
     var $t2: bool
     var $t3: u64
  0: $t3 := move($t0)
  1: $t2 := !=($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq10($t0: 0xcffa::m::Test2, $t1: 0xcffa::m::Test2): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test2
  0: $t3 := move($t0)
  1: $t2 := !=($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq2($t0: u64, $t1: u64): bool {
     var $t2: bool
     var $t3: &u64
     var $t4: &u64
  0: $t3 := borrow_local($t0)
  1: $t4 := borrow_local($t1)
  2: $t2 := !=($t3, $t4)
  3: return $t2
}


[variant baseline]
public fun m::neq3<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: #0
  0: $t3 := move($t0)
  1: $t2 := !=($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq4<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: &#0
     var $t4: &#0
  0: $t3 := borrow_local($t0)
  1: $t4 := borrow_local($t1)
  2: $t2 := !=($t3, $t4)
  3: return $t2
}


[variant baseline]
public fun m::neq5($t0: bool, $t1: bool): bool {
     var $t2: bool
     var $t3: bool
  0: $t3 := move($t0)
  1: $t2 := !=($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq6($t0: address, $t1: address): bool {
     var $t2: bool
     var $t3: address
  0: $t3 := move($t0)
  1: $t2 := !=($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq7($t0: vector<u8>, $t1: vector<u8>): bool {
     var $t2: bool
     var $t3: vector<u8>
  0: $t3 := move($t0)
  1: $t2 := !=($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq8($t0: vector<vector<u8>>, $t1: vector<vector<u8>>): bool {
     var $t2: bool
     var $t3: vector<vector<u8>>
  0: $t3 := move($t0)
  1: $t2 := !=($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq9($t0: 0xcffa::m::Test1, $t1: 0xcffa::m::Test1): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test1
  0: $t3 := move($t0)
  1: $t2 := !=($t3, $t1)
  2: return $t2
}

============ after UnreachableCodeProcessor: ================

[variant baseline]
public fun m::eq1($t0: u64, $t1: u64): u64 {
     var $t2: u64
     var $t3: bool
     var $t4: u64
     # maybe
  0: $t4 := copy($t0)
     # maybe
  1: $t3 := ==($t4, $t1)
     # maybe
  2: if ($t3) goto 3 else goto 7
     # maybe
  3: label L0
     # maybe
  4: $t2 := move($t0)
     # maybe
  5: label L2
     # maybe
  6: return $t2
     # maybe
  7: label L1
     # maybe
  8: $t2 := move($t1)
     # maybe
  9: goto 5
}


[variant baseline]
public fun m::eq10($t0: 0xcffa::m::Test2, $t1: 0xcffa::m::Test2): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test2
     # maybe
  0: $t3 := move($t0)
     # maybe
  1: $t2 := ==($t3, $t1)
     # maybe
  2: return $t2
}


[variant baseline]
public fun m::eq2($t0: u64, $t1: u64): bool {
     var $t2: bool
     var $t3: &u64
     var $t4: &u64
     # maybe
  0: $t3 := borrow_local($t0)
     # maybe
  1: $t4 := borrow_local($t1)
     # maybe
  2: $t2 := ==($t3, $t4)
     # maybe
  3: return $t2
}


[variant baseline]
public fun m::eq3<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: #0
     # maybe
  0: $t3 := move($t0)
     # maybe
  1: $t2 := ==($t3, $t1)
     # maybe
  2: return $t2
}


[variant baseline]
public fun m::eq4<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: &#0
     var $t4: &#0
     # maybe
  0: $t3 := borrow_local($t0)
     # maybe
  1: $t4 := borrow_local($t1)
     # maybe
  2: $t2 := ==($t3, $t4)
     # maybe
  3: return $t2
}


[variant baseline]
public fun m::eq5($t0: bool, $t1: bool): bool {
     var $t2: bool
     var $t3: bool
     # maybe
  0: $t3 := move($t0)
     # maybe
  1: $t2 := ==($t3, $t1)
     # maybe
  2: return $t2
}


[variant baseline]
public fun m::eq6($t0: address, $t1: address): bool {
     var $t2: bool
     var $t3: address
     # maybe
  0: $t3 := move($t0)
     # maybe
  1: $t2 := ==($t3, $t1)
     # maybe
  2: return $t2
}


[variant baseline]
public fun m::eq7($t0: vector<u8>, $t1: vector<u8>): bool {
     var $t2: bool
     var $t3: vector<u8>
     # maybe
  0: $t3 := move($t0)
     # maybe
  1: $t2 := ==($t3, $t1)
     # maybe
  2: return $t2
}


[variant baseline]
public fun m::eq8($t0: vector<vector<u8>>, $t1: vector<vector<u8>>): bool {
     var $t2: bool
     var $t3: vector<vector<u8>>
     # maybe
  0: $t3 := move($t0)
     # maybe
  1: $t2 := ==($t3, $t1)
     # maybe
  2: return $t2
}


[variant baseline]
public fun m::eq9($t0: 0xcffa::m::Test1, $t1: 0xcffa::m::Test1): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test1
     # maybe
  0: $t3 := move($t0)
     # maybe
  1: $t2 := ==($t3, $t1)
     # maybe
  2: return $t2
}


[variant baseline]
public fun m::neq1($t0: u64, $t1: u64): bool {
     var $t2: bool
     var $t3: u64
     # maybe
  0: $t3 := move($t0)
     # maybe
  1: $t2 := !=($t3, $t1)
     # maybe
  2: return $t2
}


[variant baseline]
public fun m::neq10($t0: 0xcffa::m::Test2, $t1: 0xcffa::m::Test2): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test2
     # maybe
  0: $t3 := move($t0)
     # maybe
  1: $t2 := !=($t3, $t1)
     # maybe
  2: return $t2
}


[variant baseline]
public fun m::neq2($t0: u64, $t1: u64): bool {
     var $t2: bool
     var $t3: &u64
     var $t4: &u64
     # maybe
  0: $t3 := borrow_local($t0)
     # maybe
  1: $t4 := borrow_local($t1)
     # maybe
  2: $t2 := !=($t3, $t4)
     # maybe
  3: return $t2
}


[variant baseline]
public fun m::neq3<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: #0
     # maybe
  0: $t3 := move($t0)
     # maybe
  1: $t2 := !=($t3, $t1)
     # maybe
  2: return $t2
}


[variant baseline]
public fun m::neq4<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: &#0
     var $t4: &#0
     # maybe
  0: $t3 := borrow_local($t0)
     # maybe
  1: $t4 := borrow_local($t1)
     # maybe
  2: $t2 := !=($t3, $t4)
     # maybe
  3: return $t2
}


[variant baseline]
public fun m::neq5($t0: bool, $t1: bool): bool {
     var $t2: bool
     var $t3: bool
     # maybe
  0: $t3 := move($t0)
     # maybe
  1: $t2 := !=($t3, $t1)
     # maybe
  2: return $t2
}


[variant baseline]
public fun m::neq6($t0: address, $t1: address): bool {
     var $t2: bool
     var $t3: address
     # maybe
  0: $t3 := move($t0)
     # maybe
  1: $t2 := !=($t3, $t1)
     # maybe
  2: return $t2
}


[variant baseline]
public fun m::neq7($t0: vector<u8>, $t1: vector<u8>): bool {
     var $t2: bool
     var $t3: vector<u8>
     # maybe
  0: $t3 := move($t0)
     # maybe
  1: $t2 := !=($t3, $t1)
     # maybe
  2: return $t2
}


[variant baseline]
public fun m::neq8($t0: vector<vector<u8>>, $t1: vector<vector<u8>>): bool {
     var $t2: bool
     var $t3: vector<vector<u8>>
     # maybe
  0: $t3 := move($t0)
     # maybe
  1: $t2 := !=($t3, $t1)
     # maybe
  2: return $t2
}


[variant baseline]
public fun m::neq9($t0: 0xcffa::m::Test1, $t1: 0xcffa::m::Test1): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test1
     # maybe
  0: $t3 := move($t0)
     # maybe
  1: $t2 := !=($t3, $t1)
     # maybe
  2: return $t2
}

============ after UnreachableCodeRemover: ================

[variant baseline]
public fun m::eq1($t0: u64, $t1: u64): u64 {
     var $t2: u64
     var $t3: bool
     var $t4: u64
  0: $t4 := copy($t0)
  1: $t3 := ==($t4, $t1)
  2: if ($t3) goto 3 else goto 7
  3: label L0
  4: $t2 := move($t0)
  5: label L2
  6: return $t2
  7: label L1
  8: $t2 := move($t1)
  9: goto 5
}


[variant baseline]
public fun m::eq10($t0: 0xcffa::m::Test2, $t1: 0xcffa::m::Test2): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test2
  0: $t3 := move($t0)
  1: $t2 := ==($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::eq2($t0: u64, $t1: u64): bool {
     var $t2: bool
     var $t3: &u64
     var $t4: &u64
  0: $t3 := borrow_local($t0)
  1: $t4 := borrow_local($t1)
  2: $t2 := ==($t3, $t4)
  3: return $t2
}


[variant baseline]
public fun m::eq3<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: #0
  0: $t3 := move($t0)
  1: $t2 := ==($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::eq4<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: &#0
     var $t4: &#0
  0: $t3 := borrow_local($t0)
  1: $t4 := borrow_local($t1)
  2: $t2 := ==($t3, $t4)
  3: return $t2
}


[variant baseline]
public fun m::eq5($t0: bool, $t1: bool): bool {
     var $t2: bool
     var $t3: bool
  0: $t3 := move($t0)
  1: $t2 := ==($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::eq6($t0: address, $t1: address): bool {
     var $t2: bool
     var $t3: address
  0: $t3 := move($t0)
  1: $t2 := ==($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::eq7($t0: vector<u8>, $t1: vector<u8>): bool {
     var $t2: bool
     var $t3: vector<u8>
  0: $t3 := move($t0)
  1: $t2 := ==($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::eq8($t0: vector<vector<u8>>, $t1: vector<vector<u8>>): bool {
     var $t2: bool
     var $t3: vector<vector<u8>>
  0: $t3 := move($t0)
  1: $t2 := ==($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::eq9($t0: 0xcffa::m::Test1, $t1: 0xcffa::m::Test1): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test1
  0: $t3 := move($t0)
  1: $t2 := ==($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq1($t0: u64, $t1: u64): bool {
     var $t2: bool
     var $t3: u64
  0: $t3 := move($t0)
  1: $t2 := !=($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq10($t0: 0xcffa::m::Test2, $t1: 0xcffa::m::Test2): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test2
  0: $t3 := move($t0)
  1: $t2 := !=($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq2($t0: u64, $t1: u64): bool {
     var $t2: bool
     var $t3: &u64
     var $t4: &u64
  0: $t3 := borrow_local($t0)
  1: $t4 := borrow_local($t1)
  2: $t2 := !=($t3, $t4)
  3: return $t2
}


[variant baseline]
public fun m::neq3<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: #0
  0: $t3 := move($t0)
  1: $t2 := !=($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq4<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: &#0
     var $t4: &#0
  0: $t3 := borrow_local($t0)
  1: $t4 := borrow_local($t1)
  2: $t2 := !=($t3, $t4)
  3: return $t2
}


[variant baseline]
public fun m::neq5($t0: bool, $t1: bool): bool {
     var $t2: bool
     var $t3: bool
  0: $t3 := move($t0)
  1: $t2 := !=($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq6($t0: address, $t1: address): bool {
     var $t2: bool
     var $t3: address
  0: $t3 := move($t0)
  1: $t2 := !=($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq7($t0: vector<u8>, $t1: vector<u8>): bool {
     var $t2: bool
     var $t3: vector<u8>
  0: $t3 := move($t0)
  1: $t2 := !=($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq8($t0: vector<vector<u8>>, $t1: vector<vector<u8>>): bool {
     var $t2: bool
     var $t3: vector<vector<u8>>
  0: $t3 := move($t0)
  1: $t2 := !=($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq9($t0: 0xcffa::m::Test1, $t1: 0xcffa::m::Test1): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test1
  0: $t3 := move($t0)
  1: $t2 := !=($t3, $t1)
  2: return $t2
}

============ after LiveVarAnalysisProcessor: ================

[variant baseline]
public fun m::eq1($t0: u64, $t1: u64): u64 {
     var $t2: u64
     var $t3: bool
     var $t4: u64
     # live vars: $t0, $t1
  0: $t4 := copy($t0)
     # live vars: $t0, $t1, $t4
  1: $t3 := ==($t4, $t1)
     # live vars: $t0, $t1, $t3
  2: if ($t3) goto 3 else goto 7
     # live vars: $t0, $t1
  3: label L0
     # live vars: $t0
  4: $t2 := move($t0)
     # live vars: $t2
  5: label L2
     # live vars: $t2
  6: return $t2
     # live vars: $t0, $t1
  7: label L1
     # live vars: $t1
  8: $t2 := move($t1)
     # live vars: $t2
  9: goto 5
}


[variant baseline]
public fun m::eq10($t0: 0xcffa::m::Test2, $t1: 0xcffa::m::Test2): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test2
     # live vars: $t0, $t1
  0: $t3 := move($t0)
     # live vars: $t1, $t3
  1: $t2 := ==($t3, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::eq2($t0: u64, $t1: u64): bool {
     var $t2: bool
     var $t3: &u64
     var $t4: &u64
     # live vars: $t0, $t1
  0: $t3 := borrow_local($t0)
     # live vars: $t1, $t3
  1: $t4 := borrow_local($t1)
     # live vars: $t3, $t4
  2: $t2 := ==($t3, $t4)
     # live vars: $t2
  3: return $t2
}


[variant baseline]
public fun m::eq3<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: #0
     # live vars: $t0, $t1
  0: $t3 := move($t0)
     # live vars: $t1, $t3
  1: $t2 := ==($t3, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::eq4<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: &#0
     var $t4: &#0
     # live vars: $t0, $t1
  0: $t3 := borrow_local($t0)
     # live vars: $t1, $t3
  1: $t4 := borrow_local($t1)
     # live vars: $t3, $t4
  2: $t2 := ==($t3, $t4)
     # live vars: $t2
  3: return $t2
}


[variant baseline]
public fun m::eq5($t0: bool, $t1: bool): bool {
     var $t2: bool
     var $t3: bool
     # live vars: $t0, $t1
  0: $t3 := move($t0)
     # live vars: $t1, $t3
  1: $t2 := ==($t3, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::eq6($t0: address, $t1: address): bool {
     var $t2: bool
     var $t3: address
     # live vars: $t0, $t1
  0: $t3 := move($t0)
     # live vars: $t1, $t3
  1: $t2 := ==($t3, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::eq7($t0: vector<u8>, $t1: vector<u8>): bool {
     var $t2: bool
     var $t3: vector<u8>
     # live vars: $t0, $t1
  0: $t3 := move($t0)
     # live vars: $t1, $t3
  1: $t2 := ==($t3, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::eq8($t0: vector<vector<u8>>, $t1: vector<vector<u8>>): bool {
     var $t2: bool
     var $t3: vector<vector<u8>>
     # live vars: $t0, $t1
  0: $t3 := move($t0)
     # live vars: $t1, $t3
  1: $t2 := ==($t3, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::eq9($t0: 0xcffa::m::Test1, $t1: 0xcffa::m::Test1): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test1
     # live vars: $t0, $t1
  0: $t3 := move($t0)
     # live vars: $t1, $t3
  1: $t2 := ==($t3, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::neq1($t0: u64, $t1: u64): bool {
     var $t2: bool
     var $t3: u64
     # live vars: $t0, $t1
  0: $t3 := move($t0)
     # live vars: $t1, $t3
  1: $t2 := !=($t3, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::neq10($t0: 0xcffa::m::Test2, $t1: 0xcffa::m::Test2): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test2
     # live vars: $t0, $t1
  0: $t3 := move($t0)
     # live vars: $t1, $t3
  1: $t2 := !=($t3, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::neq2($t0: u64, $t1: u64): bool {
     var $t2: bool
     var $t3: &u64
     var $t4: &u64
     # live vars: $t0, $t1
  0: $t3 := borrow_local($t0)
     # live vars: $t1, $t3
  1: $t4 := borrow_local($t1)
     # live vars: $t3, $t4
  2: $t2 := !=($t3, $t4)
     # live vars: $t2
  3: return $t2
}


[variant baseline]
public fun m::neq3<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: #0
     # live vars: $t0, $t1
  0: $t3 := move($t0)
     # live vars: $t1, $t3
  1: $t2 := !=($t3, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::neq4<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: &#0
     var $t4: &#0
     # live vars: $t0, $t1
  0: $t3 := borrow_local($t0)
     # live vars: $t1, $t3
  1: $t4 := borrow_local($t1)
     # live vars: $t3, $t4
  2: $t2 := !=($t3, $t4)
     # live vars: $t2
  3: return $t2
}


[variant baseline]
public fun m::neq5($t0: bool, $t1: bool): bool {
     var $t2: bool
     var $t3: bool
     # live vars: $t0, $t1
  0: $t3 := move($t0)
     # live vars: $t1, $t3
  1: $t2 := !=($t3, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::neq6($t0: address, $t1: address): bool {
     var $t2: bool
     var $t3: address
     # live vars: $t0, $t1
  0: $t3 := move($t0)
     # live vars: $t1, $t3
  1: $t2 := !=($t3, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::neq7($t0: vector<u8>, $t1: vector<u8>): bool {
     var $t2: bool
     var $t3: vector<u8>
     # live vars: $t0, $t1
  0: $t3 := move($t0)
     # live vars: $t1, $t3
  1: $t2 := !=($t3, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::neq8($t0: vector<vector<u8>>, $t1: vector<vector<u8>>): bool {
     var $t2: bool
     var $t3: vector<vector<u8>>
     # live vars: $t0, $t1
  0: $t3 := move($t0)
     # live vars: $t1, $t3
  1: $t2 := !=($t3, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::neq9($t0: 0xcffa::m::Test1, $t1: 0xcffa::m::Test1): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test1
     # live vars: $t0, $t1
  0: $t3 := move($t0)
     # live vars: $t1, $t3
  1: $t2 := !=($t3, $t1)
     # live vars: $t2
  2: return $t2
}

============ after DeadStoreElimination: ================

[variant baseline]
public fun m::eq1($t0: u64, $t1: u64): u64 {
     var $t2: u64
     var $t3: bool
     var $t4: u64
  0: $t4 := copy($t0)
  1: $t3 := ==($t4, $t1)
  2: if ($t3) goto 3 else goto 7
  3: label L0
  4: $t2 := move($t0)
  5: label L2
  6: return $t2
  7: label L1
  8: $t2 := move($t1)
  9: goto 5
}


[variant baseline]
public fun m::eq10($t0: 0xcffa::m::Test2, $t1: 0xcffa::m::Test2): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test2
  0: $t3 := move($t0)
  1: $t2 := ==($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::eq2($t0: u64, $t1: u64): bool {
     var $t2: bool
     var $t3: &u64
     var $t4: &u64
  0: $t3 := borrow_local($t0)
  1: $t4 := borrow_local($t1)
  2: $t2 := ==($t3, $t4)
  3: return $t2
}


[variant baseline]
public fun m::eq3<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: #0
  0: $t3 := move($t0)
  1: $t2 := ==($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::eq4<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: &#0
     var $t4: &#0
  0: $t3 := borrow_local($t0)
  1: $t4 := borrow_local($t1)
  2: $t2 := ==($t3, $t4)
  3: return $t2
}


[variant baseline]
public fun m::eq5($t0: bool, $t1: bool): bool {
     var $t2: bool
     var $t3: bool
  0: $t3 := move($t0)
  1: $t2 := ==($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::eq6($t0: address, $t1: address): bool {
     var $t2: bool
     var $t3: address
  0: $t3 := move($t0)
  1: $t2 := ==($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::eq7($t0: vector<u8>, $t1: vector<u8>): bool {
     var $t2: bool
     var $t3: vector<u8>
  0: $t3 := move($t0)
  1: $t2 := ==($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::eq8($t0: vector<vector<u8>>, $t1: vector<vector<u8>>): bool {
     var $t2: bool
     var $t3: vector<vector<u8>>
  0: $t3 := move($t0)
  1: $t2 := ==($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::eq9($t0: 0xcffa::m::Test1, $t1: 0xcffa::m::Test1): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test1
  0: $t3 := move($t0)
  1: $t2 := ==($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq1($t0: u64, $t1: u64): bool {
     var $t2: bool
     var $t3: u64
  0: $t3 := move($t0)
  1: $t2 := !=($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq10($t0: 0xcffa::m::Test2, $t1: 0xcffa::m::Test2): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test2
  0: $t3 := move($t0)
  1: $t2 := !=($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq2($t0: u64, $t1: u64): bool {
     var $t2: bool
     var $t3: &u64
     var $t4: &u64
  0: $t3 := borrow_local($t0)
  1: $t4 := borrow_local($t1)
  2: $t2 := !=($t3, $t4)
  3: return $t2
}


[variant baseline]
public fun m::neq3<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: #0
  0: $t3 := move($t0)
  1: $t2 := !=($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq4<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: &#0
     var $t4: &#0
  0: $t3 := borrow_local($t0)
  1: $t4 := borrow_local($t1)
  2: $t2 := !=($t3, $t4)
  3: return $t2
}


[variant baseline]
public fun m::neq5($t0: bool, $t1: bool): bool {
     var $t2: bool
     var $t3: bool
  0: $t3 := move($t0)
  1: $t2 := !=($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq6($t0: address, $t1: address): bool {
     var $t2: bool
     var $t3: address
  0: $t3 := move($t0)
  1: $t2 := !=($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq7($t0: vector<u8>, $t1: vector<u8>): bool {
     var $t2: bool
     var $t3: vector<u8>
  0: $t3 := move($t0)
  1: $t2 := !=($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq8($t0: vector<vector<u8>>, $t1: vector<vector<u8>>): bool {
     var $t2: bool
     var $t3: vector<vector<u8>>
  0: $t3 := move($t0)
  1: $t2 := !=($t3, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq9($t0: 0xcffa::m::Test1, $t1: 0xcffa::m::Test1): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test1
  0: $t3 := move($t0)
  1: $t2 := !=($t3, $t1)
  2: return $t2
}

============ after LiveVarAnalysisProcessor: ================

[variant baseline]
public fun m::eq1($t0: u64, $t1: u64): u64 {
     var $t2: u64
     var $t3: bool
     var $t4: u64
     # live vars: $t0, $t1
  0: $t4 := copy($t0)
     # live vars: $t0, $t1, $t4
  1: $t3 := ==($t4, $t1)
     # live vars: $t0, $t1, $t3
  2: if ($t3) goto 3 else goto 7
     # live vars: $t0, $t1
  3: label L0
     # live vars: $t0
  4: $t2 := move($t0)
     # live vars: $t2
  5: label L2
     # live vars: $t2
  6: return $t2
     # live vars: $t0, $t1
  7: label L1
     # live vars: $t1
  8: $t2 := move($t1)
     # live vars: $t2
  9: goto 5
}


[variant baseline]
public fun m::eq10($t0: 0xcffa::m::Test2, $t1: 0xcffa::m::Test2): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test2
     # live vars: $t0, $t1
  0: $t3 := move($t0)
     # live vars: $t1, $t3
  1: $t2 := ==($t3, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::eq2($t0: u64, $t1: u64): bool {
     var $t2: bool
     var $t3: &u64
     var $t4: &u64
     # live vars: $t0, $t1
  0: $t3 := borrow_local($t0)
     # live vars: $t1, $t3
  1: $t4 := borrow_local($t1)
     # live vars: $t3, $t4
  2: $t2 := ==($t3, $t4)
     # live vars: $t2
  3: return $t2
}


[variant baseline]
public fun m::eq3<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: #0
     # live vars: $t0, $t1
  0: $t3 := move($t0)
     # live vars: $t1, $t3
  1: $t2 := ==($t3, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::eq4<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: &#0
     var $t4: &#0
     # live vars: $t0, $t1
  0: $t3 := borrow_local($t0)
     # live vars: $t1, $t3
  1: $t4 := borrow_local($t1)
     # live vars: $t3, $t4
  2: $t2 := ==($t3, $t4)
     # live vars: $t2
  3: return $t2
}


[variant baseline]
public fun m::eq5($t0: bool, $t1: bool): bool {
     var $t2: bool
     var $t3: bool
     # live vars: $t0, $t1
  0: $t3 := move($t0)
     # live vars: $t1, $t3
  1: $t2 := ==($t3, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::eq6($t0: address, $t1: address): bool {
     var $t2: bool
     var $t3: address
     # live vars: $t0, $t1
  0: $t3 := move($t0)
     # live vars: $t1, $t3
  1: $t2 := ==($t3, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::eq7($t0: vector<u8>, $t1: vector<u8>): bool {
     var $t2: bool
     var $t3: vector<u8>
     # live vars: $t0, $t1
  0: $t3 := move($t0)
     # live vars: $t1, $t3
  1: $t2 := ==($t3, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::eq8($t0: vector<vector<u8>>, $t1: vector<vector<u8>>): bool {
     var $t2: bool
     var $t3: vector<vector<u8>>
     # live vars: $t0, $t1
  0: $t3 := move($t0)
     # live vars: $t1, $t3
  1: $t2 := ==($t3, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::eq9($t0: 0xcffa::m::Test1, $t1: 0xcffa::m::Test1): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test1
     # live vars: $t0, $t1
  0: $t3 := move($t0)
     # live vars: $t1, $t3
  1: $t2 := ==($t3, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::neq1($t0: u64, $t1: u64): bool {
     var $t2: bool
     var $t3: u64
     # live vars: $t0, $t1
  0: $t3 := move($t0)
     # live vars: $t1, $t3
  1: $t2 := !=($t3, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::neq10($t0: 0xcffa::m::Test2, $t1: 0xcffa::m::Test2): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test2
     # live vars: $t0, $t1
  0: $t3 := move($t0)
     # live vars: $t1, $t3
  1: $t2 := !=($t3, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::neq2($t0: u64, $t1: u64): bool {
     var $t2: bool
     var $t3: &u64
     var $t4: &u64
     # live vars: $t0, $t1
  0: $t3 := borrow_local($t0)
     # live vars: $t1, $t3
  1: $t4 := borrow_local($t1)
     # live vars: $t3, $t4
  2: $t2 := !=($t3, $t4)
     # live vars: $t2
  3: return $t2
}


[variant baseline]
public fun m::neq3<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: #0
     # live vars: $t0, $t1
  0: $t3 := move($t0)
     # live vars: $t1, $t3
  1: $t2 := !=($t3, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::neq4<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: &#0
     var $t4: &#0
     # live vars: $t0, $t1
  0: $t3 := borrow_local($t0)
     # live vars: $t1, $t3
  1: $t4 := borrow_local($t1)
     # live vars: $t3, $t4
  2: $t2 := !=($t3, $t4)
     # live vars: $t2
  3: return $t2
}


[variant baseline]
public fun m::neq5($t0: bool, $t1: bool): bool {
     var $t2: bool
     var $t3: bool
     # live vars: $t0, $t1
  0: $t3 := move($t0)
     # live vars: $t1, $t3
  1: $t2 := !=($t3, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::neq6($t0: address, $t1: address): bool {
     var $t2: bool
     var $t3: address
     # live vars: $t0, $t1
  0: $t3 := move($t0)
     # live vars: $t1, $t3
  1: $t2 := !=($t3, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::neq7($t0: vector<u8>, $t1: vector<u8>): bool {
     var $t2: bool
     var $t3: vector<u8>
     # live vars: $t0, $t1
  0: $t3 := move($t0)
     # live vars: $t1, $t3
  1: $t2 := !=($t3, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::neq8($t0: vector<vector<u8>>, $t1: vector<vector<u8>>): bool {
     var $t2: bool
     var $t3: vector<vector<u8>>
     # live vars: $t0, $t1
  0: $t3 := move($t0)
     # live vars: $t1, $t3
  1: $t2 := !=($t3, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::neq9($t0: 0xcffa::m::Test1, $t1: 0xcffa::m::Test1): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test1
     # live vars: $t0, $t1
  0: $t3 := move($t0)
     # live vars: $t1, $t3
  1: $t2 := !=($t3, $t1)
     # live vars: $t2
  2: return $t2
}

============ after VariableCoalescingTransformer: ================

[variant baseline]
public fun m::eq1($t0: u64, $t1: u64): u64 {
     var $t2: u64 [unused]
     var $t3: bool
     var $t4: u64
  0: $t4 := copy($t0)
  1: $t3 := ==($t4, $t1)
  2: if ($t3) goto 3 else goto 7
  3: label L0
  4: $t4 := move($t0)
  5: label L2
  6: return $t4
  7: label L1
  8: $t4 := move($t1)
  9: goto 5
}


[variant baseline]
public fun m::eq10($t0: 0xcffa::m::Test2, $t1: 0xcffa::m::Test2): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test2 [unused]
  0: $t0 := move($t0)
  1: $t2 := ==($t0, $t1)
  2: return $t2
}


[variant baseline]
public fun m::eq2($t0: u64, $t1: u64): bool {
     var $t2: bool
     var $t3: &u64
     var $t4: &u64
  0: $t3 := borrow_local($t0)
  1: $t4 := borrow_local($t1)
  2: $t2 := ==($t3, $t4)
  3: return $t2
}


[variant baseline]
public fun m::eq3<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: #0 [unused]
  0: $t0 := move($t0)
  1: $t2 := ==($t0, $t1)
  2: return $t2
}


[variant baseline]
public fun m::eq4<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: &#0
     var $t4: &#0
  0: $t3 := borrow_local($t0)
  1: $t4 := borrow_local($t1)
  2: $t2 := ==($t3, $t4)
  3: return $t2
}


[variant baseline]
public fun m::eq5($t0: bool, $t1: bool): bool {
     var $t2: bool [unused]
     var $t3: bool [unused]
  0: $t0 := move($t0)
  1: $t0 := ==($t0, $t1)
  2: return $t0
}


[variant baseline]
public fun m::eq6($t0: address, $t1: address): bool {
     var $t2: bool
     var $t3: address [unused]
  0: $t0 := move($t0)
  1: $t2 := ==($t0, $t1)
  2: return $t2
}


[variant baseline]
public fun m::eq7($t0: vector<u8>, $t1: vector<u8>): bool {
     var $t2: bool
     var $t3: vector<u8> [unused]
  0: $t0 := move($t0)
  1: $t2 := ==($t0, $t1)
  2: return $t2
}


[variant baseline]
public fun m::eq8($t0: vector<vector<u8>>, $t1: vector<vector<u8>>): bool {
     var $t2: bool
     var $t3: vector<vector<u8>> [unused]
  0: $t0 := move($t0)
  1: $t2 := ==($t0, $t1)
  2: return $t2
}


[variant baseline]
public fun m::eq9($t0: 0xcffa::m::Test1, $t1: 0xcffa::m::Test1): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test1 [unused]
  0: $t0 := move($t0)
  1: $t2 := ==($t0, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq1($t0: u64, $t1: u64): bool {
     var $t2: bool
     var $t3: u64 [unused]
  0: $t0 := move($t0)
  1: $t2 := !=($t0, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq10($t0: 0xcffa::m::Test2, $t1: 0xcffa::m::Test2): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test2 [unused]
  0: $t0 := move($t0)
  1: $t2 := !=($t0, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq2($t0: u64, $t1: u64): bool {
     var $t2: bool
     var $t3: &u64
     var $t4: &u64
  0: $t3 := borrow_local($t0)
  1: $t4 := borrow_local($t1)
  2: $t2 := !=($t3, $t4)
  3: return $t2
}


[variant baseline]
public fun m::neq3<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: #0 [unused]
  0: $t0 := move($t0)
  1: $t2 := !=($t0, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq4<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: &#0
     var $t4: &#0
  0: $t3 := borrow_local($t0)
  1: $t4 := borrow_local($t1)
  2: $t2 := !=($t3, $t4)
  3: return $t2
}


[variant baseline]
public fun m::neq5($t0: bool, $t1: bool): bool {
     var $t2: bool [unused]
     var $t3: bool [unused]
  0: $t0 := move($t0)
  1: $t0 := !=($t0, $t1)
  2: return $t0
}


[variant baseline]
public fun m::neq6($t0: address, $t1: address): bool {
     var $t2: bool
     var $t3: address [unused]
  0: $t0 := move($t0)
  1: $t2 := !=($t0, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq7($t0: vector<u8>, $t1: vector<u8>): bool {
     var $t2: bool
     var $t3: vector<u8> [unused]
  0: $t0 := move($t0)
  1: $t2 := !=($t0, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq8($t0: vector<vector<u8>>, $t1: vector<vector<u8>>): bool {
     var $t2: bool
     var $t3: vector<vector<u8>> [unused]
  0: $t0 := move($t0)
  1: $t2 := !=($t0, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq9($t0: 0xcffa::m::Test1, $t1: 0xcffa::m::Test1): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test1 [unused]
  0: $t0 := move($t0)
  1: $t2 := !=($t0, $t1)
  2: return $t2
}

============ after LiveVarAnalysisProcessor: ================

[variant baseline]
public fun m::eq1($t0: u64, $t1: u64): u64 {
     var $t2: u64 [unused]
     var $t3: bool
     var $t4: u64
     # live vars: $t0, $t1
  0: $t4 := copy($t0)
     # live vars: $t0, $t1, $t4
  1: $t3 := ==($t4, $t1)
     # live vars: $t0, $t1, $t3
  2: if ($t3) goto 3 else goto 7
     # live vars: $t0, $t1
  3: label L0
     # live vars: $t0
  4: $t4 := move($t0)
     # live vars: $t4
  5: label L2
     # live vars: $t4
  6: return $t4
     # live vars: $t0, $t1
  7: label L1
     # live vars: $t1
  8: $t4 := move($t1)
     # live vars: $t4
  9: goto 5
}


[variant baseline]
public fun m::eq10($t0: 0xcffa::m::Test2, $t1: 0xcffa::m::Test2): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test2 [unused]
     # live vars: $t0, $t1
  0: $t0 := move($t0)
     # live vars: $t0, $t1
  1: $t2 := ==($t0, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::eq2($t0: u64, $t1: u64): bool {
     var $t2: bool
     var $t3: &u64
     var $t4: &u64
     # live vars: $t0, $t1
  0: $t3 := borrow_local($t0)
     # live vars: $t1, $t3
  1: $t4 := borrow_local($t1)
     # live vars: $t3, $t4
  2: $t2 := ==($t3, $t4)
     # live vars: $t2
  3: return $t2
}


[variant baseline]
public fun m::eq3<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: #0 [unused]
     # live vars: $t0, $t1
  0: $t0 := move($t0)
     # live vars: $t0, $t1
  1: $t2 := ==($t0, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::eq4<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: &#0
     var $t4: &#0
     # live vars: $t0, $t1
  0: $t3 := borrow_local($t0)
     # live vars: $t1, $t3
  1: $t4 := borrow_local($t1)
     # live vars: $t3, $t4
  2: $t2 := ==($t3, $t4)
     # live vars: $t2
  3: return $t2
}


[variant baseline]
public fun m::eq5($t0: bool, $t1: bool): bool {
     var $t2: bool [unused]
     var $t3: bool [unused]
     # live vars: $t0, $t1
  0: $t0 := move($t0)
     # live vars: $t0, $t1
  1: $t0 := ==($t0, $t1)
     # live vars: $t0
  2: return $t0
}


[variant baseline]
public fun m::eq6($t0: address, $t1: address): bool {
     var $t2: bool
     var $t3: address [unused]
     # live vars: $t0, $t1
  0: $t0 := move($t0)
     # live vars: $t0, $t1
  1: $t2 := ==($t0, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::eq7($t0: vector<u8>, $t1: vector<u8>): bool {
     var $t2: bool
     var $t3: vector<u8> [unused]
     # live vars: $t0, $t1
  0: $t0 := move($t0)
     # live vars: $t0, $t1
  1: $t2 := ==($t0, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::eq8($t0: vector<vector<u8>>, $t1: vector<vector<u8>>): bool {
     var $t2: bool
     var $t3: vector<vector<u8>> [unused]
     # live vars: $t0, $t1
  0: $t0 := move($t0)
     # live vars: $t0, $t1
  1: $t2 := ==($t0, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::eq9($t0: 0xcffa::m::Test1, $t1: 0xcffa::m::Test1): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test1 [unused]
     # live vars: $t0, $t1
  0: $t0 := move($t0)
     # live vars: $t0, $t1
  1: $t2 := ==($t0, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::neq1($t0: u64, $t1: u64): bool {
     var $t2: bool
     var $t3: u64 [unused]
     # live vars: $t0, $t1
  0: $t0 := move($t0)
     # live vars: $t0, $t1
  1: $t2 := !=($t0, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::neq10($t0: 0xcffa::m::Test2, $t1: 0xcffa::m::Test2): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test2 [unused]
     # live vars: $t0, $t1
  0: $t0 := move($t0)
     # live vars: $t0, $t1
  1: $t2 := !=($t0, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::neq2($t0: u64, $t1: u64): bool {
     var $t2: bool
     var $t3: &u64
     var $t4: &u64
     # live vars: $t0, $t1
  0: $t3 := borrow_local($t0)
     # live vars: $t1, $t3
  1: $t4 := borrow_local($t1)
     # live vars: $t3, $t4
  2: $t2 := !=($t3, $t4)
     # live vars: $t2
  3: return $t2
}


[variant baseline]
public fun m::neq3<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: #0 [unused]
     # live vars: $t0, $t1
  0: $t0 := move($t0)
     # live vars: $t0, $t1
  1: $t2 := !=($t0, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::neq4<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: &#0
     var $t4: &#0
     # live vars: $t0, $t1
  0: $t3 := borrow_local($t0)
     # live vars: $t1, $t3
  1: $t4 := borrow_local($t1)
     # live vars: $t3, $t4
  2: $t2 := !=($t3, $t4)
     # live vars: $t2
  3: return $t2
}


[variant baseline]
public fun m::neq5($t0: bool, $t1: bool): bool {
     var $t2: bool [unused]
     var $t3: bool [unused]
     # live vars: $t0, $t1
  0: $t0 := move($t0)
     # live vars: $t0, $t1
  1: $t0 := !=($t0, $t1)
     # live vars: $t0
  2: return $t0
}


[variant baseline]
public fun m::neq6($t0: address, $t1: address): bool {
     var $t2: bool
     var $t3: address [unused]
     # live vars: $t0, $t1
  0: $t0 := move($t0)
     # live vars: $t0, $t1
  1: $t2 := !=($t0, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::neq7($t0: vector<u8>, $t1: vector<u8>): bool {
     var $t2: bool
     var $t3: vector<u8> [unused]
     # live vars: $t0, $t1
  0: $t0 := move($t0)
     # live vars: $t0, $t1
  1: $t2 := !=($t0, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::neq8($t0: vector<vector<u8>>, $t1: vector<vector<u8>>): bool {
     var $t2: bool
     var $t3: vector<vector<u8>> [unused]
     # live vars: $t0, $t1
  0: $t0 := move($t0)
     # live vars: $t0, $t1
  1: $t2 := !=($t0, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::neq9($t0: 0xcffa::m::Test1, $t1: 0xcffa::m::Test1): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test1 [unused]
     # live vars: $t0, $t1
  0: $t0 := move($t0)
     # live vars: $t0, $t1
  1: $t2 := !=($t0, $t1)
     # live vars: $t2
  2: return $t2
}

============ after DeadStoreElimination: ================

[variant baseline]
public fun m::eq1($t0: u64, $t1: u64): u64 {
     var $t2: u64 [unused]
     var $t3: bool
     var $t4: u64
  0: $t4 := copy($t0)
  1: $t3 := ==($t4, $t1)
  2: if ($t3) goto 3 else goto 7
  3: label L0
  4: $t4 := move($t0)
  5: label L2
  6: return $t4
  7: label L1
  8: $t4 := move($t1)
  9: goto 5
}


[variant baseline]
public fun m::eq10($t0: 0xcffa::m::Test2, $t1: 0xcffa::m::Test2): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test2 [unused]
  0: $t0 := move($t0)
  1: $t2 := ==($t0, $t1)
  2: return $t2
}


[variant baseline]
public fun m::eq2($t0: u64, $t1: u64): bool {
     var $t2: bool
     var $t3: &u64
     var $t4: &u64
  0: $t3 := borrow_local($t0)
  1: $t4 := borrow_local($t1)
  2: $t2 := ==($t3, $t4)
  3: return $t2
}


[variant baseline]
public fun m::eq3<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: #0 [unused]
  0: $t0 := move($t0)
  1: $t2 := ==($t0, $t1)
  2: return $t2
}


[variant baseline]
public fun m::eq4<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: &#0
     var $t4: &#0
  0: $t3 := borrow_local($t0)
  1: $t4 := borrow_local($t1)
  2: $t2 := ==($t3, $t4)
  3: return $t2
}


[variant baseline]
public fun m::eq5($t0: bool, $t1: bool): bool {
     var $t2: bool [unused]
     var $t3: bool [unused]
  0: $t0 := move($t0)
  1: $t0 := ==($t0, $t1)
  2: return $t0
}


[variant baseline]
public fun m::eq6($t0: address, $t1: address): bool {
     var $t2: bool
     var $t3: address [unused]
  0: $t0 := move($t0)
  1: $t2 := ==($t0, $t1)
  2: return $t2
}


[variant baseline]
public fun m::eq7($t0: vector<u8>, $t1: vector<u8>): bool {
     var $t2: bool
     var $t3: vector<u8> [unused]
  0: $t0 := move($t0)
  1: $t2 := ==($t0, $t1)
  2: return $t2
}


[variant baseline]
public fun m::eq8($t0: vector<vector<u8>>, $t1: vector<vector<u8>>): bool {
     var $t2: bool
     var $t3: vector<vector<u8>> [unused]
  0: $t0 := move($t0)
  1: $t2 := ==($t0, $t1)
  2: return $t2
}


[variant baseline]
public fun m::eq9($t0: 0xcffa::m::Test1, $t1: 0xcffa::m::Test1): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test1 [unused]
  0: $t0 := move($t0)
  1: $t2 := ==($t0, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq1($t0: u64, $t1: u64): bool {
     var $t2: bool
     var $t3: u64 [unused]
  0: $t0 := move($t0)
  1: $t2 := !=($t0, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq10($t0: 0xcffa::m::Test2, $t1: 0xcffa::m::Test2): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test2 [unused]
  0: $t0 := move($t0)
  1: $t2 := !=($t0, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq2($t0: u64, $t1: u64): bool {
     var $t2: bool
     var $t3: &u64
     var $t4: &u64
  0: $t3 := borrow_local($t0)
  1: $t4 := borrow_local($t1)
  2: $t2 := !=($t3, $t4)
  3: return $t2
}


[variant baseline]
public fun m::neq3<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: #0 [unused]
  0: $t0 := move($t0)
  1: $t2 := !=($t0, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq4<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: &#0
     var $t4: &#0
  0: $t3 := borrow_local($t0)
  1: $t4 := borrow_local($t1)
  2: $t2 := !=($t3, $t4)
  3: return $t2
}


[variant baseline]
public fun m::neq5($t0: bool, $t1: bool): bool {
     var $t2: bool [unused]
     var $t3: bool [unused]
  0: $t0 := move($t0)
  1: $t0 := !=($t0, $t1)
  2: return $t0
}


[variant baseline]
public fun m::neq6($t0: address, $t1: address): bool {
     var $t2: bool
     var $t3: address [unused]
  0: $t0 := move($t0)
  1: $t2 := !=($t0, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq7($t0: vector<u8>, $t1: vector<u8>): bool {
     var $t2: bool
     var $t3: vector<u8> [unused]
  0: $t0 := move($t0)
  1: $t2 := !=($t0, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq8($t0: vector<vector<u8>>, $t1: vector<vector<u8>>): bool {
     var $t2: bool
     var $t3: vector<vector<u8>> [unused]
  0: $t0 := move($t0)
  1: $t2 := !=($t0, $t1)
  2: return $t2
}


[variant baseline]
public fun m::neq9($t0: 0xcffa::m::Test1, $t1: 0xcffa::m::Test1): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test1 [unused]
  0: $t0 := move($t0)
  1: $t2 := !=($t0, $t1)
  2: return $t2
}

============ after LiveVarAnalysisProcessor: ================

[variant baseline]
public fun m::eq1($t0: u64, $t1: u64): u64 {
     var $t2: u64 [unused]
     var $t3: bool
     var $t4: u64
     # live vars: $t0, $t1
  0: $t4 := copy($t0)
     # live vars: $t0, $t1, $t4
  1: $t3 := ==($t4, $t1)
     # live vars: $t0, $t1, $t3
  2: if ($t3) goto 3 else goto 7
     # live vars: $t0, $t1
  3: label L0
     # live vars: $t0
  4: $t4 := move($t0)
     # live vars: $t4
  5: label L2
     # live vars: $t4
  6: return $t4
     # live vars: $t0, $t1
  7: label L1
     # live vars: $t1
  8: $t4 := move($t1)
     # live vars: $t4
  9: goto 5
}


[variant baseline]
public fun m::eq10($t0: 0xcffa::m::Test2, $t1: 0xcffa::m::Test2): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test2 [unused]
     # live vars: $t0, $t1
  0: $t0 := move($t0)
     # live vars: $t0, $t1
  1: $t2 := ==($t0, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::eq2($t0: u64, $t1: u64): bool {
     var $t2: bool
     var $t3: &u64
     var $t4: &u64
     # live vars: $t0, $t1
  0: $t3 := borrow_local($t0)
     # live vars: $t1, $t3
  1: $t4 := borrow_local($t1)
     # live vars: $t3, $t4
  2: $t2 := ==($t3, $t4)
     # live vars: $t2
  3: return $t2
}


[variant baseline]
public fun m::eq3<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: #0 [unused]
     # live vars: $t0, $t1
  0: $t0 := move($t0)
     # live vars: $t0, $t1
  1: $t2 := ==($t0, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::eq4<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: &#0
     var $t4: &#0
     # live vars: $t0, $t1
  0: $t3 := borrow_local($t0)
     # live vars: $t1, $t3
  1: $t4 := borrow_local($t1)
     # live vars: $t3, $t4
  2: $t2 := ==($t3, $t4)
     # live vars: $t2
  3: return $t2
}


[variant baseline]
public fun m::eq5($t0: bool, $t1: bool): bool {
     var $t2: bool [unused]
     var $t3: bool [unused]
     # live vars: $t0, $t1
  0: $t0 := move($t0)
     # live vars: $t0, $t1
  1: $t0 := ==($t0, $t1)
     # live vars: $t0
  2: return $t0
}


[variant baseline]
public fun m::eq6($t0: address, $t1: address): bool {
     var $t2: bool
     var $t3: address [unused]
     # live vars: $t0, $t1
  0: $t0 := move($t0)
     # live vars: $t0, $t1
  1: $t2 := ==($t0, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::eq7($t0: vector<u8>, $t1: vector<u8>): bool {
     var $t2: bool
     var $t3: vector<u8> [unused]
     # live vars: $t0, $t1
  0: $t0 := move($t0)
     # live vars: $t0, $t1
  1: $t2 := ==($t0, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::eq8($t0: vector<vector<u8>>, $t1: vector<vector<u8>>): bool {
     var $t2: bool
     var $t3: vector<vector<u8>> [unused]
     # live vars: $t0, $t1
  0: $t0 := move($t0)
     # live vars: $t0, $t1
  1: $t2 := ==($t0, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::eq9($t0: 0xcffa::m::Test1, $t1: 0xcffa::m::Test1): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test1 [unused]
     # live vars: $t0, $t1
  0: $t0 := move($t0)
     # live vars: $t0, $t1
  1: $t2 := ==($t0, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::neq1($t0: u64, $t1: u64): bool {
     var $t2: bool
     var $t3: u64 [unused]
     # live vars: $t0, $t1
  0: $t0 := move($t0)
     # live vars: $t0, $t1
  1: $t2 := !=($t0, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::neq10($t0: 0xcffa::m::Test2, $t1: 0xcffa::m::Test2): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test2 [unused]
     # live vars: $t0, $t1
  0: $t0 := move($t0)
     # live vars: $t0, $t1
  1: $t2 := !=($t0, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::neq2($t0: u64, $t1: u64): bool {
     var $t2: bool
     var $t3: &u64
     var $t4: &u64
     # live vars: $t0, $t1
  0: $t3 := borrow_local($t0)
     # live vars: $t1, $t3
  1: $t4 := borrow_local($t1)
     # live vars: $t3, $t4
  2: $t2 := !=($t3, $t4)
     # live vars: $t2
  3: return $t2
}


[variant baseline]
public fun m::neq3<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: #0 [unused]
     # live vars: $t0, $t1
  0: $t0 := move($t0)
     # live vars: $t0, $t1
  1: $t2 := !=($t0, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::neq4<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: &#0
     var $t4: &#0
     # live vars: $t0, $t1
  0: $t3 := borrow_local($t0)
     # live vars: $t1, $t3
  1: $t4 := borrow_local($t1)
     # live vars: $t3, $t4
  2: $t2 := !=($t3, $t4)
     # live vars: $t2
  3: return $t2
}


[variant baseline]
public fun m::neq5($t0: bool, $t1: bool): bool {
     var $t2: bool [unused]
     var $t3: bool [unused]
     # live vars: $t0, $t1
  0: $t0 := move($t0)
     # live vars: $t0, $t1
  1: $t0 := !=($t0, $t1)
     # live vars: $t0
  2: return $t0
}


[variant baseline]
public fun m::neq6($t0: address, $t1: address): bool {
     var $t2: bool
     var $t3: address [unused]
     # live vars: $t0, $t1
  0: $t0 := move($t0)
     # live vars: $t0, $t1
  1: $t2 := !=($t0, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::neq7($t0: vector<u8>, $t1: vector<u8>): bool {
     var $t2: bool
     var $t3: vector<u8> [unused]
     # live vars: $t0, $t1
  0: $t0 := move($t0)
     # live vars: $t0, $t1
  1: $t2 := !=($t0, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::neq8($t0: vector<vector<u8>>, $t1: vector<vector<u8>>): bool {
     var $t2: bool
     var $t3: vector<vector<u8>> [unused]
     # live vars: $t0, $t1
  0: $t0 := move($t0)
     # live vars: $t0, $t1
  1: $t2 := !=($t0, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::neq9($t0: 0xcffa::m::Test1, $t1: 0xcffa::m::Test1): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test1 [unused]
     # live vars: $t0, $t1
  0: $t0 := move($t0)
     # live vars: $t0, $t1
  1: $t2 := !=($t0, $t1)
     # live vars: $t2
  2: return $t2
}

============ after FlushWritesProcessor: ================

[variant baseline]
public fun m::eq1($t0: u64, $t1: u64): u64 {
     var $t2: u64 [unused]
     var $t3: bool
     var $t4: u64
     # live vars: $t0, $t1
  0: $t4 := copy($t0)
     # live vars: $t0, $t1, $t4
  1: $t3 := ==($t4, $t1)
     # live vars: $t0, $t1, $t3
  2: if ($t3) goto 3 else goto 7
     # live vars: $t0, $t1
  3: label L0
     # flush: $t4
     # live vars: $t0
  4: $t4 := move($t0)
     # live vars: $t4
  5: label L2
     # live vars: $t4
  6: return $t4
     # live vars: $t0, $t1
  7: label L1
     # flush: $t4
     # live vars: $t1
  8: $t4 := move($t1)
     # live vars: $t4
  9: goto 5
}


[variant baseline]
public fun m::eq10($t0: 0xcffa::m::Test2, $t1: 0xcffa::m::Test2): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test2 [unused]
     # live vars: $t0, $t1
  0: $t0 := move($t0)
     # live vars: $t0, $t1
  1: $t2 := ==($t0, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::eq2($t0: u64, $t1: u64): bool {
     var $t2: bool
     var $t3: &u64
     var $t4: &u64
     # live vars: $t0, $t1
  0: $t3 := borrow_local($t0)
     # live vars: $t1, $t3
  1: $t4 := borrow_local($t1)
     # live vars: $t3, $t4
  2: $t2 := ==($t3, $t4)
     # live vars: $t2
  3: return $t2
}


[variant baseline]
public fun m::eq3<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: #0 [unused]
     # live vars: $t0, $t1
  0: $t0 := move($t0)
     # live vars: $t0, $t1
  1: $t2 := ==($t0, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::eq4<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: &#0
     var $t4: &#0
     # live vars: $t0, $t1
  0: $t3 := borrow_local($t0)
     # live vars: $t1, $t3
  1: $t4 := borrow_local($t1)
     # live vars: $t3, $t4
  2: $t2 := ==($t3, $t4)
     # live vars: $t2
  3: return $t2
}


[variant baseline]
public fun m::eq5($t0: bool, $t1: bool): bool {
     var $t2: bool [unused]
     var $t3: bool [unused]
     # live vars: $t0, $t1
  0: $t0 := move($t0)
     # live vars: $t0, $t1
  1: $t0 := ==($t0, $t1)
     # live vars: $t0
  2: return $t0
}


[variant baseline]
public fun m::eq6($t0: address, $t1: address): bool {
     var $t2: bool
     var $t3: address [unused]
     # live vars: $t0, $t1
  0: $t0 := move($t0)
     # live vars: $t0, $t1
  1: $t2 := ==($t0, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::eq7($t0: vector<u8>, $t1: vector<u8>): bool {
     var $t2: bool
     var $t3: vector<u8> [unused]
     # live vars: $t0, $t1
  0: $t0 := move($t0)
     # live vars: $t0, $t1
  1: $t2 := ==($t0, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::eq8($t0: vector<vector<u8>>, $t1: vector<vector<u8>>): bool {
     var $t2: bool
     var $t3: vector<vector<u8>> [unused]
     # live vars: $t0, $t1
  0: $t0 := move($t0)
     # live vars: $t0, $t1
  1: $t2 := ==($t0, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::eq9($t0: 0xcffa::m::Test1, $t1: 0xcffa::m::Test1): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test1 [unused]
     # live vars: $t0, $t1
  0: $t0 := move($t0)
     # live vars: $t0, $t1
  1: $t2 := ==($t0, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::neq1($t0: u64, $t1: u64): bool {
     var $t2: bool
     var $t3: u64 [unused]
     # live vars: $t0, $t1
  0: $t0 := move($t0)
     # live vars: $t0, $t1
  1: $t2 := !=($t0, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::neq10($t0: 0xcffa::m::Test2, $t1: 0xcffa::m::Test2): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test2 [unused]
     # live vars: $t0, $t1
  0: $t0 := move($t0)
     # live vars: $t0, $t1
  1: $t2 := !=($t0, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::neq2($t0: u64, $t1: u64): bool {
     var $t2: bool
     var $t3: &u64
     var $t4: &u64
     # live vars: $t0, $t1
  0: $t3 := borrow_local($t0)
     # live vars: $t1, $t3
  1: $t4 := borrow_local($t1)
     # live vars: $t3, $t4
  2: $t2 := !=($t3, $t4)
     # live vars: $t2
  3: return $t2
}


[variant baseline]
public fun m::neq3<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: #0 [unused]
     # live vars: $t0, $t1
  0: $t0 := move($t0)
     # live vars: $t0, $t1
  1: $t2 := !=($t0, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::neq4<#0>($t0: #0, $t1: #0): bool {
     var $t2: bool
     var $t3: &#0
     var $t4: &#0
     # live vars: $t0, $t1
  0: $t3 := borrow_local($t0)
     # live vars: $t1, $t3
  1: $t4 := borrow_local($t1)
     # live vars: $t3, $t4
  2: $t2 := !=($t3, $t4)
     # live vars: $t2
  3: return $t2
}


[variant baseline]
public fun m::neq5($t0: bool, $t1: bool): bool {
     var $t2: bool [unused]
     var $t3: bool [unused]
     # live vars: $t0, $t1
  0: $t0 := move($t0)
     # live vars: $t0, $t1
  1: $t0 := !=($t0, $t1)
     # live vars: $t0
  2: return $t0
}


[variant baseline]
public fun m::neq6($t0: address, $t1: address): bool {
     var $t2: bool
     var $t3: address [unused]
     # live vars: $t0, $t1
  0: $t0 := move($t0)
     # live vars: $t0, $t1
  1: $t2 := !=($t0, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::neq7($t0: vector<u8>, $t1: vector<u8>): bool {
     var $t2: bool
     var $t3: vector<u8> [unused]
     # live vars: $t0, $t1
  0: $t0 := move($t0)
     # live vars: $t0, $t1
  1: $t2 := !=($t0, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::neq8($t0: vector<vector<u8>>, $t1: vector<vector<u8>>): bool {
     var $t2: bool
     var $t3: vector<vector<u8>> [unused]
     # live vars: $t0, $t1
  0: $t0 := move($t0)
     # live vars: $t0, $t1
  1: $t2 := !=($t0, $t1)
     # live vars: $t2
  2: return $t2
}


[variant baseline]
public fun m::neq9($t0: 0xcffa::m::Test1, $t1: 0xcffa::m::Test1): bool {
     var $t2: bool
     var $t3: 0xcffa::m::Test1 [unused]
     # live vars: $t0, $t1
  0: $t0 := move($t0)
     # live vars: $t0, $t1
  1: $t2 := !=($t0, $t1)
     # live vars: $t2
  2: return $t2
}


============ disassembled file-format ==================
// Move bytecode v8
module cffa.m {
struct Test1 has drop {
	a: u8
}
struct Test2 has drop {
	a: vector<u8>
}

public eq1(x: u64, y: u64): u64 /* def_idx: 0 */ {
L2:	$t4: u64
B0:
	0: CopyLoc[0](x: u64)
	1: CopyLoc[1](y: u64)
	2: Eq
	3: BrFalse(8)
B1:
	4: MoveLoc[0](x: u64)
	5: StLoc[2]($t4: u64)
B2:
	6: MoveLoc[2]($t4: u64)
	7: Ret
B3:
	8: MoveLoc[1](y: u64)
	9: StLoc[2]($t4: u64)
	10: Branch(6)
}
public eq10(x: Test2, y: Test2): bool /* def_idx: 1 */ {
B0:
	0: MoveLoc[0](x: Test2)
	1: MoveLoc[1](y: Test2)
	2: Eq
	3: Ret
}
public eq2(x: u64, y: u64): bool /* def_idx: 2 */ {
B0:
	0: ImmBorrowLoc[0](x: u64)
	1: ImmBorrowLoc[1](y: u64)
	2: Eq
	3: Ret
}
public eq3<T: copy + drop>(x: T, y: T): bool /* def_idx: 3 */ {
B0:
	0: MoveLoc[0](x: T)
	1: MoveLoc[1](y: T)
	2: Eq
	3: Ret
}
public eq4<T: copy + drop>(x: T, y: T): bool /* def_idx: 4 */ {
B0:
	0: ImmBorrowLoc[0](x: T)
	1: ImmBorrowLoc[1](y: T)
	2: Eq
	3: Ret
}
public eq5(x: bool, y: bool): bool /* def_idx: 5 */ {
B0:
	0: MoveLoc[0](x: bool)
	1: MoveLoc[1](y: bool)
	2: Eq
	3: Ret
}
public eq6(x: address, y: address): bool /* def_idx: 6 */ {
B0:
	0: MoveLoc[0](x: address)
	1: MoveLoc[1](y: address)
	2: Eq
	3: Ret
}
public eq7(x: vector<u8>, y: vector<u8>): bool /* def_idx: 7 */ {
B0:
	0: MoveLoc[0](x: vector<u8>)
	1: MoveLoc[1](y: vector<u8>)
	2: Eq
	3: Ret
}
public eq8(x: vector<vector<u8>>, y: vector<vector<u8>>): bool /* def_idx: 8 */ {
B0:
	0: MoveLoc[0](x: vector<vector<u8>>)
	1: MoveLoc[1](y: vector<vector<u8>>)
	2: Eq
	3: Ret
}
public eq9(x: Test1, y: Test1): bool /* def_idx: 9 */ {
B0:
	0: MoveLoc[0](x: Test1)
	1: MoveLoc[1](y: Test1)
	2: Eq
	3: Ret
}
public neq1(x: u64, y: u64): bool /* def_idx: 10 */ {
B0:
	0: MoveLoc[0](x: u64)
	1: MoveLoc[1](y: u64)
	2: Neq
	3: Ret
}
public neq10(x: Test2, y: Test2): bool /* def_idx: 11 */ {
B0:
	0: MoveLoc[0](x: Test2)
	1: MoveLoc[1](y: Test2)
	2: Neq
	3: Ret
}
public neq2(x: u64, y: u64): bool /* def_idx: 12 */ {
B0:
	0: ImmBorrowLoc[0](x: u64)
	1: ImmBorrowLoc[1](y: u64)
	2: Neq
	3: Ret
}
public neq3<T: copy + drop>(x: T, y: T): bool /* def_idx: 13 */ {
B0:
	0: MoveLoc[0](x: T)
	1: MoveLoc[1](y: T)
	2: Neq
	3: Ret
}
public neq4<T: copy + drop>(x: T, y: T): bool /* def_idx: 14 */ {
B0:
	0: ImmBorrowLoc[0](x: T)
	1: ImmBorrowLoc[1](y: T)
	2: Neq
	3: Ret
}
public neq5(x: bool, y: bool): bool /* def_idx: 15 */ {
B0:
	0: MoveLoc[0](x: bool)
	1: MoveLoc[1](y: bool)
	2: Neq
	3: Ret
}
public neq6(x: address, y: address): bool /* def_idx: 16 */ {
B0:
	0: MoveLoc[0](x: address)
	1: MoveLoc[1](y: address)
	2: Neq
	3: Ret
}
public neq7(x: vector<u8>, y: vector<u8>): bool /* def_idx: 17 */ {
B0:
	0: MoveLoc[0](x: vector<u8>)
	1: MoveLoc[1](y: vector<u8>)
	2: Neq
	3: Ret
}
public neq8(x: vector<vector<u8>>, y: vector<vector<u8>>): bool /* def_idx: 18 */ {
B0:
	0: MoveLoc[0](x: vector<vector<u8>>)
	1: MoveLoc[1](y: vector<vector<u8>>)
	2: Neq
	3: Ret
}
public neq9(x: Test1, y: Test1): bool /* def_idx: 19 */ {
B0:
	0: MoveLoc[0](x: Test1)
	1: MoveLoc[1](y: Test1)
	2: Neq
	3: Ret
}
}
============ bytecode verification succeeded ========
