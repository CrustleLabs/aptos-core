// -- Model dump before env processor pipeline:
module 0x1::test {
    struct Work {
        0: |u64|u64 has copy + drop,
    }
    private fun eq1(): Work {
        {
          let work1: Work = pack test::Work(|x: u64| Add<u64>(x, 1));
          {
            let work2: Work = pack test::Work(|x: u64| Add<u64>(x, 2));
            if Eq<Work>(work1, work2) {
              work1
            } else {
              work2
            }
          }
        }
    }
    private fun eq2(): Work {
        {
          let work1: Work = pack test::Work(|x: u64| Add<u64>(x, 1));
          {
            let work2: Work = pack test::Work(|x: u64| Add<u64>(x, 2));
            if Eq<Work>(Borrow(Immutable)(work1), Borrow(Immutable)(work2)) {
              work1
            } else {
              work2
            }
          }
        }
    }
    private fun eq3(): Work {
        {
          let work1: Work = pack test::Work(|x: u64| Add<u64>(x, 1));
          {
            let work2: Work = pack test::Work(|x: u64| Add<u64>(x, 2));
            if Eq<u64>((work1)(2), (work2)(1)) {
              work1
            } else {
              work2
            }
          }
        }
    }
    private fun eq4(): Work {
        {
          let work1: Work = pack test::Work(|x: u64| Add<u64>(x, 1));
          {
            let work2: Work = pack test::Work(|x: u64| Add<u64>(x, 2));
            if Eq<u64>(Borrow(Immutable)((work1)(2)), Borrow(Immutable)((work2)(1))) {
              work1
            } else {
              work2
            }
          }
        }
    }
} // end 0x1::test


// -- Model dump after env processor unused checks:
module 0x1::test {
    struct Work {
        0: |u64|u64 has copy + drop,
    }
    private fun eq1(): Work {
        {
          let work1: Work = pack test::Work(|x: u64| Add<u64>(x, 1));
          {
            let work2: Work = pack test::Work(|x: u64| Add<u64>(x, 2));
            if Eq<Work>(work1, work2) {
              work1
            } else {
              work2
            }
          }
        }
    }
    private fun eq2(): Work {
        {
          let work1: Work = pack test::Work(|x: u64| Add<u64>(x, 1));
          {
            let work2: Work = pack test::Work(|x: u64| Add<u64>(x, 2));
            if Eq<Work>(Borrow(Immutable)(work1), Borrow(Immutable)(work2)) {
              work1
            } else {
              work2
            }
          }
        }
    }
    private fun eq3(): Work {
        {
          let work1: Work = pack test::Work(|x: u64| Add<u64>(x, 1));
          {
            let work2: Work = pack test::Work(|x: u64| Add<u64>(x, 2));
            if Eq<u64>((work1)(2), (work2)(1)) {
              work1
            } else {
              work2
            }
          }
        }
    }
    private fun eq4(): Work {
        {
          let work1: Work = pack test::Work(|x: u64| Add<u64>(x, 1));
          {
            let work2: Work = pack test::Work(|x: u64| Add<u64>(x, 2));
            if Eq<u64>(Borrow(Immutable)((work1)(2)), Borrow(Immutable)((work2)(1))) {
              work1
            } else {
              work2
            }
          }
        }
    }
} // end 0x1::test


// -- Model dump after env processor type parameter check:
module 0x1::test {
    struct Work {
        0: |u64|u64 has copy + drop,
    }
    private fun eq1(): Work {
        {
          let work1: Work = pack test::Work(|x: u64| Add<u64>(x, 1));
          {
            let work2: Work = pack test::Work(|x: u64| Add<u64>(x, 2));
            if Eq<Work>(work1, work2) {
              work1
            } else {
              work2
            }
          }
        }
    }
    private fun eq2(): Work {
        {
          let work1: Work = pack test::Work(|x: u64| Add<u64>(x, 1));
          {
            let work2: Work = pack test::Work(|x: u64| Add<u64>(x, 2));
            if Eq<Work>(Borrow(Immutable)(work1), Borrow(Immutable)(work2)) {
              work1
            } else {
              work2
            }
          }
        }
    }
    private fun eq3(): Work {
        {
          let work1: Work = pack test::Work(|x: u64| Add<u64>(x, 1));
          {
            let work2: Work = pack test::Work(|x: u64| Add<u64>(x, 2));
            if Eq<u64>((work1)(2), (work2)(1)) {
              work1
            } else {
              work2
            }
          }
        }
    }
    private fun eq4(): Work {
        {
          let work1: Work = pack test::Work(|x: u64| Add<u64>(x, 1));
          {
            let work2: Work = pack test::Work(|x: u64| Add<u64>(x, 2));
            if Eq<u64>(Borrow(Immutable)((work1)(2)), Borrow(Immutable)((work2)(1))) {
              work1
            } else {
              work2
            }
          }
        }
    }
} // end 0x1::test


// -- Model dump after env processor check recursive struct definition:
module 0x1::test {
    struct Work {
        0: |u64|u64 has copy + drop,
    }
    private fun eq1(): Work {
        {
          let work1: Work = pack test::Work(|x: u64| Add<u64>(x, 1));
          {
            let work2: Work = pack test::Work(|x: u64| Add<u64>(x, 2));
            if Eq<Work>(work1, work2) {
              work1
            } else {
              work2
            }
          }
        }
    }
    private fun eq2(): Work {
        {
          let work1: Work = pack test::Work(|x: u64| Add<u64>(x, 1));
          {
            let work2: Work = pack test::Work(|x: u64| Add<u64>(x, 2));
            if Eq<Work>(Borrow(Immutable)(work1), Borrow(Immutable)(work2)) {
              work1
            } else {
              work2
            }
          }
        }
    }
    private fun eq3(): Work {
        {
          let work1: Work = pack test::Work(|x: u64| Add<u64>(x, 1));
          {
            let work2: Work = pack test::Work(|x: u64| Add<u64>(x, 2));
            if Eq<u64>((work1)(2), (work2)(1)) {
              work1
            } else {
              work2
            }
          }
        }
    }
    private fun eq4(): Work {
        {
          let work1: Work = pack test::Work(|x: u64| Add<u64>(x, 1));
          {
            let work2: Work = pack test::Work(|x: u64| Add<u64>(x, 2));
            if Eq<u64>(Borrow(Immutable)((work1)(2)), Borrow(Immutable)((work2)(1))) {
              work1
            } else {
              work2
            }
          }
        }
    }
} // end 0x1::test


// -- Model dump after env processor check cyclic type instantiation:
module 0x1::test {
    struct Work {
        0: |u64|u64 has copy + drop,
    }
    private fun eq1(): Work {
        {
          let work1: Work = pack test::Work(|x: u64| Add<u64>(x, 1));
          {
            let work2: Work = pack test::Work(|x: u64| Add<u64>(x, 2));
            if Eq<Work>(work1, work2) {
              work1
            } else {
              work2
            }
          }
        }
    }
    private fun eq2(): Work {
        {
          let work1: Work = pack test::Work(|x: u64| Add<u64>(x, 1));
          {
            let work2: Work = pack test::Work(|x: u64| Add<u64>(x, 2));
            if Eq<Work>(Borrow(Immutable)(work1), Borrow(Immutable)(work2)) {
              work1
            } else {
              work2
            }
          }
        }
    }
    private fun eq3(): Work {
        {
          let work1: Work = pack test::Work(|x: u64| Add<u64>(x, 1));
          {
            let work2: Work = pack test::Work(|x: u64| Add<u64>(x, 2));
            if Eq<u64>((work1)(2), (work2)(1)) {
              work1
            } else {
              work2
            }
          }
        }
    }
    private fun eq4(): Work {
        {
          let work1: Work = pack test::Work(|x: u64| Add<u64>(x, 1));
          {
            let work2: Work = pack test::Work(|x: u64| Add<u64>(x, 2));
            if Eq<u64>(Borrow(Immutable)((work1)(2)), Borrow(Immutable)((work2)(1))) {
              work1
            } else {
              work2
            }
          }
        }
    }
} // end 0x1::test


// -- Model dump after env processor unused struct params check:
module 0x1::test {
    struct Work {
        0: |u64|u64 has copy + drop,
    }
    private fun eq1(): Work {
        {
          let work1: Work = pack test::Work(|x: u64| Add<u64>(x, 1));
          {
            let work2: Work = pack test::Work(|x: u64| Add<u64>(x, 2));
            if Eq<Work>(work1, work2) {
              work1
            } else {
              work2
            }
          }
        }
    }
    private fun eq2(): Work {
        {
          let work1: Work = pack test::Work(|x: u64| Add<u64>(x, 1));
          {
            let work2: Work = pack test::Work(|x: u64| Add<u64>(x, 2));
            if Eq<Work>(Borrow(Immutable)(work1), Borrow(Immutable)(work2)) {
              work1
            } else {
              work2
            }
          }
        }
    }
    private fun eq3(): Work {
        {
          let work1: Work = pack test::Work(|x: u64| Add<u64>(x, 1));
          {
            let work2: Work = pack test::Work(|x: u64| Add<u64>(x, 2));
            if Eq<u64>((work1)(2), (work2)(1)) {
              work1
            } else {
              work2
            }
          }
        }
    }
    private fun eq4(): Work {
        {
          let work1: Work = pack test::Work(|x: u64| Add<u64>(x, 1));
          {
            let work2: Work = pack test::Work(|x: u64| Add<u64>(x, 2));
            if Eq<u64>(Borrow(Immutable)((work1)(2)), Borrow(Immutable)((work2)(1))) {
              work1
            } else {
              work2
            }
          }
        }
    }
} // end 0x1::test


// -- Model dump after env processor access and use check before inlining:
module 0x1::test {
    struct Work {
        0: |u64|u64 has copy + drop,
    }
    private fun eq1(): Work {
        {
          let work1: Work = pack test::Work(|x: u64| Add<u64>(x, 1));
          {
            let work2: Work = pack test::Work(|x: u64| Add<u64>(x, 2));
            if Eq<Work>(work1, work2) {
              work1
            } else {
              work2
            }
          }
        }
    }
    private fun eq2(): Work {
        {
          let work1: Work = pack test::Work(|x: u64| Add<u64>(x, 1));
          {
            let work2: Work = pack test::Work(|x: u64| Add<u64>(x, 2));
            if Eq<Work>(Borrow(Immutable)(work1), Borrow(Immutable)(work2)) {
              work1
            } else {
              work2
            }
          }
        }
    }
    private fun eq3(): Work {
        {
          let work1: Work = pack test::Work(|x: u64| Add<u64>(x, 1));
          {
            let work2: Work = pack test::Work(|x: u64| Add<u64>(x, 2));
            if Eq<u64>((work1)(2), (work2)(1)) {
              work1
            } else {
              work2
            }
          }
        }
    }
    private fun eq4(): Work {
        {
          let work1: Work = pack test::Work(|x: u64| Add<u64>(x, 1));
          {
            let work2: Work = pack test::Work(|x: u64| Add<u64>(x, 2));
            if Eq<u64>(Borrow(Immutable)((work1)(2)), Borrow(Immutable)((work2)(1))) {
              work1
            } else {
              work2
            }
          }
        }
    }
} // end 0x1::test


// -- Model dump after env processor inlining:
module 0x1::test {
    struct Work {
        0: |u64|u64 has copy + drop,
    }
    private fun eq1(): Work {
        {
          let work1: Work = pack test::Work(|x: u64| Add<u64>(x, 1));
          {
            let work2: Work = pack test::Work(|x: u64| Add<u64>(x, 2));
            if Eq<Work>(work1, work2) {
              work1
            } else {
              work2
            }
          }
        }
    }
    private fun eq2(): Work {
        {
          let work1: Work = pack test::Work(|x: u64| Add<u64>(x, 1));
          {
            let work2: Work = pack test::Work(|x: u64| Add<u64>(x, 2));
            if Eq<Work>(Borrow(Immutable)(work1), Borrow(Immutable)(work2)) {
              work1
            } else {
              work2
            }
          }
        }
    }
    private fun eq3(): Work {
        {
          let work1: Work = pack test::Work(|x: u64| Add<u64>(x, 1));
          {
            let work2: Work = pack test::Work(|x: u64| Add<u64>(x, 2));
            if Eq<u64>((work1)(2), (work2)(1)) {
              work1
            } else {
              work2
            }
          }
        }
    }
    private fun eq4(): Work {
        {
          let work1: Work = pack test::Work(|x: u64| Add<u64>(x, 1));
          {
            let work2: Work = pack test::Work(|x: u64| Add<u64>(x, 2));
            if Eq<u64>(Borrow(Immutable)((work1)(2)), Borrow(Immutable)((work2)(1))) {
              work1
            } else {
              work2
            }
          }
        }
    }
} // end 0x1::test


// -- Model dump after env processor access and use check after inlining:
module 0x1::test {
    struct Work {
        0: |u64|u64 has copy + drop,
    }
    private fun eq1(): Work {
        {
          let work1: Work = pack test::Work(|x: u64| Add<u64>(x, 1));
          {
            let work2: Work = pack test::Work(|x: u64| Add<u64>(x, 2));
            if Eq<Work>(work1, work2) {
              work1
            } else {
              work2
            }
          }
        }
    }
    private fun eq2(): Work {
        {
          let work1: Work = pack test::Work(|x: u64| Add<u64>(x, 1));
          {
            let work2: Work = pack test::Work(|x: u64| Add<u64>(x, 2));
            if Eq<Work>(Borrow(Immutable)(work1), Borrow(Immutable)(work2)) {
              work1
            } else {
              work2
            }
          }
        }
    }
    private fun eq3(): Work {
        {
          let work1: Work = pack test::Work(|x: u64| Add<u64>(x, 1));
          {
            let work2: Work = pack test::Work(|x: u64| Add<u64>(x, 2));
            if Eq<u64>((work1)(2), (work2)(1)) {
              work1
            } else {
              work2
            }
          }
        }
    }
    private fun eq4(): Work {
        {
          let work1: Work = pack test::Work(|x: u64| Add<u64>(x, 1));
          {
            let work2: Work = pack test::Work(|x: u64| Add<u64>(x, 2));
            if Eq<u64>(Borrow(Immutable)((work1)(2)), Borrow(Immutable)((work2)(1))) {
              work1
            } else {
              work2
            }
          }
        }
    }
} // end 0x1::test


// -- Model dump after env processor acquires check:
module 0x1::test {
    struct Work {
        0: |u64|u64 has copy + drop,
    }
    private fun eq1(): Work {
        {
          let work1: Work = pack test::Work(|x: u64| Add<u64>(x, 1));
          {
            let work2: Work = pack test::Work(|x: u64| Add<u64>(x, 2));
            if Eq<Work>(work1, work2) {
              work1
            } else {
              work2
            }
          }
        }
    }
    private fun eq2(): Work {
        {
          let work1: Work = pack test::Work(|x: u64| Add<u64>(x, 1));
          {
            let work2: Work = pack test::Work(|x: u64| Add<u64>(x, 2));
            if Eq<Work>(Borrow(Immutable)(work1), Borrow(Immutable)(work2)) {
              work1
            } else {
              work2
            }
          }
        }
    }
    private fun eq3(): Work {
        {
          let work1: Work = pack test::Work(|x: u64| Add<u64>(x, 1));
          {
            let work2: Work = pack test::Work(|x: u64| Add<u64>(x, 2));
            if Eq<u64>((work1)(2), (work2)(1)) {
              work1
            } else {
              work2
            }
          }
        }
    }
    private fun eq4(): Work {
        {
          let work1: Work = pack test::Work(|x: u64| Add<u64>(x, 1));
          {
            let work2: Work = pack test::Work(|x: u64| Add<u64>(x, 2));
            if Eq<u64>(Borrow(Immutable)((work1)(2)), Borrow(Immutable)((work2)(1))) {
              work1
            } else {
              work2
            }
          }
        }
    }
} // end 0x1::test


// -- Model dump after env processor lambda-lifting:
module 0x1::test {
    struct Work {
        0: |u64|u64 has copy + drop,
    }
    private fun eq1(): Work {
        {
          let work1: Work = pack test::Work(closure#0test::__lambda__1__eq1());
          {
            let work2: Work = pack test::Work(closure#0test::__lambda__2__eq1());
            if Eq<Work>(work1, work2) {
              work1
            } else {
              work2
            }
          }
        }
    }
    private fun eq2(): Work {
        {
          let work1: Work = pack test::Work(closure#0test::__lambda__1__eq2());
          {
            let work2: Work = pack test::Work(closure#0test::__lambda__2__eq2());
            if Eq<Work>(Borrow(Immutable)(work1), Borrow(Immutable)(work2)) {
              work1
            } else {
              work2
            }
          }
        }
    }
    private fun eq3(): Work {
        {
          let work1: Work = pack test::Work(closure#0test::__lambda__1__eq3());
          {
            let work2: Work = pack test::Work(closure#0test::__lambda__2__eq3());
            if Eq<u64>((work1)(2), (work2)(1)) {
              work1
            } else {
              work2
            }
          }
        }
    }
    private fun eq4(): Work {
        {
          let work1: Work = pack test::Work(closure#0test::__lambda__1__eq4());
          {
            let work2: Work = pack test::Work(closure#0test::__lambda__2__eq4());
            if Eq<u64>(Borrow(Immutable)((work1)(2)), Borrow(Immutable)((work2)(1))) {
              work1
            } else {
              work2
            }
          }
        }
    }
    private fun __lambda__1__eq1(x: u64): u64 {
        Add<u64>(x, 1)
    }
    private fun __lambda__2__eq1(x: u64): u64 {
        Add<u64>(x, 2)
    }
    private fun __lambda__1__eq2(x: u64): u64 {
        Add<u64>(x, 1)
    }
    private fun __lambda__2__eq2(x: u64): u64 {
        Add<u64>(x, 2)
    }
    private fun __lambda__1__eq3(x: u64): u64 {
        Add<u64>(x, 1)
    }
    private fun __lambda__2__eq3(x: u64): u64 {
        Add<u64>(x, 2)
    }
    private fun __lambda__1__eq4(x: u64): u64 {
        Add<u64>(x, 1)
    }
    private fun __lambda__2__eq4(x: u64): u64 {
        Add<u64>(x, 2)
    }
} // end 0x1::test


// -- Model dump after env processor closure-checker:
module 0x1::test {
    struct Work {
        0: |u64|u64 has copy + drop,
    }
    private fun eq1(): Work {
        {
          let work1: Work = pack test::Work(closure#0test::__lambda__1__eq1());
          {
            let work2: Work = pack test::Work(closure#0test::__lambda__2__eq1());
            if Eq<Work>(work1, work2) {
              work1
            } else {
              work2
            }
          }
        }
    }
    private fun eq2(): Work {
        {
          let work1: Work = pack test::Work(closure#0test::__lambda__1__eq2());
          {
            let work2: Work = pack test::Work(closure#0test::__lambda__2__eq2());
            if Eq<Work>(Borrow(Immutable)(work1), Borrow(Immutable)(work2)) {
              work1
            } else {
              work2
            }
          }
        }
    }
    private fun eq3(): Work {
        {
          let work1: Work = pack test::Work(closure#0test::__lambda__1__eq3());
          {
            let work2: Work = pack test::Work(closure#0test::__lambda__2__eq3());
            if Eq<u64>((work1)(2), (work2)(1)) {
              work1
            } else {
              work2
            }
          }
        }
    }
    private fun eq4(): Work {
        {
          let work1: Work = pack test::Work(closure#0test::__lambda__1__eq4());
          {
            let work2: Work = pack test::Work(closure#0test::__lambda__2__eq4());
            if Eq<u64>(Borrow(Immutable)((work1)(2)), Borrow(Immutable)((work2)(1))) {
              work1
            } else {
              work2
            }
          }
        }
    }
    private fun __lambda__1__eq1(x: u64): u64 {
        Add<u64>(x, 1)
    }
    private fun __lambda__2__eq1(x: u64): u64 {
        Add<u64>(x, 2)
    }
    private fun __lambda__1__eq2(x: u64): u64 {
        Add<u64>(x, 1)
    }
    private fun __lambda__2__eq2(x: u64): u64 {
        Add<u64>(x, 2)
    }
    private fun __lambda__1__eq3(x: u64): u64 {
        Add<u64>(x, 1)
    }
    private fun __lambda__2__eq3(x: u64): u64 {
        Add<u64>(x, 2)
    }
    private fun __lambda__1__eq4(x: u64): u64 {
        Add<u64>(x, 1)
    }
    private fun __lambda__2__eq4(x: u64): u64 {
        Add<u64>(x, 2)
    }
} // end 0x1::test


// -- Model dump after env processor specification checker:
module 0x1::test {
    struct Work {
        0: |u64|u64 has copy + drop,
    }
    private fun eq1(): Work {
        {
          let work1: Work = pack test::Work(closure#0test::__lambda__1__eq1());
          {
            let work2: Work = pack test::Work(closure#0test::__lambda__2__eq1());
            if Eq<Work>(work1, work2) {
              work1
            } else {
              work2
            }
          }
        }
    }
    private fun eq2(): Work {
        {
          let work1: Work = pack test::Work(closure#0test::__lambda__1__eq2());
          {
            let work2: Work = pack test::Work(closure#0test::__lambda__2__eq2());
            if Eq<Work>(Borrow(Immutable)(work1), Borrow(Immutable)(work2)) {
              work1
            } else {
              work2
            }
          }
        }
    }
    private fun eq3(): Work {
        {
          let work1: Work = pack test::Work(closure#0test::__lambda__1__eq3());
          {
            let work2: Work = pack test::Work(closure#0test::__lambda__2__eq3());
            if Eq<u64>((work1)(2), (work2)(1)) {
              work1
            } else {
              work2
            }
          }
        }
    }
    private fun eq4(): Work {
        {
          let work1: Work = pack test::Work(closure#0test::__lambda__1__eq4());
          {
            let work2: Work = pack test::Work(closure#0test::__lambda__2__eq4());
            if Eq<u64>(Borrow(Immutable)((work1)(2)), Borrow(Immutable)((work2)(1))) {
              work1
            } else {
              work2
            }
          }
        }
    }
    private fun __lambda__1__eq1(x: u64): u64 {
        Add<u64>(x, 1)
    }
    private fun __lambda__2__eq1(x: u64): u64 {
        Add<u64>(x, 2)
    }
    private fun __lambda__1__eq2(x: u64): u64 {
        Add<u64>(x, 1)
    }
    private fun __lambda__2__eq2(x: u64): u64 {
        Add<u64>(x, 2)
    }
    private fun __lambda__1__eq3(x: u64): u64 {
        Add<u64>(x, 1)
    }
    private fun __lambda__2__eq3(x: u64): u64 {
        Add<u64>(x, 2)
    }
    private fun __lambda__1__eq4(x: u64): u64 {
        Add<u64>(x, 1)
    }
    private fun __lambda__2__eq4(x: u64): u64 {
        Add<u64>(x, 2)
    }
} // end 0x1::test


// -- Model dump after env processor specification rewriter:
module 0x1::test {
    struct Work {
        0: |u64|u64 has copy + drop,
    }
    private fun eq1(): Work {
        {
          let work1: Work = pack test::Work(closure#0test::__lambda__1__eq1());
          {
            let work2: Work = pack test::Work(closure#0test::__lambda__2__eq1());
            if Eq<Work>(work1, work2) {
              work1
            } else {
              work2
            }
          }
        }
    }
    private fun eq2(): Work {
        {
          let work1: Work = pack test::Work(closure#0test::__lambda__1__eq2());
          {
            let work2: Work = pack test::Work(closure#0test::__lambda__2__eq2());
            if Eq<Work>(Borrow(Immutable)(work1), Borrow(Immutable)(work2)) {
              work1
            } else {
              work2
            }
          }
        }
    }
    private fun eq3(): Work {
        {
          let work1: Work = pack test::Work(closure#0test::__lambda__1__eq3());
          {
            let work2: Work = pack test::Work(closure#0test::__lambda__2__eq3());
            if Eq<u64>((work1)(2), (work2)(1)) {
              work1
            } else {
              work2
            }
          }
        }
    }
    private fun eq4(): Work {
        {
          let work1: Work = pack test::Work(closure#0test::__lambda__1__eq4());
          {
            let work2: Work = pack test::Work(closure#0test::__lambda__2__eq4());
            if Eq<u64>(Borrow(Immutable)((work1)(2)), Borrow(Immutable)((work2)(1))) {
              work1
            } else {
              work2
            }
          }
        }
    }
    private fun __lambda__1__eq1(x: u64): u64 {
        Add<u64>(x, 1)
    }
    private fun __lambda__2__eq1(x: u64): u64 {
        Add<u64>(x, 2)
    }
    private fun __lambda__1__eq2(x: u64): u64 {
        Add<u64>(x, 1)
    }
    private fun __lambda__2__eq2(x: u64): u64 {
        Add<u64>(x, 2)
    }
    private fun __lambda__1__eq3(x: u64): u64 {
        Add<u64>(x, 1)
    }
    private fun __lambda__2__eq3(x: u64): u64 {
        Add<u64>(x, 2)
    }
    private fun __lambda__1__eq4(x: u64): u64 {
        Add<u64>(x, 1)
    }
    private fun __lambda__2__eq4(x: u64): u64 {
        Add<u64>(x, 2)
    }
} // end 0x1::test


============ bytecode before first stackless bytecode pipeline ================

[variant baseline]
fun test::eq1(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop
     var $t5: bool
     var $t6: 0x1::test::Work
  0: $t2 := closure#0 test::__lambda__1__eq1()
  1: $t1 := pack 0x1::test::Work($t2)
  2: $t4 := closure#0 test::__lambda__2__eq1()
  3: $t3 := pack 0x1::test::Work($t4)
  4: $t6 := infer($t1)
  5: $t5 := ==($t6, $t3)
  6: if ($t5) goto 7 else goto 10
  7: label L0
  8: $t0 := infer($t1)
  9: goto 12
 10: label L1
 11: $t0 := infer($t3)
 12: label L2
 13: return $t0
}


[variant baseline]
fun test::eq2(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop
     var $t5: bool
     var $t6: &0x1::test::Work
     var $t7: &0x1::test::Work
  0: $t2 := closure#0 test::__lambda__1__eq2()
  1: $t1 := pack 0x1::test::Work($t2)
  2: $t4 := closure#0 test::__lambda__2__eq2()
  3: $t3 := pack 0x1::test::Work($t4)
  4: $t6 := borrow_local($t1)
  5: $t7 := borrow_local($t3)
  6: $t5 := ==($t6, $t7)
  7: if ($t5) goto 8 else goto 11
  8: label L0
  9: $t0 := infer($t1)
 10: goto 13
 11: label L1
 12: $t0 := infer($t3)
 13: label L2
 14: return $t0
}


[variant baseline]
fun test::eq3(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop
     var $t5: bool
     var $t6: u64
     var $t7: u64
     var $t8: |u64|u64 has copy + drop
     var $t9: u64
     var $t10: u64
     var $t11: |u64|u64 has copy + drop
  0: $t2 := closure#0 test::__lambda__1__eq3()
  1: $t1 := pack 0x1::test::Work($t2)
  2: $t4 := closure#0 test::__lambda__2__eq3()
  3: $t3 := pack 0x1::test::Work($t4)
  4: $t7 := 2
  5: $t8 := unpack 0x1::test::Work($t1)
  6: $t6 := invoke($t7, $t8)
  7: $t10 := 1
  8: $t11 := unpack 0x1::test::Work($t3)
  9: $t9 := invoke($t10, $t11)
 10: $t5 := ==($t6, $t9)
 11: if ($t5) goto 12 else goto 15
 12: label L0
 13: $t0 := infer($t1)
 14: goto 17
 15: label L1
 16: $t0 := infer($t3)
 17: label L2
 18: return $t0
}


[variant baseline]
fun test::eq4(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop
     var $t5: bool
     var $t6: &u64
     var $t7: u64
     var $t8: u64
     var $t9: |u64|u64 has copy + drop
     var $t10: &u64
     var $t11: u64
     var $t12: u64
     var $t13: |u64|u64 has copy + drop
  0: $t2 := closure#0 test::__lambda__1__eq4()
  1: $t1 := pack 0x1::test::Work($t2)
  2: $t4 := closure#0 test::__lambda__2__eq4()
  3: $t3 := pack 0x1::test::Work($t4)
  4: $t8 := 2
  5: $t9 := unpack 0x1::test::Work($t1)
  6: $t7 := invoke($t8, $t9)
  7: $t6 := borrow_local($t7)
  8: $t12 := 1
  9: $t13 := unpack 0x1::test::Work($t3)
 10: $t11 := invoke($t12, $t13)
 11: $t10 := borrow_local($t11)
 12: $t5 := ==($t6, $t10)
 13: if ($t5) goto 14 else goto 17
 14: label L0
 15: $t0 := infer($t1)
 16: goto 19
 17: label L1
 18: $t0 := infer($t3)
 19: label L2
 20: return $t0
}


[variant baseline]
fun test::__lambda__1__eq1($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
  0: $t2 := infer($t0)
  1: $t3 := 1
  2: $t1 := +($t2, $t3)
  3: return $t1
}


[variant baseline]
fun test::__lambda__2__eq1($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
  0: $t2 := infer($t0)
  1: $t3 := 2
  2: $t1 := +($t2, $t3)
  3: return $t1
}


[variant baseline]
fun test::__lambda__1__eq2($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
  0: $t2 := infer($t0)
  1: $t3 := 1
  2: $t1 := +($t2, $t3)
  3: return $t1
}


[variant baseline]
fun test::__lambda__2__eq2($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
  0: $t2 := infer($t0)
  1: $t3 := 2
  2: $t1 := +($t2, $t3)
  3: return $t1
}


[variant baseline]
fun test::__lambda__1__eq3($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
  0: $t2 := infer($t0)
  1: $t3 := 1
  2: $t1 := +($t2, $t3)
  3: return $t1
}


[variant baseline]
fun test::__lambda__2__eq3($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
  0: $t2 := infer($t0)
  1: $t3 := 2
  2: $t1 := +($t2, $t3)
  3: return $t1
}


[variant baseline]
fun test::__lambda__1__eq4($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
  0: $t2 := infer($t0)
  1: $t3 := 1
  2: $t1 := +($t2, $t3)
  3: return $t1
}


[variant baseline]
fun test::__lambda__2__eq4($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
  0: $t2 := infer($t0)
  1: $t3 := 2
  2: $t1 := +($t2, $t3)
  3: return $t1
}

============ after SplitCriticalEdgesProcessor: ================

[variant baseline]
fun test::eq1(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop
     var $t5: bool
     var $t6: 0x1::test::Work
  0: $t2 := closure#0 test::__lambda__1__eq1()
  1: $t1 := pack 0x1::test::Work($t2)
  2: $t4 := closure#0 test::__lambda__2__eq1()
  3: $t3 := pack 0x1::test::Work($t4)
  4: $t6 := infer($t1)
  5: $t5 := ==($t6, $t3)
  6: if ($t5) goto 7 else goto 10
  7: label L0
  8: $t0 := infer($t1)
  9: goto 12
 10: label L1
 11: $t0 := infer($t3)
 12: label L2
 13: return $t0
}


[variant baseline]
fun test::eq2(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop
     var $t5: bool
     var $t6: &0x1::test::Work
     var $t7: &0x1::test::Work
  0: $t2 := closure#0 test::__lambda__1__eq2()
  1: $t1 := pack 0x1::test::Work($t2)
  2: $t4 := closure#0 test::__lambda__2__eq2()
  3: $t3 := pack 0x1::test::Work($t4)
  4: $t6 := borrow_local($t1)
  5: $t7 := borrow_local($t3)
  6: $t5 := ==($t6, $t7)
  7: if ($t5) goto 8 else goto 11
  8: label L0
  9: $t0 := infer($t1)
 10: goto 13
 11: label L1
 12: $t0 := infer($t3)
 13: label L2
 14: return $t0
}


[variant baseline]
fun test::eq3(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop
     var $t5: bool
     var $t6: u64
     var $t7: u64
     var $t8: |u64|u64 has copy + drop
     var $t9: u64
     var $t10: u64
     var $t11: |u64|u64 has copy + drop
  0: $t2 := closure#0 test::__lambda__1__eq3()
  1: $t1 := pack 0x1::test::Work($t2)
  2: $t4 := closure#0 test::__lambda__2__eq3()
  3: $t3 := pack 0x1::test::Work($t4)
  4: $t7 := 2
  5: $t8 := unpack 0x1::test::Work($t1)
  6: $t6 := invoke($t7, $t8)
  7: $t10 := 1
  8: $t11 := unpack 0x1::test::Work($t3)
  9: $t9 := invoke($t10, $t11)
 10: $t5 := ==($t6, $t9)
 11: if ($t5) goto 12 else goto 15
 12: label L0
 13: $t0 := infer($t1)
 14: goto 17
 15: label L1
 16: $t0 := infer($t3)
 17: label L2
 18: return $t0
}


[variant baseline]
fun test::eq4(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop
     var $t5: bool
     var $t6: &u64
     var $t7: u64
     var $t8: u64
     var $t9: |u64|u64 has copy + drop
     var $t10: &u64
     var $t11: u64
     var $t12: u64
     var $t13: |u64|u64 has copy + drop
  0: $t2 := closure#0 test::__lambda__1__eq4()
  1: $t1 := pack 0x1::test::Work($t2)
  2: $t4 := closure#0 test::__lambda__2__eq4()
  3: $t3 := pack 0x1::test::Work($t4)
  4: $t8 := 2
  5: $t9 := unpack 0x1::test::Work($t1)
  6: $t7 := invoke($t8, $t9)
  7: $t6 := borrow_local($t7)
  8: $t12 := 1
  9: $t13 := unpack 0x1::test::Work($t3)
 10: $t11 := invoke($t12, $t13)
 11: $t10 := borrow_local($t11)
 12: $t5 := ==($t6, $t10)
 13: if ($t5) goto 14 else goto 17
 14: label L0
 15: $t0 := infer($t1)
 16: goto 19
 17: label L1
 18: $t0 := infer($t3)
 19: label L2
 20: return $t0
}


[variant baseline]
fun test::__lambda__1__eq1($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
  0: $t2 := infer($t0)
  1: $t3 := 1
  2: $t1 := +($t2, $t3)
  3: return $t1
}


[variant baseline]
fun test::__lambda__2__eq1($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
  0: $t2 := infer($t0)
  1: $t3 := 2
  2: $t1 := +($t2, $t3)
  3: return $t1
}


[variant baseline]
fun test::__lambda__1__eq2($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
  0: $t2 := infer($t0)
  1: $t3 := 1
  2: $t1 := +($t2, $t3)
  3: return $t1
}


[variant baseline]
fun test::__lambda__2__eq2($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
  0: $t2 := infer($t0)
  1: $t3 := 2
  2: $t1 := +($t2, $t3)
  3: return $t1
}


[variant baseline]
fun test::__lambda__1__eq3($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
  0: $t2 := infer($t0)
  1: $t3 := 1
  2: $t1 := +($t2, $t3)
  3: return $t1
}


[variant baseline]
fun test::__lambda__2__eq3($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
  0: $t2 := infer($t0)
  1: $t3 := 2
  2: $t1 := +($t2, $t3)
  3: return $t1
}


[variant baseline]
fun test::__lambda__1__eq4($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
  0: $t2 := infer($t0)
  1: $t3 := 1
  2: $t1 := +($t2, $t3)
  3: return $t1
}


[variant baseline]
fun test::__lambda__2__eq4($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
  0: $t2 := infer($t0)
  1: $t3 := 2
  2: $t1 := +($t2, $t3)
  3: return $t1
}

============ after uninitialized_use_checker: ================

[variant baseline]
fun test::eq1(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop
     var $t5: bool
     var $t6: 0x1::test::Work
  0: $t2 := closure#0 test::__lambda__1__eq1()
  1: $t1 := pack 0x1::test::Work($t2)
  2: $t4 := closure#0 test::__lambda__2__eq1()
  3: $t3 := pack 0x1::test::Work($t4)
  4: $t6 := infer($t1)
  5: $t5 := ==($t6, $t3)
  6: if ($t5) goto 7 else goto 10
  7: label L0
  8: $t0 := infer($t1)
  9: goto 12
 10: label L1
 11: $t0 := infer($t3)
 12: label L2
 13: return $t0
}


[variant baseline]
fun test::eq2(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop
     var $t5: bool
     var $t6: &0x1::test::Work
     var $t7: &0x1::test::Work
  0: $t2 := closure#0 test::__lambda__1__eq2()
  1: $t1 := pack 0x1::test::Work($t2)
  2: $t4 := closure#0 test::__lambda__2__eq2()
  3: $t3 := pack 0x1::test::Work($t4)
  4: $t6 := borrow_local($t1)
  5: $t7 := borrow_local($t3)
  6: $t5 := ==($t6, $t7)
  7: if ($t5) goto 8 else goto 11
  8: label L0
  9: $t0 := infer($t1)
 10: goto 13
 11: label L1
 12: $t0 := infer($t3)
 13: label L2
 14: return $t0
}


[variant baseline]
fun test::eq3(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop
     var $t5: bool
     var $t6: u64
     var $t7: u64
     var $t8: |u64|u64 has copy + drop
     var $t9: u64
     var $t10: u64
     var $t11: |u64|u64 has copy + drop
  0: $t2 := closure#0 test::__lambda__1__eq3()
  1: $t1 := pack 0x1::test::Work($t2)
  2: $t4 := closure#0 test::__lambda__2__eq3()
  3: $t3 := pack 0x1::test::Work($t4)
  4: $t7 := 2
  5: $t8 := unpack 0x1::test::Work($t1)
  6: $t6 := invoke($t7, $t8)
  7: $t10 := 1
  8: $t11 := unpack 0x1::test::Work($t3)
  9: $t9 := invoke($t10, $t11)
 10: $t5 := ==($t6, $t9)
 11: if ($t5) goto 12 else goto 15
 12: label L0
 13: $t0 := infer($t1)
 14: goto 17
 15: label L1
 16: $t0 := infer($t3)
 17: label L2
 18: return $t0
}


[variant baseline]
fun test::eq4(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop
     var $t5: bool
     var $t6: &u64
     var $t7: u64
     var $t8: u64
     var $t9: |u64|u64 has copy + drop
     var $t10: &u64
     var $t11: u64
     var $t12: u64
     var $t13: |u64|u64 has copy + drop
  0: $t2 := closure#0 test::__lambda__1__eq4()
  1: $t1 := pack 0x1::test::Work($t2)
  2: $t4 := closure#0 test::__lambda__2__eq4()
  3: $t3 := pack 0x1::test::Work($t4)
  4: $t8 := 2
  5: $t9 := unpack 0x1::test::Work($t1)
  6: $t7 := invoke($t8, $t9)
  7: $t6 := borrow_local($t7)
  8: $t12 := 1
  9: $t13 := unpack 0x1::test::Work($t3)
 10: $t11 := invoke($t12, $t13)
 11: $t10 := borrow_local($t11)
 12: $t5 := ==($t6, $t10)
 13: if ($t5) goto 14 else goto 17
 14: label L0
 15: $t0 := infer($t1)
 16: goto 19
 17: label L1
 18: $t0 := infer($t3)
 19: label L2
 20: return $t0
}


[variant baseline]
fun test::__lambda__1__eq1($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
  0: $t2 := infer($t0)
  1: $t3 := 1
  2: $t1 := +($t2, $t3)
  3: return $t1
}


[variant baseline]
fun test::__lambda__2__eq1($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
  0: $t2 := infer($t0)
  1: $t3 := 2
  2: $t1 := +($t2, $t3)
  3: return $t1
}


[variant baseline]
fun test::__lambda__1__eq2($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
  0: $t2 := infer($t0)
  1: $t3 := 1
  2: $t1 := +($t2, $t3)
  3: return $t1
}


[variant baseline]
fun test::__lambda__2__eq2($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
  0: $t2 := infer($t0)
  1: $t3 := 2
  2: $t1 := +($t2, $t3)
  3: return $t1
}


[variant baseline]
fun test::__lambda__1__eq3($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
  0: $t2 := infer($t0)
  1: $t3 := 1
  2: $t1 := +($t2, $t3)
  3: return $t1
}


[variant baseline]
fun test::__lambda__2__eq3($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
  0: $t2 := infer($t0)
  1: $t3 := 2
  2: $t1 := +($t2, $t3)
  3: return $t1
}


[variant baseline]
fun test::__lambda__1__eq4($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
  0: $t2 := infer($t0)
  1: $t3 := 1
  2: $t1 := +($t2, $t3)
  3: return $t1
}


[variant baseline]
fun test::__lambda__2__eq4($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
  0: $t2 := infer($t0)
  1: $t3 := 2
  2: $t1 := +($t2, $t3)
  3: return $t1
}

============ after LiveVarAnalysisProcessor: ================

[variant baseline]
fun test::eq1(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop
     var $t5: bool
     var $t6: 0x1::test::Work
     # live vars:
  0: $t2 := closure#0 test::__lambda__1__eq1()
     # live vars: $t2
  1: $t1 := pack 0x1::test::Work($t2)
     # live vars: $t1
  2: $t4 := closure#0 test::__lambda__2__eq1()
     # live vars: $t1, $t4
  3: $t3 := pack 0x1::test::Work($t4)
     # live vars: $t1, $t3
  4: $t6 := infer($t1)
     # live vars: $t1, $t3, $t6
  5: $t5 := ==($t6, $t3)
     # live vars: $t1, $t3, $t5
  6: if ($t5) goto 7 else goto 10
     # live vars: $t1, $t3
  7: label L0
     # live vars: $t1
  8: $t0 := infer($t1)
     # live vars: $t0
  9: goto 12
     # live vars: $t1, $t3
 10: label L1
     # live vars: $t3
 11: $t0 := infer($t3)
     # live vars: $t0
 12: label L2
     # live vars: $t0
 13: return $t0
}


[variant baseline]
fun test::eq2(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop
     var $t5: bool
     var $t6: &0x1::test::Work
     var $t7: &0x1::test::Work
     # live vars:
  0: $t2 := closure#0 test::__lambda__1__eq2()
     # live vars: $t2
  1: $t1 := pack 0x1::test::Work($t2)
     # live vars: $t1
  2: $t4 := closure#0 test::__lambda__2__eq2()
     # live vars: $t1, $t4
  3: $t3 := pack 0x1::test::Work($t4)
     # live vars: $t1, $t3
  4: $t6 := borrow_local($t1)
     # live vars: $t1, $t3, $t6
  5: $t7 := borrow_local($t3)
     # live vars: $t1, $t3, $t6, $t7
  6: $t5 := ==($t6, $t7)
     # live vars: $t1, $t3, $t5
  7: if ($t5) goto 8 else goto 11
     # live vars: $t1, $t3
  8: label L0
     # live vars: $t1
  9: $t0 := infer($t1)
     # live vars: $t0
 10: goto 13
     # live vars: $t1, $t3
 11: label L1
     # live vars: $t3
 12: $t0 := infer($t3)
     # live vars: $t0
 13: label L2
     # live vars: $t0
 14: return $t0
}


[variant baseline]
fun test::eq3(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop
     var $t5: bool
     var $t6: u64
     var $t7: u64
     var $t8: |u64|u64 has copy + drop
     var $t9: u64
     var $t10: u64
     var $t11: |u64|u64 has copy + drop
     # live vars:
  0: $t2 := closure#0 test::__lambda__1__eq3()
     # live vars: $t2
  1: $t1 := pack 0x1::test::Work($t2)
     # live vars: $t1
  2: $t4 := closure#0 test::__lambda__2__eq3()
     # live vars: $t1, $t4
  3: $t3 := pack 0x1::test::Work($t4)
     # live vars: $t1, $t3
  4: $t7 := 2
     # live vars: $t1, $t3, $t7
  5: $t8 := unpack 0x1::test::Work($t1)
     # live vars: $t1, $t3, $t7, $t8
  6: $t6 := invoke($t7, $t8)
     # live vars: $t1, $t3, $t6
  7: $t10 := 1
     # live vars: $t1, $t3, $t6, $t10
  8: $t11 := unpack 0x1::test::Work($t3)
     # live vars: $t1, $t3, $t6, $t10, $t11
  9: $t9 := invoke($t10, $t11)
     # live vars: $t1, $t3, $t6, $t9
 10: $t5 := ==($t6, $t9)
     # live vars: $t1, $t3, $t5
 11: if ($t5) goto 12 else goto 15
     # live vars: $t1, $t3
 12: label L0
     # live vars: $t1
 13: $t0 := infer($t1)
     # live vars: $t0
 14: goto 17
     # live vars: $t1, $t3
 15: label L1
     # live vars: $t3
 16: $t0 := infer($t3)
     # live vars: $t0
 17: label L2
     # live vars: $t0
 18: return $t0
}


[variant baseline]
fun test::eq4(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop
     var $t5: bool
     var $t6: &u64
     var $t7: u64
     var $t8: u64
     var $t9: |u64|u64 has copy + drop
     var $t10: &u64
     var $t11: u64
     var $t12: u64
     var $t13: |u64|u64 has copy + drop
     # live vars:
  0: $t2 := closure#0 test::__lambda__1__eq4()
     # live vars: $t2
  1: $t1 := pack 0x1::test::Work($t2)
     # live vars: $t1
  2: $t4 := closure#0 test::__lambda__2__eq4()
     # live vars: $t1, $t4
  3: $t3 := pack 0x1::test::Work($t4)
     # live vars: $t1, $t3
  4: $t8 := 2
     # live vars: $t1, $t3, $t8
  5: $t9 := unpack 0x1::test::Work($t1)
     # live vars: $t1, $t3, $t8, $t9
  6: $t7 := invoke($t8, $t9)
     # live vars: $t1, $t3, $t7
  7: $t6 := borrow_local($t7)
     # live vars: $t1, $t3, $t6
  8: $t12 := 1
     # live vars: $t1, $t3, $t6, $t12
  9: $t13 := unpack 0x1::test::Work($t3)
     # live vars: $t1, $t3, $t6, $t12, $t13
 10: $t11 := invoke($t12, $t13)
     # live vars: $t1, $t3, $t6, $t11
 11: $t10 := borrow_local($t11)
     # live vars: $t1, $t3, $t6, $t10
 12: $t5 := ==($t6, $t10)
     # live vars: $t1, $t3, $t5
 13: if ($t5) goto 14 else goto 17
     # live vars: $t1, $t3
 14: label L0
     # live vars: $t1
 15: $t0 := infer($t1)
     # live vars: $t0
 16: goto 19
     # live vars: $t1, $t3
 17: label L1
     # live vars: $t3
 18: $t0 := infer($t3)
     # live vars: $t0
 19: label L2
     # live vars: $t0
 20: return $t0
}


[variant baseline]
fun test::__lambda__1__eq1($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
     # live vars: $t0
  0: $t2 := infer($t0)
     # live vars: $t2
  1: $t3 := 1
     # live vars: $t2, $t3
  2: $t1 := +($t2, $t3)
     # live vars: $t1
  3: return $t1
}


[variant baseline]
fun test::__lambda__2__eq1($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
     # live vars: $t0
  0: $t2 := infer($t0)
     # live vars: $t2
  1: $t3 := 2
     # live vars: $t2, $t3
  2: $t1 := +($t2, $t3)
     # live vars: $t1
  3: return $t1
}


[variant baseline]
fun test::__lambda__1__eq2($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
     # live vars: $t0
  0: $t2 := infer($t0)
     # live vars: $t2
  1: $t3 := 1
     # live vars: $t2, $t3
  2: $t1 := +($t2, $t3)
     # live vars: $t1
  3: return $t1
}


[variant baseline]
fun test::__lambda__2__eq2($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
     # live vars: $t0
  0: $t2 := infer($t0)
     # live vars: $t2
  1: $t3 := 2
     # live vars: $t2, $t3
  2: $t1 := +($t2, $t3)
     # live vars: $t1
  3: return $t1
}


[variant baseline]
fun test::__lambda__1__eq3($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
     # live vars: $t0
  0: $t2 := infer($t0)
     # live vars: $t2
  1: $t3 := 1
     # live vars: $t2, $t3
  2: $t1 := +($t2, $t3)
     # live vars: $t1
  3: return $t1
}


[variant baseline]
fun test::__lambda__2__eq3($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
     # live vars: $t0
  0: $t2 := infer($t0)
     # live vars: $t2
  1: $t3 := 2
     # live vars: $t2, $t3
  2: $t1 := +($t2, $t3)
     # live vars: $t1
  3: return $t1
}


[variant baseline]
fun test::__lambda__1__eq4($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
     # live vars: $t0
  0: $t2 := infer($t0)
     # live vars: $t2
  1: $t3 := 1
     # live vars: $t2, $t3
  2: $t1 := +($t2, $t3)
     # live vars: $t1
  3: return $t1
}


[variant baseline]
fun test::__lambda__2__eq4($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
     # live vars: $t0
  0: $t2 := infer($t0)
     # live vars: $t2
  1: $t3 := 2
     # live vars: $t2, $t3
  2: $t1 := +($t2, $t3)
     # live vars: $t1
  3: return $t1
}

============ after UnusedAssignmentChecker: ================

[variant baseline]
fun test::eq1(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop
     var $t5: bool
     var $t6: 0x1::test::Work
     # live vars:
  0: $t2 := closure#0 test::__lambda__1__eq1()
     # live vars: $t2
  1: $t1 := pack 0x1::test::Work($t2)
     # live vars: $t1
  2: $t4 := closure#0 test::__lambda__2__eq1()
     # live vars: $t1, $t4
  3: $t3 := pack 0x1::test::Work($t4)
     # live vars: $t1, $t3
  4: $t6 := infer($t1)
     # live vars: $t1, $t3, $t6
  5: $t5 := ==($t6, $t3)
     # live vars: $t1, $t3, $t5
  6: if ($t5) goto 7 else goto 10
     # live vars: $t1, $t3
  7: label L0
     # live vars: $t1
  8: $t0 := infer($t1)
     # live vars: $t0
  9: goto 12
     # live vars: $t1, $t3
 10: label L1
     # live vars: $t3
 11: $t0 := infer($t3)
     # live vars: $t0
 12: label L2
     # live vars: $t0
 13: return $t0
}


[variant baseline]
fun test::eq2(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop
     var $t5: bool
     var $t6: &0x1::test::Work
     var $t7: &0x1::test::Work
     # live vars:
  0: $t2 := closure#0 test::__lambda__1__eq2()
     # live vars: $t2
  1: $t1 := pack 0x1::test::Work($t2)
     # live vars: $t1
  2: $t4 := closure#0 test::__lambda__2__eq2()
     # live vars: $t1, $t4
  3: $t3 := pack 0x1::test::Work($t4)
     # live vars: $t1, $t3
  4: $t6 := borrow_local($t1)
     # live vars: $t1, $t3, $t6
  5: $t7 := borrow_local($t3)
     # live vars: $t1, $t3, $t6, $t7
  6: $t5 := ==($t6, $t7)
     # live vars: $t1, $t3, $t5
  7: if ($t5) goto 8 else goto 11
     # live vars: $t1, $t3
  8: label L0
     # live vars: $t1
  9: $t0 := infer($t1)
     # live vars: $t0
 10: goto 13
     # live vars: $t1, $t3
 11: label L1
     # live vars: $t3
 12: $t0 := infer($t3)
     # live vars: $t0
 13: label L2
     # live vars: $t0
 14: return $t0
}


[variant baseline]
fun test::eq3(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop
     var $t5: bool
     var $t6: u64
     var $t7: u64
     var $t8: |u64|u64 has copy + drop
     var $t9: u64
     var $t10: u64
     var $t11: |u64|u64 has copy + drop
     # live vars:
  0: $t2 := closure#0 test::__lambda__1__eq3()
     # live vars: $t2
  1: $t1 := pack 0x1::test::Work($t2)
     # live vars: $t1
  2: $t4 := closure#0 test::__lambda__2__eq3()
     # live vars: $t1, $t4
  3: $t3 := pack 0x1::test::Work($t4)
     # live vars: $t1, $t3
  4: $t7 := 2
     # live vars: $t1, $t3, $t7
  5: $t8 := unpack 0x1::test::Work($t1)
     # live vars: $t1, $t3, $t7, $t8
  6: $t6 := invoke($t7, $t8)
     # live vars: $t1, $t3, $t6
  7: $t10 := 1
     # live vars: $t1, $t3, $t6, $t10
  8: $t11 := unpack 0x1::test::Work($t3)
     # live vars: $t1, $t3, $t6, $t10, $t11
  9: $t9 := invoke($t10, $t11)
     # live vars: $t1, $t3, $t6, $t9
 10: $t5 := ==($t6, $t9)
     # live vars: $t1, $t3, $t5
 11: if ($t5) goto 12 else goto 15
     # live vars: $t1, $t3
 12: label L0
     # live vars: $t1
 13: $t0 := infer($t1)
     # live vars: $t0
 14: goto 17
     # live vars: $t1, $t3
 15: label L1
     # live vars: $t3
 16: $t0 := infer($t3)
     # live vars: $t0
 17: label L2
     # live vars: $t0
 18: return $t0
}


[variant baseline]
fun test::eq4(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop
     var $t5: bool
     var $t6: &u64
     var $t7: u64
     var $t8: u64
     var $t9: |u64|u64 has copy + drop
     var $t10: &u64
     var $t11: u64
     var $t12: u64
     var $t13: |u64|u64 has copy + drop
     # live vars:
  0: $t2 := closure#0 test::__lambda__1__eq4()
     # live vars: $t2
  1: $t1 := pack 0x1::test::Work($t2)
     # live vars: $t1
  2: $t4 := closure#0 test::__lambda__2__eq4()
     # live vars: $t1, $t4
  3: $t3 := pack 0x1::test::Work($t4)
     # live vars: $t1, $t3
  4: $t8 := 2
     # live vars: $t1, $t3, $t8
  5: $t9 := unpack 0x1::test::Work($t1)
     # live vars: $t1, $t3, $t8, $t9
  6: $t7 := invoke($t8, $t9)
     # live vars: $t1, $t3, $t7
  7: $t6 := borrow_local($t7)
     # live vars: $t1, $t3, $t6
  8: $t12 := 1
     # live vars: $t1, $t3, $t6, $t12
  9: $t13 := unpack 0x1::test::Work($t3)
     # live vars: $t1, $t3, $t6, $t12, $t13
 10: $t11 := invoke($t12, $t13)
     # live vars: $t1, $t3, $t6, $t11
 11: $t10 := borrow_local($t11)
     # live vars: $t1, $t3, $t6, $t10
 12: $t5 := ==($t6, $t10)
     # live vars: $t1, $t3, $t5
 13: if ($t5) goto 14 else goto 17
     # live vars: $t1, $t3
 14: label L0
     # live vars: $t1
 15: $t0 := infer($t1)
     # live vars: $t0
 16: goto 19
     # live vars: $t1, $t3
 17: label L1
     # live vars: $t3
 18: $t0 := infer($t3)
     # live vars: $t0
 19: label L2
     # live vars: $t0
 20: return $t0
}


[variant baseline]
fun test::__lambda__1__eq1($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
     # live vars: $t0
  0: $t2 := infer($t0)
     # live vars: $t2
  1: $t3 := 1
     # live vars: $t2, $t3
  2: $t1 := +($t2, $t3)
     # live vars: $t1
  3: return $t1
}


[variant baseline]
fun test::__lambda__2__eq1($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
     # live vars: $t0
  0: $t2 := infer($t0)
     # live vars: $t2
  1: $t3 := 2
     # live vars: $t2, $t3
  2: $t1 := +($t2, $t3)
     # live vars: $t1
  3: return $t1
}


[variant baseline]
fun test::__lambda__1__eq2($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
     # live vars: $t0
  0: $t2 := infer($t0)
     # live vars: $t2
  1: $t3 := 1
     # live vars: $t2, $t3
  2: $t1 := +($t2, $t3)
     # live vars: $t1
  3: return $t1
}


[variant baseline]
fun test::__lambda__2__eq2($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
     # live vars: $t0
  0: $t2 := infer($t0)
     # live vars: $t2
  1: $t3 := 2
     # live vars: $t2, $t3
  2: $t1 := +($t2, $t3)
     # live vars: $t1
  3: return $t1
}


[variant baseline]
fun test::__lambda__1__eq3($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
     # live vars: $t0
  0: $t2 := infer($t0)
     # live vars: $t2
  1: $t3 := 1
     # live vars: $t2, $t3
  2: $t1 := +($t2, $t3)
     # live vars: $t1
  3: return $t1
}


[variant baseline]
fun test::__lambda__2__eq3($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
     # live vars: $t0
  0: $t2 := infer($t0)
     # live vars: $t2
  1: $t3 := 2
     # live vars: $t2, $t3
  2: $t1 := +($t2, $t3)
     # live vars: $t1
  3: return $t1
}


[variant baseline]
fun test::__lambda__1__eq4($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
     # live vars: $t0
  0: $t2 := infer($t0)
     # live vars: $t2
  1: $t3 := 1
     # live vars: $t2, $t3
  2: $t1 := +($t2, $t3)
     # live vars: $t1
  3: return $t1
}


[variant baseline]
fun test::__lambda__2__eq4($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
     # live vars: $t0
  0: $t2 := infer($t0)
     # live vars: $t2
  1: $t3 := 2
     # live vars: $t2, $t3
  2: $t1 := +($t2, $t3)
     # live vars: $t1
  3: return $t1
}

============ after LiveVarAnalysisProcessor: ================

[variant baseline]
fun test::eq1(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop
     var $t5: bool
     var $t6: 0x1::test::Work
     # live vars:
  0: $t2 := closure#0 test::__lambda__1__eq1()
     # live vars: $t2
  1: $t1 := pack 0x1::test::Work($t2)
     # live vars: $t1
  2: $t4 := closure#0 test::__lambda__2__eq1()
     # live vars: $t1, $t4
  3: $t3 := pack 0x1::test::Work($t4)
     # live vars: $t1, $t3
  4: $t6 := infer($t1)
     # live vars: $t1, $t3, $t6
  5: $t5 := ==($t6, $t3)
     # live vars: $t1, $t3, $t5
  6: if ($t5) goto 7 else goto 10
     # live vars: $t1, $t3
  7: label L0
     # live vars: $t1
  8: $t0 := infer($t1)
     # live vars: $t0
  9: goto 12
     # live vars: $t1, $t3
 10: label L1
     # live vars: $t3
 11: $t0 := infer($t3)
     # live vars: $t0
 12: label L2
     # live vars: $t0
 13: return $t0
}


[variant baseline]
fun test::eq2(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop
     var $t5: bool
     var $t6: &0x1::test::Work
     var $t7: &0x1::test::Work
     # live vars:
  0: $t2 := closure#0 test::__lambda__1__eq2()
     # live vars: $t2
  1: $t1 := pack 0x1::test::Work($t2)
     # live vars: $t1
  2: $t4 := closure#0 test::__lambda__2__eq2()
     # live vars: $t1, $t4
  3: $t3 := pack 0x1::test::Work($t4)
     # live vars: $t1, $t3
  4: $t6 := borrow_local($t1)
     # live vars: $t1, $t3, $t6
  5: $t7 := borrow_local($t3)
     # live vars: $t1, $t3, $t6, $t7
  6: $t5 := ==($t6, $t7)
     # live vars: $t1, $t3, $t5
  7: if ($t5) goto 8 else goto 11
     # live vars: $t1, $t3
  8: label L0
     # live vars: $t1
  9: $t0 := infer($t1)
     # live vars: $t0
 10: goto 13
     # live vars: $t1, $t3
 11: label L1
     # live vars: $t3
 12: $t0 := infer($t3)
     # live vars: $t0
 13: label L2
     # live vars: $t0
 14: return $t0
}


[variant baseline]
fun test::eq3(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop
     var $t5: bool
     var $t6: u64
     var $t7: u64
     var $t8: |u64|u64 has copy + drop
     var $t9: u64
     var $t10: u64
     var $t11: |u64|u64 has copy + drop
     # live vars:
  0: $t2 := closure#0 test::__lambda__1__eq3()
     # live vars: $t2
  1: $t1 := pack 0x1::test::Work($t2)
     # live vars: $t1
  2: $t4 := closure#0 test::__lambda__2__eq3()
     # live vars: $t1, $t4
  3: $t3 := pack 0x1::test::Work($t4)
     # live vars: $t1, $t3
  4: $t7 := 2
     # live vars: $t1, $t3, $t7
  5: $t8 := unpack 0x1::test::Work($t1)
     # live vars: $t1, $t3, $t7, $t8
  6: $t6 := invoke($t7, $t8)
     # live vars: $t1, $t3, $t6
  7: $t10 := 1
     # live vars: $t1, $t3, $t6, $t10
  8: $t11 := unpack 0x1::test::Work($t3)
     # live vars: $t1, $t3, $t6, $t10, $t11
  9: $t9 := invoke($t10, $t11)
     # live vars: $t1, $t3, $t6, $t9
 10: $t5 := ==($t6, $t9)
     # live vars: $t1, $t3, $t5
 11: if ($t5) goto 12 else goto 15
     # live vars: $t1, $t3
 12: label L0
     # live vars: $t1
 13: $t0 := infer($t1)
     # live vars: $t0
 14: goto 17
     # live vars: $t1, $t3
 15: label L1
     # live vars: $t3
 16: $t0 := infer($t3)
     # live vars: $t0
 17: label L2
     # live vars: $t0
 18: return $t0
}


[variant baseline]
fun test::eq4(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop
     var $t5: bool
     var $t6: &u64
     var $t7: u64
     var $t8: u64
     var $t9: |u64|u64 has copy + drop
     var $t10: &u64
     var $t11: u64
     var $t12: u64
     var $t13: |u64|u64 has copy + drop
     # live vars:
  0: $t2 := closure#0 test::__lambda__1__eq4()
     # live vars: $t2
  1: $t1 := pack 0x1::test::Work($t2)
     # live vars: $t1
  2: $t4 := closure#0 test::__lambda__2__eq4()
     # live vars: $t1, $t4
  3: $t3 := pack 0x1::test::Work($t4)
     # live vars: $t1, $t3
  4: $t8 := 2
     # live vars: $t1, $t3, $t8
  5: $t9 := unpack 0x1::test::Work($t1)
     # live vars: $t1, $t3, $t8, $t9
  6: $t7 := invoke($t8, $t9)
     # live vars: $t1, $t3, $t7
  7: $t6 := borrow_local($t7)
     # live vars: $t1, $t3, $t6
  8: $t12 := 1
     # live vars: $t1, $t3, $t6, $t12
  9: $t13 := unpack 0x1::test::Work($t3)
     # live vars: $t1, $t3, $t6, $t12, $t13
 10: $t11 := invoke($t12, $t13)
     # live vars: $t1, $t3, $t6, $t11
 11: $t10 := borrow_local($t11)
     # live vars: $t1, $t3, $t6, $t10
 12: $t5 := ==($t6, $t10)
     # live vars: $t1, $t3, $t5
 13: if ($t5) goto 14 else goto 17
     # live vars: $t1, $t3
 14: label L0
     # live vars: $t1
 15: $t0 := infer($t1)
     # live vars: $t0
 16: goto 19
     # live vars: $t1, $t3
 17: label L1
     # live vars: $t3
 18: $t0 := infer($t3)
     # live vars: $t0
 19: label L2
     # live vars: $t0
 20: return $t0
}


[variant baseline]
fun test::__lambda__1__eq1($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
     # live vars: $t0
  0: $t2 := infer($t0)
     # live vars: $t2
  1: $t3 := 1
     # live vars: $t2, $t3
  2: $t1 := +($t2, $t3)
     # live vars: $t1
  3: return $t1
}


[variant baseline]
fun test::__lambda__2__eq1($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
     # live vars: $t0
  0: $t2 := infer($t0)
     # live vars: $t2
  1: $t3 := 2
     # live vars: $t2, $t3
  2: $t1 := +($t2, $t3)
     # live vars: $t1
  3: return $t1
}


[variant baseline]
fun test::__lambda__1__eq2($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
     # live vars: $t0
  0: $t2 := infer($t0)
     # live vars: $t2
  1: $t3 := 1
     # live vars: $t2, $t3
  2: $t1 := +($t2, $t3)
     # live vars: $t1
  3: return $t1
}


[variant baseline]
fun test::__lambda__2__eq2($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
     # live vars: $t0
  0: $t2 := infer($t0)
     # live vars: $t2
  1: $t3 := 2
     # live vars: $t2, $t3
  2: $t1 := +($t2, $t3)
     # live vars: $t1
  3: return $t1
}


[variant baseline]
fun test::__lambda__1__eq3($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
     # live vars: $t0
  0: $t2 := infer($t0)
     # live vars: $t2
  1: $t3 := 1
     # live vars: $t2, $t3
  2: $t1 := +($t2, $t3)
     # live vars: $t1
  3: return $t1
}


[variant baseline]
fun test::__lambda__2__eq3($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
     # live vars: $t0
  0: $t2 := infer($t0)
     # live vars: $t2
  1: $t3 := 2
     # live vars: $t2, $t3
  2: $t1 := +($t2, $t3)
     # live vars: $t1
  3: return $t1
}


[variant baseline]
fun test::__lambda__1__eq4($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
     # live vars: $t0
  0: $t2 := infer($t0)
     # live vars: $t2
  1: $t3 := 1
     # live vars: $t2, $t3
  2: $t1 := +($t2, $t3)
     # live vars: $t1
  3: return $t1
}


[variant baseline]
fun test::__lambda__2__eq4($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
     # live vars: $t0
  0: $t2 := infer($t0)
     # live vars: $t2
  1: $t3 := 2
     # live vars: $t2, $t3
  2: $t1 := +($t2, $t3)
     # live vars: $t1
  3: return $t1
}

============ after ReferenceSafetyProcessor: ================

[variant baseline]
fun test::eq1(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop
     var $t5: bool
     var $t6: 0x1::test::Work
     # live vars:
     # refs: []
     #
  0: $t2 := closure#0 test::__lambda__1__eq1()
     # live vars: $t2
     # refs: []
     #
  1: $t1 := pack 0x1::test::Work($t2)
     # live vars: $t1
     # refs: []
     #
  2: $t4 := closure#0 test::__lambda__2__eq1()
     # live vars: $t1, $t4
     # refs: []
     #
  3: $t3 := pack 0x1::test::Work($t4)
     # live vars: $t1, $t3
     # refs: []
     #
  4: $t6 := infer($t1)
     # live vars: $t1, $t3, $t6
     # refs: []
     #
  5: $t5 := ==($t6, $t3)
     # live vars: $t1, $t3, $t5
     # refs: []
     #
  6: if ($t5) goto 7 else goto 10
     # live vars: $t1, $t3
     # refs: []
     #
  7: label L0
     # live vars: $t1
     # refs: []
     #
  8: $t0 := infer($t1)
     # live vars: $t0
     # refs: []
     #
  9: goto 12
     # live vars: $t1, $t3
     # refs: []
     #
 10: label L1
     # live vars: $t3
     # refs: []
     #
 11: $t0 := infer($t3)
     # live vars: $t0
     # refs: []
     #
 12: label L2
     # live vars: $t0
     # refs: []
     #
 13: return $t0
}


[variant baseline]
fun test::eq2(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop
     var $t5: bool
     var $t6: &0x1::test::Work
     var $t7: &0x1::test::Work
     # live vars:
     # refs: []
     #
  0: $t2 := closure#0 test::__lambda__1__eq2()
     # live vars: $t2
     # refs: []
     #
  1: $t1 := pack 0x1::test::Work($t2)
     # live vars: $t1
     # refs: []
     #
  2: $t4 := closure#0 test::__lambda__2__eq2()
     # live vars: $t1, $t4
     # refs: []
     #
  3: $t3 := pack 0x1::test::Work($t4)
     # live vars: $t1, $t3
     # refs: []
     #
  4: $t6 := borrow_local($t1)
     # live vars: $t1, $t3, $t6
     # refs: [$t6 => #6]
     # #6
     #   <no edges>
     # #root
     #   => #6 via [local `work1`] at line 17
     #
  5: $t7 := borrow_local($t3)
     # live vars: $t1, $t3, $t6, $t7
     # refs: [$t6 => #6, $t7 => #7]
     # #6
     #   <no edges>
     # #7
     #   <no edges>
     # #root
     #   => #6 via [local `work1`] at line 17
     #   => #7 via [local `work2`] at line 17
     #
  6: $t5 := ==($t6, $t7)
     # live vars: $t1, $t3, $t5
     # refs: []
     #
  7: if ($t5) goto 8 else goto 11
     # live vars: $t1, $t3
     # refs: []
     #
  8: label L0
     # live vars: $t1
     # refs: []
     #
  9: $t0 := infer($t1)
     # live vars: $t0
     # refs: []
     #
 10: goto 13
     # live vars: $t1, $t3
     # refs: []
     #
 11: label L1
     # live vars: $t3
     # refs: []
     #
 12: $t0 := infer($t3)
     # live vars: $t0
     # refs: []
     #
 13: label L2
     # live vars: $t0
     # refs: []
     #
 14: return $t0
}


[variant baseline]
fun test::eq3(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop
     var $t5: bool
     var $t6: u64
     var $t7: u64
     var $t8: |u64|u64 has copy + drop
     var $t9: u64
     var $t10: u64
     var $t11: |u64|u64 has copy + drop
     # live vars:
     # refs: []
     #
  0: $t2 := closure#0 test::__lambda__1__eq3()
     # live vars: $t2
     # refs: []
     #
  1: $t1 := pack 0x1::test::Work($t2)
     # live vars: $t1
     # refs: []
     #
  2: $t4 := closure#0 test::__lambda__2__eq3()
     # live vars: $t1, $t4
     # refs: []
     #
  3: $t3 := pack 0x1::test::Work($t4)
     # live vars: $t1, $t3
     # refs: []
     #
  4: $t7 := 2
     # live vars: $t1, $t3, $t7
     # refs: []
     #
  5: $t8 := unpack 0x1::test::Work($t1)
     # live vars: $t1, $t3, $t7, $t8
     # refs: []
     #
  6: $t6 := invoke($t7, $t8)
     # live vars: $t1, $t3, $t6
     # refs: []
     #
  7: $t10 := 1
     # live vars: $t1, $t3, $t6, $t10
     # refs: []
     #
  8: $t11 := unpack 0x1::test::Work($t3)
     # live vars: $t1, $t3, $t6, $t10, $t11
     # refs: []
     #
  9: $t9 := invoke($t10, $t11)
     # live vars: $t1, $t3, $t6, $t9
     # refs: []
     #
 10: $t5 := ==($t6, $t9)
     # live vars: $t1, $t3, $t5
     # refs: []
     #
 11: if ($t5) goto 12 else goto 15
     # live vars: $t1, $t3
     # refs: []
     #
 12: label L0
     # live vars: $t1
     # refs: []
     #
 13: $t0 := infer($t1)
     # live vars: $t0
     # refs: []
     #
 14: goto 17
     # live vars: $t1, $t3
     # refs: []
     #
 15: label L1
     # live vars: $t3
     # refs: []
     #
 16: $t0 := infer($t3)
     # live vars: $t0
     # refs: []
     #
 17: label L2
     # live vars: $t0
     # refs: []
     #
 18: return $t0
}


[variant baseline]
fun test::eq4(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop
     var $t5: bool
     var $t6: &u64
     var $t7: u64
     var $t8: u64
     var $t9: |u64|u64 has copy + drop
     var $t10: &u64
     var $t11: u64
     var $t12: u64
     var $t13: |u64|u64 has copy + drop
     # live vars:
     # refs: []
     #
  0: $t2 := closure#0 test::__lambda__1__eq4()
     # live vars: $t2
     # refs: []
     #
  1: $t1 := pack 0x1::test::Work($t2)
     # live vars: $t1
     # refs: []
     #
  2: $t4 := closure#0 test::__lambda__2__eq4()
     # live vars: $t1, $t4
     # refs: []
     #
  3: $t3 := pack 0x1::test::Work($t4)
     # live vars: $t1, $t3
     # refs: []
     #
  4: $t8 := 2
     # live vars: $t1, $t3, $t8
     # refs: []
     #
  5: $t9 := unpack 0x1::test::Work($t1)
     # live vars: $t1, $t3, $t8, $t9
     # refs: []
     #
  6: $t7 := invoke($t8, $t9)
     # live vars: $t1, $t3, $t7
     # refs: []
     #
  7: $t6 := borrow_local($t7)
     # live vars: $t1, $t3, $t6
     # refs: [$t6 => #6]
     # #6
     #   <no edges>
     # #root
     #   => #6 via [value] at line 35
     #
  8: $t12 := 1
     # live vars: $t1, $t3, $t6, $t12
     # refs: [$t6 => #6]
     # #6
     #   <no edges>
     # #root
     #   => #6 via [value] at line 35
     #
  9: $t13 := unpack 0x1::test::Work($t3)
     # live vars: $t1, $t3, $t6, $t12, $t13
     # refs: [$t6 => #6]
     # #6
     #   <no edges>
     # #root
     #   => #6 via [value] at line 35
     #
 10: $t11 := invoke($t12, $t13)
     # live vars: $t1, $t3, $t6, $t11
     # refs: [$t6 => #6]
     # #6
     #   <no edges>
     # #root
     #   => #6 via [value] at line 35
     #
 11: $t10 := borrow_local($t11)
     # live vars: $t1, $t3, $t6, $t10
     # refs: [$t6 => #6, $t10 => #10]
     # #6
     #   <no edges>
     # #10
     #   <no edges>
     # #root
     #   => #6 via [value] at line 35
     #   => #10 via [value] at line 35
     #
 12: $t5 := ==($t6, $t10)
     # live vars: $t1, $t3, $t5
     # refs: []
     #
 13: if ($t5) goto 14 else goto 17
     # live vars: $t1, $t3
     # refs: []
     #
 14: label L0
     # live vars: $t1
     # refs: []
     #
 15: $t0 := infer($t1)
     # live vars: $t0
     # refs: []
     #
 16: goto 19
     # live vars: $t1, $t3
     # refs: []
     #
 17: label L1
     # live vars: $t3
     # refs: []
     #
 18: $t0 := infer($t3)
     # live vars: $t0
     # refs: []
     #
 19: label L2
     # live vars: $t0
     # refs: []
     #
 20: return $t0
}


[variant baseline]
fun test::__lambda__1__eq1($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
     # live vars: $t0
     # refs: []
     #
  0: $t2 := infer($t0)
     # live vars: $t2
     # refs: []
     #
  1: $t3 := 1
     # live vars: $t2, $t3
     # refs: []
     #
  2: $t1 := +($t2, $t3)
     # live vars: $t1
     # refs: []
     #
  3: return $t1
}


[variant baseline]
fun test::__lambda__2__eq1($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
     # live vars: $t0
     # refs: []
     #
  0: $t2 := infer($t0)
     # live vars: $t2
     # refs: []
     #
  1: $t3 := 2
     # live vars: $t2, $t3
     # refs: []
     #
  2: $t1 := +($t2, $t3)
     # live vars: $t1
     # refs: []
     #
  3: return $t1
}


[variant baseline]
fun test::__lambda__1__eq2($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
     # live vars: $t0
     # refs: []
     #
  0: $t2 := infer($t0)
     # live vars: $t2
     # refs: []
     #
  1: $t3 := 1
     # live vars: $t2, $t3
     # refs: []
     #
  2: $t1 := +($t2, $t3)
     # live vars: $t1
     # refs: []
     #
  3: return $t1
}


[variant baseline]
fun test::__lambda__2__eq2($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
     # live vars: $t0
     # refs: []
     #
  0: $t2 := infer($t0)
     # live vars: $t2
     # refs: []
     #
  1: $t3 := 2
     # live vars: $t2, $t3
     # refs: []
     #
  2: $t1 := +($t2, $t3)
     # live vars: $t1
     # refs: []
     #
  3: return $t1
}


[variant baseline]
fun test::__lambda__1__eq3($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
     # live vars: $t0
     # refs: []
     #
  0: $t2 := infer($t0)
     # live vars: $t2
     # refs: []
     #
  1: $t3 := 1
     # live vars: $t2, $t3
     # refs: []
     #
  2: $t1 := +($t2, $t3)
     # live vars: $t1
     # refs: []
     #
  3: return $t1
}


[variant baseline]
fun test::__lambda__2__eq3($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
     # live vars: $t0
     # refs: []
     #
  0: $t2 := infer($t0)
     # live vars: $t2
     # refs: []
     #
  1: $t3 := 2
     # live vars: $t2, $t3
     # refs: []
     #
  2: $t1 := +($t2, $t3)
     # live vars: $t1
     # refs: []
     #
  3: return $t1
}


[variant baseline]
fun test::__lambda__1__eq4($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
     # live vars: $t0
     # refs: []
     #
  0: $t2 := infer($t0)
     # live vars: $t2
     # refs: []
     #
  1: $t3 := 1
     # live vars: $t2, $t3
     # refs: []
     #
  2: $t1 := +($t2, $t3)
     # live vars: $t1
     # refs: []
     #
  3: return $t1
}


[variant baseline]
fun test::__lambda__2__eq4($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
     # live vars: $t0
     # refs: []
     #
  0: $t2 := infer($t0)
     # live vars: $t2
     # refs: []
     #
  1: $t3 := 2
     # live vars: $t2, $t3
     # refs: []
     #
  2: $t1 := +($t2, $t3)
     # live vars: $t1
     # refs: []
     #
  3: return $t1
}

============ after AbortAnalysisProcessor: ================

[variant baseline]
fun test::eq1(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop
     var $t5: bool
     var $t6: 0x1::test::Work
     # abort state: {returns}
     # live vars:
     # refs: []
     #
  0: $t2 := closure#0 test::__lambda__1__eq1()
     # abort state: {returns}
     # live vars: $t2
     # refs: []
     #
  1: $t1 := pack 0x1::test::Work($t2)
     # abort state: {returns}
     # live vars: $t1
     # refs: []
     #
  2: $t4 := closure#0 test::__lambda__2__eq1()
     # abort state: {returns}
     # live vars: $t1, $t4
     # refs: []
     #
  3: $t3 := pack 0x1::test::Work($t4)
     # abort state: {returns}
     # live vars: $t1, $t3
     # refs: []
     #
  4: $t6 := infer($t1)
     # abort state: {returns}
     # live vars: $t1, $t3, $t6
     # refs: []
     #
  5: $t5 := ==($t6, $t3)
     # abort state: {returns}
     # live vars: $t1, $t3, $t5
     # refs: []
     #
  6: if ($t5) goto 7 else goto 10
     # abort state: {returns}
     # live vars: $t1, $t3
     # refs: []
     #
  7: label L0
     # abort state: {returns}
     # live vars: $t1
     # refs: []
     #
  8: $t0 := infer($t1)
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
  9: goto 12
     # abort state: {returns}
     # live vars: $t1, $t3
     # refs: []
     #
 10: label L1
     # abort state: {returns}
     # live vars: $t3
     # refs: []
     #
 11: $t0 := infer($t3)
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
 12: label L2
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
 13: return $t0
}


[variant baseline]
fun test::eq2(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop
     var $t5: bool
     var $t6: &0x1::test::Work
     var $t7: &0x1::test::Work
     # abort state: {returns}
     # live vars:
     # refs: []
     #
  0: $t2 := closure#0 test::__lambda__1__eq2()
     # abort state: {returns}
     # live vars: $t2
     # refs: []
     #
  1: $t1 := pack 0x1::test::Work($t2)
     # abort state: {returns}
     # live vars: $t1
     # refs: []
     #
  2: $t4 := closure#0 test::__lambda__2__eq2()
     # abort state: {returns}
     # live vars: $t1, $t4
     # refs: []
     #
  3: $t3 := pack 0x1::test::Work($t4)
     # abort state: {returns}
     # live vars: $t1, $t3
     # refs: []
     #
  4: $t6 := borrow_local($t1)
     # abort state: {returns}
     # live vars: $t1, $t3, $t6
     # refs: [$t6 => #6]
     # #6
     #   <no edges>
     # #root
     #   => #6 via [local `work1`] at line 17
     #
  5: $t7 := borrow_local($t3)
     # abort state: {returns}
     # live vars: $t1, $t3, $t6, $t7
     # refs: [$t6 => #6, $t7 => #7]
     # #6
     #   <no edges>
     # #7
     #   <no edges>
     # #root
     #   => #6 via [local `work1`] at line 17
     #   => #7 via [local `work2`] at line 17
     #
  6: $t5 := ==($t6, $t7)
     # abort state: {returns}
     # live vars: $t1, $t3, $t5
     # refs: []
     #
  7: if ($t5) goto 8 else goto 11
     # abort state: {returns}
     # live vars: $t1, $t3
     # refs: []
     #
  8: label L0
     # abort state: {returns}
     # live vars: $t1
     # refs: []
     #
  9: $t0 := infer($t1)
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
 10: goto 13
     # abort state: {returns}
     # live vars: $t1, $t3
     # refs: []
     #
 11: label L1
     # abort state: {returns}
     # live vars: $t3
     # refs: []
     #
 12: $t0 := infer($t3)
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
 13: label L2
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
 14: return $t0
}


[variant baseline]
fun test::eq3(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop
     var $t5: bool
     var $t6: u64
     var $t7: u64
     var $t8: |u64|u64 has copy + drop
     var $t9: u64
     var $t10: u64
     var $t11: |u64|u64 has copy + drop
     # abort state: {returns,aborts}
     # live vars:
     # refs: []
     #
  0: $t2 := closure#0 test::__lambda__1__eq3()
     # abort state: {returns,aborts}
     # live vars: $t2
     # refs: []
     #
  1: $t1 := pack 0x1::test::Work($t2)
     # abort state: {returns,aborts}
     # live vars: $t1
     # refs: []
     #
  2: $t4 := closure#0 test::__lambda__2__eq3()
     # abort state: {returns,aborts}
     # live vars: $t1, $t4
     # refs: []
     #
  3: $t3 := pack 0x1::test::Work($t4)
     # abort state: {returns,aborts}
     # live vars: $t1, $t3
     # refs: []
     #
  4: $t7 := 2
     # abort state: {returns,aborts}
     # live vars: $t1, $t3, $t7
     # refs: []
     #
  5: $t8 := unpack 0x1::test::Work($t1)
     # abort state: {returns,aborts}
     # live vars: $t1, $t3, $t7, $t8
     # refs: []
     #
  6: $t6 := invoke($t7, $t8)
     # abort state: {returns,aborts}
     # live vars: $t1, $t3, $t6
     # refs: []
     #
  7: $t10 := 1
     # abort state: {returns,aborts}
     # live vars: $t1, $t3, $t6, $t10
     # refs: []
     #
  8: $t11 := unpack 0x1::test::Work($t3)
     # abort state: {returns,aborts}
     # live vars: $t1, $t3, $t6, $t10, $t11
     # refs: []
     #
  9: $t9 := invoke($t10, $t11)
     # abort state: {returns}
     # live vars: $t1, $t3, $t6, $t9
     # refs: []
     #
 10: $t5 := ==($t6, $t9)
     # abort state: {returns}
     # live vars: $t1, $t3, $t5
     # refs: []
     #
 11: if ($t5) goto 12 else goto 15
     # abort state: {returns}
     # live vars: $t1, $t3
     # refs: []
     #
 12: label L0
     # abort state: {returns}
     # live vars: $t1
     # refs: []
     #
 13: $t0 := infer($t1)
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
 14: goto 17
     # abort state: {returns}
     # live vars: $t1, $t3
     # refs: []
     #
 15: label L1
     # abort state: {returns}
     # live vars: $t3
     # refs: []
     #
 16: $t0 := infer($t3)
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
 17: label L2
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
 18: return $t0
}


[variant baseline]
fun test::eq4(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop
     var $t5: bool
     var $t6: &u64
     var $t7: u64
     var $t8: u64
     var $t9: |u64|u64 has copy + drop
     var $t10: &u64
     var $t11: u64
     var $t12: u64
     var $t13: |u64|u64 has copy + drop
     # abort state: {returns,aborts}
     # live vars:
     # refs: []
     #
  0: $t2 := closure#0 test::__lambda__1__eq4()
     # abort state: {returns,aborts}
     # live vars: $t2
     # refs: []
     #
  1: $t1 := pack 0x1::test::Work($t2)
     # abort state: {returns,aborts}
     # live vars: $t1
     # refs: []
     #
  2: $t4 := closure#0 test::__lambda__2__eq4()
     # abort state: {returns,aborts}
     # live vars: $t1, $t4
     # refs: []
     #
  3: $t3 := pack 0x1::test::Work($t4)
     # abort state: {returns,aborts}
     # live vars: $t1, $t3
     # refs: []
     #
  4: $t8 := 2
     # abort state: {returns,aborts}
     # live vars: $t1, $t3, $t8
     # refs: []
     #
  5: $t9 := unpack 0x1::test::Work($t1)
     # abort state: {returns,aborts}
     # live vars: $t1, $t3, $t8, $t9
     # refs: []
     #
  6: $t7 := invoke($t8, $t9)
     # abort state: {returns,aborts}
     # live vars: $t1, $t3, $t7
     # refs: []
     #
  7: $t6 := borrow_local($t7)
     # abort state: {returns,aborts}
     # live vars: $t1, $t3, $t6
     # refs: [$t6 => #6]
     # #6
     #   <no edges>
     # #root
     #   => #6 via [value] at line 35
     #
  8: $t12 := 1
     # abort state: {returns,aborts}
     # live vars: $t1, $t3, $t6, $t12
     # refs: [$t6 => #6]
     # #6
     #   <no edges>
     # #root
     #   => #6 via [value] at line 35
     #
  9: $t13 := unpack 0x1::test::Work($t3)
     # abort state: {returns,aborts}
     # live vars: $t1, $t3, $t6, $t12, $t13
     # refs: [$t6 => #6]
     # #6
     #   <no edges>
     # #root
     #   => #6 via [value] at line 35
     #
 10: $t11 := invoke($t12, $t13)
     # abort state: {returns}
     # live vars: $t1, $t3, $t6, $t11
     # refs: [$t6 => #6]
     # #6
     #   <no edges>
     # #root
     #   => #6 via [value] at line 35
     #
 11: $t10 := borrow_local($t11)
     # abort state: {returns}
     # live vars: $t1, $t3, $t6, $t10
     # refs: [$t6 => #6, $t10 => #10]
     # #6
     #   <no edges>
     # #10
     #   <no edges>
     # #root
     #   => #6 via [value] at line 35
     #   => #10 via [value] at line 35
     #
 12: $t5 := ==($t6, $t10)
     # abort state: {returns}
     # live vars: $t1, $t3, $t5
     # refs: []
     #
 13: if ($t5) goto 14 else goto 17
     # abort state: {returns}
     # live vars: $t1, $t3
     # refs: []
     #
 14: label L0
     # abort state: {returns}
     # live vars: $t1
     # refs: []
     #
 15: $t0 := infer($t1)
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
 16: goto 19
     # abort state: {returns}
     # live vars: $t1, $t3
     # refs: []
     #
 17: label L1
     # abort state: {returns}
     # live vars: $t3
     # refs: []
     #
 18: $t0 := infer($t3)
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
 19: label L2
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
 20: return $t0
}


[variant baseline]
fun test::__lambda__1__eq1($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
     # abort state: {returns,aborts}
     # live vars: $t0
     # refs: []
     #
  0: $t2 := infer($t0)
     # abort state: {returns,aborts}
     # live vars: $t2
     # refs: []
     #
  1: $t3 := 1
     # abort state: {returns,aborts}
     # live vars: $t2, $t3
     # refs: []
     #
  2: $t1 := +($t2, $t3)
     # abort state: {returns}
     # live vars: $t1
     # refs: []
     #
  3: return $t1
}


[variant baseline]
fun test::__lambda__2__eq1($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
     # abort state: {returns,aborts}
     # live vars: $t0
     # refs: []
     #
  0: $t2 := infer($t0)
     # abort state: {returns,aborts}
     # live vars: $t2
     # refs: []
     #
  1: $t3 := 2
     # abort state: {returns,aborts}
     # live vars: $t2, $t3
     # refs: []
     #
  2: $t1 := +($t2, $t3)
     # abort state: {returns}
     # live vars: $t1
     # refs: []
     #
  3: return $t1
}


[variant baseline]
fun test::__lambda__1__eq2($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
     # abort state: {returns,aborts}
     # live vars: $t0
     # refs: []
     #
  0: $t2 := infer($t0)
     # abort state: {returns,aborts}
     # live vars: $t2
     # refs: []
     #
  1: $t3 := 1
     # abort state: {returns,aborts}
     # live vars: $t2, $t3
     # refs: []
     #
  2: $t1 := +($t2, $t3)
     # abort state: {returns}
     # live vars: $t1
     # refs: []
     #
  3: return $t1
}


[variant baseline]
fun test::__lambda__2__eq2($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
     # abort state: {returns,aborts}
     # live vars: $t0
     # refs: []
     #
  0: $t2 := infer($t0)
     # abort state: {returns,aborts}
     # live vars: $t2
     # refs: []
     #
  1: $t3 := 2
     # abort state: {returns,aborts}
     # live vars: $t2, $t3
     # refs: []
     #
  2: $t1 := +($t2, $t3)
     # abort state: {returns}
     # live vars: $t1
     # refs: []
     #
  3: return $t1
}


[variant baseline]
fun test::__lambda__1__eq3($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
     # abort state: {returns,aborts}
     # live vars: $t0
     # refs: []
     #
  0: $t2 := infer($t0)
     # abort state: {returns,aborts}
     # live vars: $t2
     # refs: []
     #
  1: $t3 := 1
     # abort state: {returns,aborts}
     # live vars: $t2, $t3
     # refs: []
     #
  2: $t1 := +($t2, $t3)
     # abort state: {returns}
     # live vars: $t1
     # refs: []
     #
  3: return $t1
}


[variant baseline]
fun test::__lambda__2__eq3($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
     # abort state: {returns,aborts}
     # live vars: $t0
     # refs: []
     #
  0: $t2 := infer($t0)
     # abort state: {returns,aborts}
     # live vars: $t2
     # refs: []
     #
  1: $t3 := 2
     # abort state: {returns,aborts}
     # live vars: $t2, $t3
     # refs: []
     #
  2: $t1 := +($t2, $t3)
     # abort state: {returns}
     # live vars: $t1
     # refs: []
     #
  3: return $t1
}


[variant baseline]
fun test::__lambda__1__eq4($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
     # abort state: {returns,aborts}
     # live vars: $t0
     # refs: []
     #
  0: $t2 := infer($t0)
     # abort state: {returns,aborts}
     # live vars: $t2
     # refs: []
     #
  1: $t3 := 1
     # abort state: {returns,aborts}
     # live vars: $t2, $t3
     # refs: []
     #
  2: $t1 := +($t2, $t3)
     # abort state: {returns}
     # live vars: $t1
     # refs: []
     #
  3: return $t1
}


[variant baseline]
fun test::__lambda__2__eq4($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
     # abort state: {returns,aborts}
     # live vars: $t0
     # refs: []
     #
  0: $t2 := infer($t0)
     # abort state: {returns,aborts}
     # live vars: $t2
     # refs: []
     #
  1: $t3 := 2
     # abort state: {returns,aborts}
     # live vars: $t2, $t3
     # refs: []
     #
  2: $t1 := +($t2, $t3)
     # abort state: {returns}
     # live vars: $t1
     # refs: []
     #
  3: return $t1
}

============ after AbilityProcessor: ================

[variant baseline]
fun test::eq1(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop
     var $t5: bool
     var $t6: 0x1::test::Work
  0: $t2 := closure#0 test::__lambda__1__eq1()
  1: $t1 := pack 0x1::test::Work($t2)
  2: $t4 := closure#0 test::__lambda__2__eq1()
  3: $t3 := pack 0x1::test::Work($t4)
  4: $t6 := copy($t1)
  5: $t5 := ==($t6, $t3)
  6: if ($t5) goto 7 else goto 10
  7: label L0
  8: $t0 := move($t1)
  9: goto 12
 10: label L1
 11: $t0 := move($t3)
 12: label L2
 13: return $t0
}


[variant baseline]
fun test::eq2(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop
     var $t5: bool
     var $t6: &0x1::test::Work
     var $t7: &0x1::test::Work
  0: $t2 := closure#0 test::__lambda__1__eq2()
  1: $t1 := pack 0x1::test::Work($t2)
  2: $t4 := closure#0 test::__lambda__2__eq2()
  3: $t3 := pack 0x1::test::Work($t4)
  4: $t6 := borrow_local($t1)
  5: $t7 := borrow_local($t3)
  6: $t5 := ==($t6, $t7)
  7: if ($t5) goto 8 else goto 11
  8: label L0
  9: $t0 := move($t1)
 10: goto 13
 11: label L1
 12: $t0 := move($t3)
 13: label L2
 14: return $t0
}


[variant baseline]
fun test::eq3(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop
     var $t5: bool
     var $t6: u64
     var $t7: u64
     var $t8: |u64|u64 has copy + drop
     var $t9: u64
     var $t10: u64
     var $t11: |u64|u64 has copy + drop
  0: $t2 := closure#0 test::__lambda__1__eq3()
  1: $t1 := pack 0x1::test::Work($t2)
  2: $t4 := closure#0 test::__lambda__2__eq3()
  3: $t3 := pack 0x1::test::Work($t4)
  4: $t7 := 2
  5: $t8 := unpack 0x1::test::Work($t1)
  6: $t6 := invoke($t7, $t8)
  7: $t10 := 1
  8: $t11 := unpack 0x1::test::Work($t3)
  9: $t9 := invoke($t10, $t11)
 10: $t5 := ==($t6, $t9)
 11: if ($t5) goto 12 else goto 15
 12: label L0
 13: $t0 := move($t1)
 14: goto 17
 15: label L1
 16: $t0 := move($t3)
 17: label L2
 18: return $t0
}


[variant baseline]
fun test::eq4(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop
     var $t5: bool
     var $t6: &u64
     var $t7: u64
     var $t8: u64
     var $t9: |u64|u64 has copy + drop
     var $t10: &u64
     var $t11: u64
     var $t12: u64
     var $t13: |u64|u64 has copy + drop
  0: $t2 := closure#0 test::__lambda__1__eq4()
  1: $t1 := pack 0x1::test::Work($t2)
  2: $t4 := closure#0 test::__lambda__2__eq4()
  3: $t3 := pack 0x1::test::Work($t4)
  4: $t8 := 2
  5: $t9 := unpack 0x1::test::Work($t1)
  6: $t7 := invoke($t8, $t9)
  7: $t6 := borrow_local($t7)
  8: $t12 := 1
  9: $t13 := unpack 0x1::test::Work($t3)
 10: $t11 := invoke($t12, $t13)
 11: $t10 := borrow_local($t11)
 12: $t5 := ==($t6, $t10)
 13: if ($t5) goto 14 else goto 17
 14: label L0
 15: $t0 := move($t1)
 16: goto 19
 17: label L1
 18: $t0 := move($t3)
 19: label L2
 20: return $t0
}


[variant baseline]
fun test::__lambda__1__eq1($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
  0: $t2 := move($t0)
  1: $t3 := 1
  2: $t1 := +($t2, $t3)
  3: return $t1
}


[variant baseline]
fun test::__lambda__2__eq1($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
  0: $t2 := move($t0)
  1: $t3 := 2
  2: $t1 := +($t2, $t3)
  3: return $t1
}


[variant baseline]
fun test::__lambda__1__eq2($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
  0: $t2 := move($t0)
  1: $t3 := 1
  2: $t1 := +($t2, $t3)
  3: return $t1
}


[variant baseline]
fun test::__lambda__2__eq2($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
  0: $t2 := move($t0)
  1: $t3 := 2
  2: $t1 := +($t2, $t3)
  3: return $t1
}


[variant baseline]
fun test::__lambda__1__eq3($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
  0: $t2 := move($t0)
  1: $t3 := 1
  2: $t1 := +($t2, $t3)
  3: return $t1
}


[variant baseline]
fun test::__lambda__2__eq3($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
  0: $t2 := move($t0)
  1: $t3 := 2
  2: $t1 := +($t2, $t3)
  3: return $t1
}


[variant baseline]
fun test::__lambda__1__eq4($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
  0: $t2 := move($t0)
  1: $t3 := 1
  2: $t1 := +($t2, $t3)
  3: return $t1
}


[variant baseline]
fun test::__lambda__2__eq4($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
  0: $t2 := move($t0)
  1: $t3 := 2
  2: $t1 := +($t2, $t3)
  3: return $t1
}

// -- Model dump before env processor pipeline:
module 0x1::test {
    struct Work {
        0: |u64|u64 has copy + drop,
    }
    private fun eq1(): Work {
        {
          let work1: Work = pack test::Work(closure#0test::__lambda__1__eq1());
          {
            let work2: Work = pack test::Work(closure#0test::__lambda__2__eq1());
            if Eq<Work>(work1, work2) {
              work1
            } else {
              work2
            }
          }
        }
    }
    private fun eq2(): Work {
        {
          let work1: Work = pack test::Work(closure#0test::__lambda__1__eq2());
          {
            let work2: Work = pack test::Work(closure#0test::__lambda__2__eq2());
            if Eq<Work>(Borrow(Immutable)(work1), Borrow(Immutable)(work2)) {
              work1
            } else {
              work2
            }
          }
        }
    }
    private fun eq3(): Work {
        {
          let work1: Work = pack test::Work(closure#0test::__lambda__1__eq3());
          {
            let work2: Work = pack test::Work(closure#0test::__lambda__2__eq3());
            if Eq<u64>((work1)(2), (work2)(1)) {
              work1
            } else {
              work2
            }
          }
        }
    }
    private fun eq4(): Work {
        {
          let work1: Work = pack test::Work(closure#0test::__lambda__1__eq4());
          {
            let work2: Work = pack test::Work(closure#0test::__lambda__2__eq4());
            if Eq<u64>(Borrow(Immutable)((work1)(2)), Borrow(Immutable)((work2)(1))) {
              work1
            } else {
              work2
            }
          }
        }
    }
    private fun __lambda__1__eq1(x: u64): u64 {
        Add<u64>(x, 1)
    }
    private fun __lambda__2__eq1(x: u64): u64 {
        Add<u64>(x, 2)
    }
    private fun __lambda__1__eq2(x: u64): u64 {
        Add<u64>(x, 1)
    }
    private fun __lambda__2__eq2(x: u64): u64 {
        Add<u64>(x, 2)
    }
    private fun __lambda__1__eq3(x: u64): u64 {
        Add<u64>(x, 1)
    }
    private fun __lambda__2__eq3(x: u64): u64 {
        Add<u64>(x, 2)
    }
    private fun __lambda__1__eq4(x: u64): u64 {
        Add<u64>(x, 1)
    }
    private fun __lambda__2__eq4(x: u64): u64 {
        Add<u64>(x, 2)
    }
} // end 0x1::test


// -- Model dump after env processor simplifier:
module 0x1::test {
    struct Work {
        0: |u64|u64 has copy + drop,
    }
    private fun eq1(): Work {
        {
          let work1: Work = pack test::Work(closure#0test::__lambda__1__eq1());
          {
            let work2: Work = pack test::Work(closure#0test::__lambda__2__eq1());
            if Eq<Work>(work1, work2) {
              work1
            } else {
              work2
            }
          }
        }
    }
    private fun eq2(): Work {
        {
          let work1: Work = pack test::Work(closure#0test::__lambda__1__eq2());
          {
            let work2: Work = pack test::Work(closure#0test::__lambda__2__eq2());
            if Eq<Work>(Borrow(Immutable)(work1), Borrow(Immutable)(work2)) {
              work1
            } else {
              work2
            }
          }
        }
    }
    private fun eq3(): Work {
        {
          let work1: Work = pack test::Work(closure#0test::__lambda__1__eq3());
          {
            let work2: Work = pack test::Work(closure#0test::__lambda__2__eq3());
            if Eq<u64>((work1)(2), (work2)(1)) {
              work1
            } else {
              work2
            }
          }
        }
    }
    private fun eq4(): Work {
        {
          let work1: Work = pack test::Work(closure#0test::__lambda__1__eq4());
          {
            let work2: Work = pack test::Work(closure#0test::__lambda__2__eq4());
            if Eq<u64>(Borrow(Immutable)((work1)(2)), Borrow(Immutable)((work2)(1))) {
              work1
            } else {
              work2
            }
          }
        }
    }
    private fun __lambda__1__eq1(x: u64): u64 {
        Add<u64>(x, 1)
    }
    private fun __lambda__2__eq1(x: u64): u64 {
        Add<u64>(x, 2)
    }
    private fun __lambda__1__eq2(x: u64): u64 {
        Add<u64>(x, 1)
    }
    private fun __lambda__2__eq2(x: u64): u64 {
        Add<u64>(x, 2)
    }
    private fun __lambda__1__eq3(x: u64): u64 {
        Add<u64>(x, 1)
    }
    private fun __lambda__2__eq3(x: u64): u64 {
        Add<u64>(x, 2)
    }
    private fun __lambda__1__eq4(x: u64): u64 {
        Add<u64>(x, 1)
    }
    private fun __lambda__2__eq4(x: u64): u64 {
        Add<u64>(x, 2)
    }
} // end 0x1::test


// -- Model dump after env processor rewrite comparison operations:
module 0x1::test {
    struct Work {
        0: |u64|u64 has copy + drop,
    }
    private fun eq1(): Work {
        {
          let work1: Work = pack test::Work(closure#0test::__lambda__1__eq1());
          {
            let work2: Work = pack test::Work(closure#0test::__lambda__2__eq1());
            if Eq<Work>(Borrow(Immutable)(work1), Borrow(Immutable)(work2)) {
              work1
            } else {
              work2
            }
          }
        }
    }
    private fun eq2(): Work {
        {
          let work1: Work = pack test::Work(closure#0test::__lambda__1__eq2());
          {
            let work2: Work = pack test::Work(closure#0test::__lambda__2__eq2());
            if Eq<Work>(Borrow(Immutable)(work1), Borrow(Immutable)(work2)) {
              work1
            } else {
              work2
            }
          }
        }
    }
    private fun eq3(): Work {
        {
          let work1: Work = pack test::Work(closure#0test::__lambda__1__eq3());
          {
            let work2: Work = pack test::Work(closure#0test::__lambda__2__eq3());
            if Eq<u64>((work1)(2), (work2)(1)) {
              work1
            } else {
              work2
            }
          }
        }
    }
    private fun eq4(): Work {
        {
          let work1: Work = pack test::Work(closure#0test::__lambda__1__eq4());
          {
            let work2: Work = pack test::Work(closure#0test::__lambda__2__eq4());
            if Eq<u64>(Borrow(Immutable)((work1)(2)), Borrow(Immutable)((work2)(1))) {
              work1
            } else {
              work2
            }
          }
        }
    }
    private fun __lambda__1__eq1(x: u64): u64 {
        Add<u64>(x, 1)
    }
    private fun __lambda__2__eq1(x: u64): u64 {
        Add<u64>(x, 2)
    }
    private fun __lambda__1__eq2(x: u64): u64 {
        Add<u64>(x, 1)
    }
    private fun __lambda__2__eq2(x: u64): u64 {
        Add<u64>(x, 2)
    }
    private fun __lambda__1__eq3(x: u64): u64 {
        Add<u64>(x, 1)
    }
    private fun __lambda__2__eq3(x: u64): u64 {
        Add<u64>(x, 2)
    }
    private fun __lambda__1__eq4(x: u64): u64 {
        Add<u64>(x, 1)
    }
    private fun __lambda__2__eq4(x: u64): u64 {
        Add<u64>(x, 2)
    }
} // end 0x1::test


============ bytecode before second stackless bytecode pipeline ================

[variant baseline]
fun test::eq1(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop
     var $t5: bool
     var $t6: &0x1::test::Work
     var $t7: &0x1::test::Work
  0: $t2 := closure#0 test::__lambda__1__eq1()
  1: $t1 := pack 0x1::test::Work($t2)
  2: $t4 := closure#0 test::__lambda__2__eq1()
  3: $t3 := pack 0x1::test::Work($t4)
  4: $t6 := borrow_local($t1)
  5: $t7 := borrow_local($t3)
  6: $t5 := ==($t6, $t7)
  7: if ($t5) goto 8 else goto 11
  8: label L0
  9: $t0 := infer($t1)
 10: goto 13
 11: label L1
 12: $t0 := infer($t3)
 13: label L2
 14: return $t0
}


[variant baseline]
fun test::eq2(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop
     var $t5: bool
     var $t6: &0x1::test::Work
     var $t7: &0x1::test::Work
  0: $t2 := closure#0 test::__lambda__1__eq2()
  1: $t1 := pack 0x1::test::Work($t2)
  2: $t4 := closure#0 test::__lambda__2__eq2()
  3: $t3 := pack 0x1::test::Work($t4)
  4: $t6 := borrow_local($t1)
  5: $t7 := borrow_local($t3)
  6: $t5 := ==($t6, $t7)
  7: if ($t5) goto 8 else goto 11
  8: label L0
  9: $t0 := infer($t1)
 10: goto 13
 11: label L1
 12: $t0 := infer($t3)
 13: label L2
 14: return $t0
}


[variant baseline]
fun test::eq3(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop
     var $t5: bool
     var $t6: u64
     var $t7: u64
     var $t8: |u64|u64 has copy + drop
     var $t9: u64
     var $t10: u64
     var $t11: |u64|u64 has copy + drop
  0: $t2 := closure#0 test::__lambda__1__eq3()
  1: $t1 := pack 0x1::test::Work($t2)
  2: $t4 := closure#0 test::__lambda__2__eq3()
  3: $t3 := pack 0x1::test::Work($t4)
  4: $t7 := 2
  5: $t8 := unpack 0x1::test::Work($t1)
  6: $t6 := invoke($t7, $t8)
  7: $t10 := 1
  8: $t11 := unpack 0x1::test::Work($t3)
  9: $t9 := invoke($t10, $t11)
 10: $t5 := ==($t6, $t9)
 11: if ($t5) goto 12 else goto 15
 12: label L0
 13: $t0 := infer($t1)
 14: goto 17
 15: label L1
 16: $t0 := infer($t3)
 17: label L2
 18: return $t0
}


[variant baseline]
fun test::eq4(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop
     var $t5: bool
     var $t6: &u64
     var $t7: u64
     var $t8: u64
     var $t9: |u64|u64 has copy + drop
     var $t10: &u64
     var $t11: u64
     var $t12: u64
     var $t13: |u64|u64 has copy + drop
  0: $t2 := closure#0 test::__lambda__1__eq4()
  1: $t1 := pack 0x1::test::Work($t2)
  2: $t4 := closure#0 test::__lambda__2__eq4()
  3: $t3 := pack 0x1::test::Work($t4)
  4: $t8 := 2
  5: $t9 := unpack 0x1::test::Work($t1)
  6: $t7 := invoke($t8, $t9)
  7: $t6 := borrow_local($t7)
  8: $t12 := 1
  9: $t13 := unpack 0x1::test::Work($t3)
 10: $t11 := invoke($t12, $t13)
 11: $t10 := borrow_local($t11)
 12: $t5 := ==($t6, $t10)
 13: if ($t5) goto 14 else goto 17
 14: label L0
 15: $t0 := infer($t1)
 16: goto 19
 17: label L1
 18: $t0 := infer($t3)
 19: label L2
 20: return $t0
}


[variant baseline]
fun test::__lambda__1__eq1($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
  0: $t2 := infer($t0)
  1: $t3 := 1
  2: $t1 := +($t2, $t3)
  3: return $t1
}


[variant baseline]
fun test::__lambda__2__eq1($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
  0: $t2 := infer($t0)
  1: $t3 := 2
  2: $t1 := +($t2, $t3)
  3: return $t1
}


[variant baseline]
fun test::__lambda__1__eq2($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
  0: $t2 := infer($t0)
  1: $t3 := 1
  2: $t1 := +($t2, $t3)
  3: return $t1
}


[variant baseline]
fun test::__lambda__2__eq2($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
  0: $t2 := infer($t0)
  1: $t3 := 2
  2: $t1 := +($t2, $t3)
  3: return $t1
}


[variant baseline]
fun test::__lambda__1__eq3($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
  0: $t2 := infer($t0)
  1: $t3 := 1
  2: $t1 := +($t2, $t3)
  3: return $t1
}


[variant baseline]
fun test::__lambda__2__eq3($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
  0: $t2 := infer($t0)
  1: $t3 := 2
  2: $t1 := +($t2, $t3)
  3: return $t1
}


[variant baseline]
fun test::__lambda__1__eq4($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
  0: $t2 := infer($t0)
  1: $t3 := 1
  2: $t1 := +($t2, $t3)
  3: return $t1
}


[variant baseline]
fun test::__lambda__2__eq4($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
  0: $t2 := infer($t0)
  1: $t3 := 2
  2: $t1 := +($t2, $t3)
  3: return $t1
}

============ after SplitCriticalEdgesProcessor: ================

[variant baseline]
fun test::eq1(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop
     var $t5: bool
     var $t6: &0x1::test::Work
     var $t7: &0x1::test::Work
  0: $t2 := closure#0 test::__lambda__1__eq1()
  1: $t1 := pack 0x1::test::Work($t2)
  2: $t4 := closure#0 test::__lambda__2__eq1()
  3: $t3 := pack 0x1::test::Work($t4)
  4: $t6 := borrow_local($t1)
  5: $t7 := borrow_local($t3)
  6: $t5 := ==($t6, $t7)
  7: if ($t5) goto 8 else goto 11
  8: label L0
  9: $t0 := infer($t1)
 10: goto 13
 11: label L1
 12: $t0 := infer($t3)
 13: label L2
 14: return $t0
}


[variant baseline]
fun test::eq2(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop
     var $t5: bool
     var $t6: &0x1::test::Work
     var $t7: &0x1::test::Work
  0: $t2 := closure#0 test::__lambda__1__eq2()
  1: $t1 := pack 0x1::test::Work($t2)
  2: $t4 := closure#0 test::__lambda__2__eq2()
  3: $t3 := pack 0x1::test::Work($t4)
  4: $t6 := borrow_local($t1)
  5: $t7 := borrow_local($t3)
  6: $t5 := ==($t6, $t7)
  7: if ($t5) goto 8 else goto 11
  8: label L0
  9: $t0 := infer($t1)
 10: goto 13
 11: label L1
 12: $t0 := infer($t3)
 13: label L2
 14: return $t0
}


[variant baseline]
fun test::eq3(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop
     var $t5: bool
     var $t6: u64
     var $t7: u64
     var $t8: |u64|u64 has copy + drop
     var $t9: u64
     var $t10: u64
     var $t11: |u64|u64 has copy + drop
  0: $t2 := closure#0 test::__lambda__1__eq3()
  1: $t1 := pack 0x1::test::Work($t2)
  2: $t4 := closure#0 test::__lambda__2__eq3()
  3: $t3 := pack 0x1::test::Work($t4)
  4: $t7 := 2
  5: $t8 := unpack 0x1::test::Work($t1)
  6: $t6 := invoke($t7, $t8)
  7: $t10 := 1
  8: $t11 := unpack 0x1::test::Work($t3)
  9: $t9 := invoke($t10, $t11)
 10: $t5 := ==($t6, $t9)
 11: if ($t5) goto 12 else goto 15
 12: label L0
 13: $t0 := infer($t1)
 14: goto 17
 15: label L1
 16: $t0 := infer($t3)
 17: label L2
 18: return $t0
}


[variant baseline]
fun test::eq4(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop
     var $t5: bool
     var $t6: &u64
     var $t7: u64
     var $t8: u64
     var $t9: |u64|u64 has copy + drop
     var $t10: &u64
     var $t11: u64
     var $t12: u64
     var $t13: |u64|u64 has copy + drop
  0: $t2 := closure#0 test::__lambda__1__eq4()
  1: $t1 := pack 0x1::test::Work($t2)
  2: $t4 := closure#0 test::__lambda__2__eq4()
  3: $t3 := pack 0x1::test::Work($t4)
  4: $t8 := 2
  5: $t9 := unpack 0x1::test::Work($t1)
  6: $t7 := invoke($t8, $t9)
  7: $t6 := borrow_local($t7)
  8: $t12 := 1
  9: $t13 := unpack 0x1::test::Work($t3)
 10: $t11 := invoke($t12, $t13)
 11: $t10 := borrow_local($t11)
 12: $t5 := ==($t6, $t10)
 13: if ($t5) goto 14 else goto 17
 14: label L0
 15: $t0 := infer($t1)
 16: goto 19
 17: label L1
 18: $t0 := infer($t3)
 19: label L2
 20: return $t0
}


[variant baseline]
fun test::__lambda__1__eq1($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
  0: $t2 := infer($t0)
  1: $t3 := 1
  2: $t1 := +($t2, $t3)
  3: return $t1
}


[variant baseline]
fun test::__lambda__2__eq1($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
  0: $t2 := infer($t0)
  1: $t3 := 2
  2: $t1 := +($t2, $t3)
  3: return $t1
}


[variant baseline]
fun test::__lambda__1__eq2($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
  0: $t2 := infer($t0)
  1: $t3 := 1
  2: $t1 := +($t2, $t3)
  3: return $t1
}


[variant baseline]
fun test::__lambda__2__eq2($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
  0: $t2 := infer($t0)
  1: $t3 := 2
  2: $t1 := +($t2, $t3)
  3: return $t1
}


[variant baseline]
fun test::__lambda__1__eq3($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
  0: $t2 := infer($t0)
  1: $t3 := 1
  2: $t1 := +($t2, $t3)
  3: return $t1
}


[variant baseline]
fun test::__lambda__2__eq3($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
  0: $t2 := infer($t0)
  1: $t3 := 2
  2: $t1 := +($t2, $t3)
  3: return $t1
}


[variant baseline]
fun test::__lambda__1__eq4($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
  0: $t2 := infer($t0)
  1: $t3 := 1
  2: $t1 := +($t2, $t3)
  3: return $t1
}


[variant baseline]
fun test::__lambda__2__eq4($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
  0: $t2 := infer($t0)
  1: $t3 := 2
  2: $t1 := +($t2, $t3)
  3: return $t1
}

============ after LiveVarAnalysisProcessor: ================

[variant baseline]
fun test::eq1(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop
     var $t5: bool
     var $t6: &0x1::test::Work
     var $t7: &0x1::test::Work
     # live vars:
  0: $t2 := closure#0 test::__lambda__1__eq1()
     # live vars: $t2
  1: $t1 := pack 0x1::test::Work($t2)
     # live vars: $t1
  2: $t4 := closure#0 test::__lambda__2__eq1()
     # live vars: $t1, $t4
  3: $t3 := pack 0x1::test::Work($t4)
     # live vars: $t1, $t3
  4: $t6 := borrow_local($t1)
     # live vars: $t1, $t3, $t6
  5: $t7 := borrow_local($t3)
     # live vars: $t1, $t3, $t6, $t7
  6: $t5 := ==($t6, $t7)
     # live vars: $t1, $t3, $t5
  7: if ($t5) goto 8 else goto 11
     # live vars: $t1, $t3
  8: label L0
     # live vars: $t1
  9: $t0 := infer($t1)
     # live vars: $t0
 10: goto 13
     # live vars: $t1, $t3
 11: label L1
     # live vars: $t3
 12: $t0 := infer($t3)
     # live vars: $t0
 13: label L2
     # live vars: $t0
 14: return $t0
}


[variant baseline]
fun test::eq2(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop
     var $t5: bool
     var $t6: &0x1::test::Work
     var $t7: &0x1::test::Work
     # live vars:
  0: $t2 := closure#0 test::__lambda__1__eq2()
     # live vars: $t2
  1: $t1 := pack 0x1::test::Work($t2)
     # live vars: $t1
  2: $t4 := closure#0 test::__lambda__2__eq2()
     # live vars: $t1, $t4
  3: $t3 := pack 0x1::test::Work($t4)
     # live vars: $t1, $t3
  4: $t6 := borrow_local($t1)
     # live vars: $t1, $t3, $t6
  5: $t7 := borrow_local($t3)
     # live vars: $t1, $t3, $t6, $t7
  6: $t5 := ==($t6, $t7)
     # live vars: $t1, $t3, $t5
  7: if ($t5) goto 8 else goto 11
     # live vars: $t1, $t3
  8: label L0
     # live vars: $t1
  9: $t0 := infer($t1)
     # live vars: $t0
 10: goto 13
     # live vars: $t1, $t3
 11: label L1
     # live vars: $t3
 12: $t0 := infer($t3)
     # live vars: $t0
 13: label L2
     # live vars: $t0
 14: return $t0
}


[variant baseline]
fun test::eq3(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop
     var $t5: bool
     var $t6: u64
     var $t7: u64
     var $t8: |u64|u64 has copy + drop
     var $t9: u64
     var $t10: u64
     var $t11: |u64|u64 has copy + drop
     # live vars:
  0: $t2 := closure#0 test::__lambda__1__eq3()
     # live vars: $t2
  1: $t1 := pack 0x1::test::Work($t2)
     # live vars: $t1
  2: $t4 := closure#0 test::__lambda__2__eq3()
     # live vars: $t1, $t4
  3: $t3 := pack 0x1::test::Work($t4)
     # live vars: $t1, $t3
  4: $t7 := 2
     # live vars: $t1, $t3, $t7
  5: $t8 := unpack 0x1::test::Work($t1)
     # live vars: $t1, $t3, $t7, $t8
  6: $t6 := invoke($t7, $t8)
     # live vars: $t1, $t3, $t6
  7: $t10 := 1
     # live vars: $t1, $t3, $t6, $t10
  8: $t11 := unpack 0x1::test::Work($t3)
     # live vars: $t1, $t3, $t6, $t10, $t11
  9: $t9 := invoke($t10, $t11)
     # live vars: $t1, $t3, $t6, $t9
 10: $t5 := ==($t6, $t9)
     # live vars: $t1, $t3, $t5
 11: if ($t5) goto 12 else goto 15
     # live vars: $t1, $t3
 12: label L0
     # live vars: $t1
 13: $t0 := infer($t1)
     # live vars: $t0
 14: goto 17
     # live vars: $t1, $t3
 15: label L1
     # live vars: $t3
 16: $t0 := infer($t3)
     # live vars: $t0
 17: label L2
     # live vars: $t0
 18: return $t0
}


[variant baseline]
fun test::eq4(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop
     var $t5: bool
     var $t6: &u64
     var $t7: u64
     var $t8: u64
     var $t9: |u64|u64 has copy + drop
     var $t10: &u64
     var $t11: u64
     var $t12: u64
     var $t13: |u64|u64 has copy + drop
     # live vars:
  0: $t2 := closure#0 test::__lambda__1__eq4()
     # live vars: $t2
  1: $t1 := pack 0x1::test::Work($t2)
     # live vars: $t1
  2: $t4 := closure#0 test::__lambda__2__eq4()
     # live vars: $t1, $t4
  3: $t3 := pack 0x1::test::Work($t4)
     # live vars: $t1, $t3
  4: $t8 := 2
     # live vars: $t1, $t3, $t8
  5: $t9 := unpack 0x1::test::Work($t1)
     # live vars: $t1, $t3, $t8, $t9
  6: $t7 := invoke($t8, $t9)
     # live vars: $t1, $t3, $t7
  7: $t6 := borrow_local($t7)
     # live vars: $t1, $t3, $t6
  8: $t12 := 1
     # live vars: $t1, $t3, $t6, $t12
  9: $t13 := unpack 0x1::test::Work($t3)
     # live vars: $t1, $t3, $t6, $t12, $t13
 10: $t11 := invoke($t12, $t13)
     # live vars: $t1, $t3, $t6, $t11
 11: $t10 := borrow_local($t11)
     # live vars: $t1, $t3, $t6, $t10
 12: $t5 := ==($t6, $t10)
     # live vars: $t1, $t3, $t5
 13: if ($t5) goto 14 else goto 17
     # live vars: $t1, $t3
 14: label L0
     # live vars: $t1
 15: $t0 := infer($t1)
     # live vars: $t0
 16: goto 19
     # live vars: $t1, $t3
 17: label L1
     # live vars: $t3
 18: $t0 := infer($t3)
     # live vars: $t0
 19: label L2
     # live vars: $t0
 20: return $t0
}


[variant baseline]
fun test::__lambda__1__eq1($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
     # live vars: $t0
  0: $t2 := infer($t0)
     # live vars: $t2
  1: $t3 := 1
     # live vars: $t2, $t3
  2: $t1 := +($t2, $t3)
     # live vars: $t1
  3: return $t1
}


[variant baseline]
fun test::__lambda__2__eq1($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
     # live vars: $t0
  0: $t2 := infer($t0)
     # live vars: $t2
  1: $t3 := 2
     # live vars: $t2, $t3
  2: $t1 := +($t2, $t3)
     # live vars: $t1
  3: return $t1
}


[variant baseline]
fun test::__lambda__1__eq2($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
     # live vars: $t0
  0: $t2 := infer($t0)
     # live vars: $t2
  1: $t3 := 1
     # live vars: $t2, $t3
  2: $t1 := +($t2, $t3)
     # live vars: $t1
  3: return $t1
}


[variant baseline]
fun test::__lambda__2__eq2($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
     # live vars: $t0
  0: $t2 := infer($t0)
     # live vars: $t2
  1: $t3 := 2
     # live vars: $t2, $t3
  2: $t1 := +($t2, $t3)
     # live vars: $t1
  3: return $t1
}


[variant baseline]
fun test::__lambda__1__eq3($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
     # live vars: $t0
  0: $t2 := infer($t0)
     # live vars: $t2
  1: $t3 := 1
     # live vars: $t2, $t3
  2: $t1 := +($t2, $t3)
     # live vars: $t1
  3: return $t1
}


[variant baseline]
fun test::__lambda__2__eq3($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
     # live vars: $t0
  0: $t2 := infer($t0)
     # live vars: $t2
  1: $t3 := 2
     # live vars: $t2, $t3
  2: $t1 := +($t2, $t3)
     # live vars: $t1
  3: return $t1
}


[variant baseline]
fun test::__lambda__1__eq4($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
     # live vars: $t0
  0: $t2 := infer($t0)
     # live vars: $t2
  1: $t3 := 1
     # live vars: $t2, $t3
  2: $t1 := +($t2, $t3)
     # live vars: $t1
  3: return $t1
}


[variant baseline]
fun test::__lambda__2__eq4($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
     # live vars: $t0
  0: $t2 := infer($t0)
     # live vars: $t2
  1: $t3 := 2
     # live vars: $t2, $t3
  2: $t1 := +($t2, $t3)
     # live vars: $t1
  3: return $t1
}

============ after ReferenceSafetyProcessor: ================

[variant baseline]
fun test::eq1(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop
     var $t5: bool
     var $t6: &0x1::test::Work
     var $t7: &0x1::test::Work
     # live vars:
     # refs: []
     #
  0: $t2 := closure#0 test::__lambda__1__eq1()
     # live vars: $t2
     # refs: []
     #
  1: $t1 := pack 0x1::test::Work($t2)
     # live vars: $t1
     # refs: []
     #
  2: $t4 := closure#0 test::__lambda__2__eq1()
     # live vars: $t1, $t4
     # refs: []
     #
  3: $t3 := pack 0x1::test::Work($t4)
     # live vars: $t1, $t3
     # refs: []
     #
  4: $t6 := borrow_local($t1)
     # live vars: $t1, $t3, $t6
     # refs: [$t6 => #6]
     # #6
     #   <no edges>
     # #root
     #   => #6 via [local `work1`] at line 8
     #
  5: $t7 := borrow_local($t3)
     # live vars: $t1, $t3, $t6, $t7
     # refs: [$t6 => #6, $t7 => #7]
     # #6
     #   <no edges>
     # #7
     #   <no edges>
     # #root
     #   => #6 via [local `work1`] at line 8
     #   => #7 via [local `work2`] at line 8
     #
  6: $t5 := ==($t6, $t7)
     # live vars: $t1, $t3, $t5
     # refs: []
     #
  7: if ($t5) goto 8 else goto 11
     # live vars: $t1, $t3
     # refs: []
     #
  8: label L0
     # live vars: $t1
     # refs: []
     #
  9: $t0 := infer($t1)
     # live vars: $t0
     # refs: []
     #
 10: goto 13
     # live vars: $t1, $t3
     # refs: []
     #
 11: label L1
     # live vars: $t3
     # refs: []
     #
 12: $t0 := infer($t3)
     # live vars: $t0
     # refs: []
     #
 13: label L2
     # live vars: $t0
     # refs: []
     #
 14: return $t0
}


[variant baseline]
fun test::eq2(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop
     var $t5: bool
     var $t6: &0x1::test::Work
     var $t7: &0x1::test::Work
     # live vars:
     # refs: []
     #
  0: $t2 := closure#0 test::__lambda__1__eq2()
     # live vars: $t2
     # refs: []
     #
  1: $t1 := pack 0x1::test::Work($t2)
     # live vars: $t1
     # refs: []
     #
  2: $t4 := closure#0 test::__lambda__2__eq2()
     # live vars: $t1, $t4
     # refs: []
     #
  3: $t3 := pack 0x1::test::Work($t4)
     # live vars: $t1, $t3
     # refs: []
     #
  4: $t6 := borrow_local($t1)
     # live vars: $t1, $t3, $t6
     # refs: [$t6 => #6]
     # #6
     #   <no edges>
     # #root
     #   => #6 via [local `work1`] at line 17
     #
  5: $t7 := borrow_local($t3)
     # live vars: $t1, $t3, $t6, $t7
     # refs: [$t6 => #6, $t7 => #7]
     # #6
     #   <no edges>
     # #7
     #   <no edges>
     # #root
     #   => #6 via [local `work1`] at line 17
     #   => #7 via [local `work2`] at line 17
     #
  6: $t5 := ==($t6, $t7)
     # live vars: $t1, $t3, $t5
     # refs: []
     #
  7: if ($t5) goto 8 else goto 11
     # live vars: $t1, $t3
     # refs: []
     #
  8: label L0
     # live vars: $t1
     # refs: []
     #
  9: $t0 := infer($t1)
     # live vars: $t0
     # refs: []
     #
 10: goto 13
     # live vars: $t1, $t3
     # refs: []
     #
 11: label L1
     # live vars: $t3
     # refs: []
     #
 12: $t0 := infer($t3)
     # live vars: $t0
     # refs: []
     #
 13: label L2
     # live vars: $t0
     # refs: []
     #
 14: return $t0
}


[variant baseline]
fun test::eq3(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop
     var $t5: bool
     var $t6: u64
     var $t7: u64
     var $t8: |u64|u64 has copy + drop
     var $t9: u64
     var $t10: u64
     var $t11: |u64|u64 has copy + drop
     # live vars:
     # refs: []
     #
  0: $t2 := closure#0 test::__lambda__1__eq3()
     # live vars: $t2
     # refs: []
     #
  1: $t1 := pack 0x1::test::Work($t2)
     # live vars: $t1
     # refs: []
     #
  2: $t4 := closure#0 test::__lambda__2__eq3()
     # live vars: $t1, $t4
     # refs: []
     #
  3: $t3 := pack 0x1::test::Work($t4)
     # live vars: $t1, $t3
     # refs: []
     #
  4: $t7 := 2
     # live vars: $t1, $t3, $t7
     # refs: []
     #
  5: $t8 := unpack 0x1::test::Work($t1)
     # live vars: $t1, $t3, $t7, $t8
     # refs: []
     #
  6: $t6 := invoke($t7, $t8)
     # live vars: $t1, $t3, $t6
     # refs: []
     #
  7: $t10 := 1
     # live vars: $t1, $t3, $t6, $t10
     # refs: []
     #
  8: $t11 := unpack 0x1::test::Work($t3)
     # live vars: $t1, $t3, $t6, $t10, $t11
     # refs: []
     #
  9: $t9 := invoke($t10, $t11)
     # live vars: $t1, $t3, $t6, $t9
     # refs: []
     #
 10: $t5 := ==($t6, $t9)
     # live vars: $t1, $t3, $t5
     # refs: []
     #
 11: if ($t5) goto 12 else goto 15
     # live vars: $t1, $t3
     # refs: []
     #
 12: label L0
     # live vars: $t1
     # refs: []
     #
 13: $t0 := infer($t1)
     # live vars: $t0
     # refs: []
     #
 14: goto 17
     # live vars: $t1, $t3
     # refs: []
     #
 15: label L1
     # live vars: $t3
     # refs: []
     #
 16: $t0 := infer($t3)
     # live vars: $t0
     # refs: []
     #
 17: label L2
     # live vars: $t0
     # refs: []
     #
 18: return $t0
}


[variant baseline]
fun test::eq4(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop
     var $t5: bool
     var $t6: &u64
     var $t7: u64
     var $t8: u64
     var $t9: |u64|u64 has copy + drop
     var $t10: &u64
     var $t11: u64
     var $t12: u64
     var $t13: |u64|u64 has copy + drop
     # live vars:
     # refs: []
     #
  0: $t2 := closure#0 test::__lambda__1__eq4()
     # live vars: $t2
     # refs: []
     #
  1: $t1 := pack 0x1::test::Work($t2)
     # live vars: $t1
     # refs: []
     #
  2: $t4 := closure#0 test::__lambda__2__eq4()
     # live vars: $t1, $t4
     # refs: []
     #
  3: $t3 := pack 0x1::test::Work($t4)
     # live vars: $t1, $t3
     # refs: []
     #
  4: $t8 := 2
     # live vars: $t1, $t3, $t8
     # refs: []
     #
  5: $t9 := unpack 0x1::test::Work($t1)
     # live vars: $t1, $t3, $t8, $t9
     # refs: []
     #
  6: $t7 := invoke($t8, $t9)
     # live vars: $t1, $t3, $t7
     # refs: []
     #
  7: $t6 := borrow_local($t7)
     # live vars: $t1, $t3, $t6
     # refs: [$t6 => #6]
     # #6
     #   <no edges>
     # #root
     #   => #6 via [value] at line 35
     #
  8: $t12 := 1
     # live vars: $t1, $t3, $t6, $t12
     # refs: [$t6 => #6]
     # #6
     #   <no edges>
     # #root
     #   => #6 via [value] at line 35
     #
  9: $t13 := unpack 0x1::test::Work($t3)
     # live vars: $t1, $t3, $t6, $t12, $t13
     # refs: [$t6 => #6]
     # #6
     #   <no edges>
     # #root
     #   => #6 via [value] at line 35
     #
 10: $t11 := invoke($t12, $t13)
     # live vars: $t1, $t3, $t6, $t11
     # refs: [$t6 => #6]
     # #6
     #   <no edges>
     # #root
     #   => #6 via [value] at line 35
     #
 11: $t10 := borrow_local($t11)
     # live vars: $t1, $t3, $t6, $t10
     # refs: [$t6 => #6, $t10 => #10]
     # #6
     #   <no edges>
     # #10
     #   <no edges>
     # #root
     #   => #6 via [value] at line 35
     #   => #10 via [value] at line 35
     #
 12: $t5 := ==($t6, $t10)
     # live vars: $t1, $t3, $t5
     # refs: []
     #
 13: if ($t5) goto 14 else goto 17
     # live vars: $t1, $t3
     # refs: []
     #
 14: label L0
     # live vars: $t1
     # refs: []
     #
 15: $t0 := infer($t1)
     # live vars: $t0
     # refs: []
     #
 16: goto 19
     # live vars: $t1, $t3
     # refs: []
     #
 17: label L1
     # live vars: $t3
     # refs: []
     #
 18: $t0 := infer($t3)
     # live vars: $t0
     # refs: []
     #
 19: label L2
     # live vars: $t0
     # refs: []
     #
 20: return $t0
}


[variant baseline]
fun test::__lambda__1__eq1($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
     # live vars: $t0
     # refs: []
     #
  0: $t2 := infer($t0)
     # live vars: $t2
     # refs: []
     #
  1: $t3 := 1
     # live vars: $t2, $t3
     # refs: []
     #
  2: $t1 := +($t2, $t3)
     # live vars: $t1
     # refs: []
     #
  3: return $t1
}


[variant baseline]
fun test::__lambda__2__eq1($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
     # live vars: $t0
     # refs: []
     #
  0: $t2 := infer($t0)
     # live vars: $t2
     # refs: []
     #
  1: $t3 := 2
     # live vars: $t2, $t3
     # refs: []
     #
  2: $t1 := +($t2, $t3)
     # live vars: $t1
     # refs: []
     #
  3: return $t1
}


[variant baseline]
fun test::__lambda__1__eq2($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
     # live vars: $t0
     # refs: []
     #
  0: $t2 := infer($t0)
     # live vars: $t2
     # refs: []
     #
  1: $t3 := 1
     # live vars: $t2, $t3
     # refs: []
     #
  2: $t1 := +($t2, $t3)
     # live vars: $t1
     # refs: []
     #
  3: return $t1
}


[variant baseline]
fun test::__lambda__2__eq2($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
     # live vars: $t0
     # refs: []
     #
  0: $t2 := infer($t0)
     # live vars: $t2
     # refs: []
     #
  1: $t3 := 2
     # live vars: $t2, $t3
     # refs: []
     #
  2: $t1 := +($t2, $t3)
     # live vars: $t1
     # refs: []
     #
  3: return $t1
}


[variant baseline]
fun test::__lambda__1__eq3($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
     # live vars: $t0
     # refs: []
     #
  0: $t2 := infer($t0)
     # live vars: $t2
     # refs: []
     #
  1: $t3 := 1
     # live vars: $t2, $t3
     # refs: []
     #
  2: $t1 := +($t2, $t3)
     # live vars: $t1
     # refs: []
     #
  3: return $t1
}


[variant baseline]
fun test::__lambda__2__eq3($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
     # live vars: $t0
     # refs: []
     #
  0: $t2 := infer($t0)
     # live vars: $t2
     # refs: []
     #
  1: $t3 := 2
     # live vars: $t2, $t3
     # refs: []
     #
  2: $t1 := +($t2, $t3)
     # live vars: $t1
     # refs: []
     #
  3: return $t1
}


[variant baseline]
fun test::__lambda__1__eq4($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
     # live vars: $t0
     # refs: []
     #
  0: $t2 := infer($t0)
     # live vars: $t2
     # refs: []
     #
  1: $t3 := 1
     # live vars: $t2, $t3
     # refs: []
     #
  2: $t1 := +($t2, $t3)
     # live vars: $t1
     # refs: []
     #
  3: return $t1
}


[variant baseline]
fun test::__lambda__2__eq4($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
     # live vars: $t0
     # refs: []
     #
  0: $t2 := infer($t0)
     # live vars: $t2
     # refs: []
     #
  1: $t3 := 2
     # live vars: $t2, $t3
     # refs: []
     #
  2: $t1 := +($t2, $t3)
     # live vars: $t1
     # refs: []
     #
  3: return $t1
}

============ after AbortAnalysisProcessor: ================

[variant baseline]
fun test::eq1(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop
     var $t5: bool
     var $t6: &0x1::test::Work
     var $t7: &0x1::test::Work
     # abort state: {returns}
     # live vars:
     # refs: []
     #
  0: $t2 := closure#0 test::__lambda__1__eq1()
     # abort state: {returns}
     # live vars: $t2
     # refs: []
     #
  1: $t1 := pack 0x1::test::Work($t2)
     # abort state: {returns}
     # live vars: $t1
     # refs: []
     #
  2: $t4 := closure#0 test::__lambda__2__eq1()
     # abort state: {returns}
     # live vars: $t1, $t4
     # refs: []
     #
  3: $t3 := pack 0x1::test::Work($t4)
     # abort state: {returns}
     # live vars: $t1, $t3
     # refs: []
     #
  4: $t6 := borrow_local($t1)
     # abort state: {returns}
     # live vars: $t1, $t3, $t6
     # refs: [$t6 => #6]
     # #6
     #   <no edges>
     # #root
     #   => #6 via [local `work1`] at line 8
     #
  5: $t7 := borrow_local($t3)
     # abort state: {returns}
     # live vars: $t1, $t3, $t6, $t7
     # refs: [$t6 => #6, $t7 => #7]
     # #6
     #   <no edges>
     # #7
     #   <no edges>
     # #root
     #   => #6 via [local `work1`] at line 8
     #   => #7 via [local `work2`] at line 8
     #
  6: $t5 := ==($t6, $t7)
     # abort state: {returns}
     # live vars: $t1, $t3, $t5
     # refs: []
     #
  7: if ($t5) goto 8 else goto 11
     # abort state: {returns}
     # live vars: $t1, $t3
     # refs: []
     #
  8: label L0
     # abort state: {returns}
     # live vars: $t1
     # refs: []
     #
  9: $t0 := infer($t1)
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
 10: goto 13
     # abort state: {returns}
     # live vars: $t1, $t3
     # refs: []
     #
 11: label L1
     # abort state: {returns}
     # live vars: $t3
     # refs: []
     #
 12: $t0 := infer($t3)
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
 13: label L2
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
 14: return $t0
}


[variant baseline]
fun test::eq2(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop
     var $t5: bool
     var $t6: &0x1::test::Work
     var $t7: &0x1::test::Work
     # abort state: {returns}
     # live vars:
     # refs: []
     #
  0: $t2 := closure#0 test::__lambda__1__eq2()
     # abort state: {returns}
     # live vars: $t2
     # refs: []
     #
  1: $t1 := pack 0x1::test::Work($t2)
     # abort state: {returns}
     # live vars: $t1
     # refs: []
     #
  2: $t4 := closure#0 test::__lambda__2__eq2()
     # abort state: {returns}
     # live vars: $t1, $t4
     # refs: []
     #
  3: $t3 := pack 0x1::test::Work($t4)
     # abort state: {returns}
     # live vars: $t1, $t3
     # refs: []
     #
  4: $t6 := borrow_local($t1)
     # abort state: {returns}
     # live vars: $t1, $t3, $t6
     # refs: [$t6 => #6]
     # #6
     #   <no edges>
     # #root
     #   => #6 via [local `work1`] at line 17
     #
  5: $t7 := borrow_local($t3)
     # abort state: {returns}
     # live vars: $t1, $t3, $t6, $t7
     # refs: [$t6 => #6, $t7 => #7]
     # #6
     #   <no edges>
     # #7
     #   <no edges>
     # #root
     #   => #6 via [local `work1`] at line 17
     #   => #7 via [local `work2`] at line 17
     #
  6: $t5 := ==($t6, $t7)
     # abort state: {returns}
     # live vars: $t1, $t3, $t5
     # refs: []
     #
  7: if ($t5) goto 8 else goto 11
     # abort state: {returns}
     # live vars: $t1, $t3
     # refs: []
     #
  8: label L0
     # abort state: {returns}
     # live vars: $t1
     # refs: []
     #
  9: $t0 := infer($t1)
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
 10: goto 13
     # abort state: {returns}
     # live vars: $t1, $t3
     # refs: []
     #
 11: label L1
     # abort state: {returns}
     # live vars: $t3
     # refs: []
     #
 12: $t0 := infer($t3)
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
 13: label L2
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
 14: return $t0
}


[variant baseline]
fun test::eq3(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop
     var $t5: bool
     var $t6: u64
     var $t7: u64
     var $t8: |u64|u64 has copy + drop
     var $t9: u64
     var $t10: u64
     var $t11: |u64|u64 has copy + drop
     # abort state: {returns,aborts}
     # live vars:
     # refs: []
     #
  0: $t2 := closure#0 test::__lambda__1__eq3()
     # abort state: {returns,aborts}
     # live vars: $t2
     # refs: []
     #
  1: $t1 := pack 0x1::test::Work($t2)
     # abort state: {returns,aborts}
     # live vars: $t1
     # refs: []
     #
  2: $t4 := closure#0 test::__lambda__2__eq3()
     # abort state: {returns,aborts}
     # live vars: $t1, $t4
     # refs: []
     #
  3: $t3 := pack 0x1::test::Work($t4)
     # abort state: {returns,aborts}
     # live vars: $t1, $t3
     # refs: []
     #
  4: $t7 := 2
     # abort state: {returns,aborts}
     # live vars: $t1, $t3, $t7
     # refs: []
     #
  5: $t8 := unpack 0x1::test::Work($t1)
     # abort state: {returns,aborts}
     # live vars: $t1, $t3, $t7, $t8
     # refs: []
     #
  6: $t6 := invoke($t7, $t8)
     # abort state: {returns,aborts}
     # live vars: $t1, $t3, $t6
     # refs: []
     #
  7: $t10 := 1
     # abort state: {returns,aborts}
     # live vars: $t1, $t3, $t6, $t10
     # refs: []
     #
  8: $t11 := unpack 0x1::test::Work($t3)
     # abort state: {returns,aborts}
     # live vars: $t1, $t3, $t6, $t10, $t11
     # refs: []
     #
  9: $t9 := invoke($t10, $t11)
     # abort state: {returns}
     # live vars: $t1, $t3, $t6, $t9
     # refs: []
     #
 10: $t5 := ==($t6, $t9)
     # abort state: {returns}
     # live vars: $t1, $t3, $t5
     # refs: []
     #
 11: if ($t5) goto 12 else goto 15
     # abort state: {returns}
     # live vars: $t1, $t3
     # refs: []
     #
 12: label L0
     # abort state: {returns}
     # live vars: $t1
     # refs: []
     #
 13: $t0 := infer($t1)
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
 14: goto 17
     # abort state: {returns}
     # live vars: $t1, $t3
     # refs: []
     #
 15: label L1
     # abort state: {returns}
     # live vars: $t3
     # refs: []
     #
 16: $t0 := infer($t3)
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
 17: label L2
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
 18: return $t0
}


[variant baseline]
fun test::eq4(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop
     var $t5: bool
     var $t6: &u64
     var $t7: u64
     var $t8: u64
     var $t9: |u64|u64 has copy + drop
     var $t10: &u64
     var $t11: u64
     var $t12: u64
     var $t13: |u64|u64 has copy + drop
     # abort state: {returns,aborts}
     # live vars:
     # refs: []
     #
  0: $t2 := closure#0 test::__lambda__1__eq4()
     # abort state: {returns,aborts}
     # live vars: $t2
     # refs: []
     #
  1: $t1 := pack 0x1::test::Work($t2)
     # abort state: {returns,aborts}
     # live vars: $t1
     # refs: []
     #
  2: $t4 := closure#0 test::__lambda__2__eq4()
     # abort state: {returns,aborts}
     # live vars: $t1, $t4
     # refs: []
     #
  3: $t3 := pack 0x1::test::Work($t4)
     # abort state: {returns,aborts}
     # live vars: $t1, $t3
     # refs: []
     #
  4: $t8 := 2
     # abort state: {returns,aborts}
     # live vars: $t1, $t3, $t8
     # refs: []
     #
  5: $t9 := unpack 0x1::test::Work($t1)
     # abort state: {returns,aborts}
     # live vars: $t1, $t3, $t8, $t9
     # refs: []
     #
  6: $t7 := invoke($t8, $t9)
     # abort state: {returns,aborts}
     # live vars: $t1, $t3, $t7
     # refs: []
     #
  7: $t6 := borrow_local($t7)
     # abort state: {returns,aborts}
     # live vars: $t1, $t3, $t6
     # refs: [$t6 => #6]
     # #6
     #   <no edges>
     # #root
     #   => #6 via [value] at line 35
     #
  8: $t12 := 1
     # abort state: {returns,aborts}
     # live vars: $t1, $t3, $t6, $t12
     # refs: [$t6 => #6]
     # #6
     #   <no edges>
     # #root
     #   => #6 via [value] at line 35
     #
  9: $t13 := unpack 0x1::test::Work($t3)
     # abort state: {returns,aborts}
     # live vars: $t1, $t3, $t6, $t12, $t13
     # refs: [$t6 => #6]
     # #6
     #   <no edges>
     # #root
     #   => #6 via [value] at line 35
     #
 10: $t11 := invoke($t12, $t13)
     # abort state: {returns}
     # live vars: $t1, $t3, $t6, $t11
     # refs: [$t6 => #6]
     # #6
     #   <no edges>
     # #root
     #   => #6 via [value] at line 35
     #
 11: $t10 := borrow_local($t11)
     # abort state: {returns}
     # live vars: $t1, $t3, $t6, $t10
     # refs: [$t6 => #6, $t10 => #10]
     # #6
     #   <no edges>
     # #10
     #   <no edges>
     # #root
     #   => #6 via [value] at line 35
     #   => #10 via [value] at line 35
     #
 12: $t5 := ==($t6, $t10)
     # abort state: {returns}
     # live vars: $t1, $t3, $t5
     # refs: []
     #
 13: if ($t5) goto 14 else goto 17
     # abort state: {returns}
     # live vars: $t1, $t3
     # refs: []
     #
 14: label L0
     # abort state: {returns}
     # live vars: $t1
     # refs: []
     #
 15: $t0 := infer($t1)
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
 16: goto 19
     # abort state: {returns}
     # live vars: $t1, $t3
     # refs: []
     #
 17: label L1
     # abort state: {returns}
     # live vars: $t3
     # refs: []
     #
 18: $t0 := infer($t3)
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
 19: label L2
     # abort state: {returns}
     # live vars: $t0
     # refs: []
     #
 20: return $t0
}


[variant baseline]
fun test::__lambda__1__eq1($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
     # abort state: {returns,aborts}
     # live vars: $t0
     # refs: []
     #
  0: $t2 := infer($t0)
     # abort state: {returns,aborts}
     # live vars: $t2
     # refs: []
     #
  1: $t3 := 1
     # abort state: {returns,aborts}
     # live vars: $t2, $t3
     # refs: []
     #
  2: $t1 := +($t2, $t3)
     # abort state: {returns}
     # live vars: $t1
     # refs: []
     #
  3: return $t1
}


[variant baseline]
fun test::__lambda__2__eq1($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
     # abort state: {returns,aborts}
     # live vars: $t0
     # refs: []
     #
  0: $t2 := infer($t0)
     # abort state: {returns,aborts}
     # live vars: $t2
     # refs: []
     #
  1: $t3 := 2
     # abort state: {returns,aborts}
     # live vars: $t2, $t3
     # refs: []
     #
  2: $t1 := +($t2, $t3)
     # abort state: {returns}
     # live vars: $t1
     # refs: []
     #
  3: return $t1
}


[variant baseline]
fun test::__lambda__1__eq2($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
     # abort state: {returns,aborts}
     # live vars: $t0
     # refs: []
     #
  0: $t2 := infer($t0)
     # abort state: {returns,aborts}
     # live vars: $t2
     # refs: []
     #
  1: $t3 := 1
     # abort state: {returns,aborts}
     # live vars: $t2, $t3
     # refs: []
     #
  2: $t1 := +($t2, $t3)
     # abort state: {returns}
     # live vars: $t1
     # refs: []
     #
  3: return $t1
}


[variant baseline]
fun test::__lambda__2__eq2($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
     # abort state: {returns,aborts}
     # live vars: $t0
     # refs: []
     #
  0: $t2 := infer($t0)
     # abort state: {returns,aborts}
     # live vars: $t2
     # refs: []
     #
  1: $t3 := 2
     # abort state: {returns,aborts}
     # live vars: $t2, $t3
     # refs: []
     #
  2: $t1 := +($t2, $t3)
     # abort state: {returns}
     # live vars: $t1
     # refs: []
     #
  3: return $t1
}


[variant baseline]
fun test::__lambda__1__eq3($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
     # abort state: {returns,aborts}
     # live vars: $t0
     # refs: []
     #
  0: $t2 := infer($t0)
     # abort state: {returns,aborts}
     # live vars: $t2
     # refs: []
     #
  1: $t3 := 1
     # abort state: {returns,aborts}
     # live vars: $t2, $t3
     # refs: []
     #
  2: $t1 := +($t2, $t3)
     # abort state: {returns}
     # live vars: $t1
     # refs: []
     #
  3: return $t1
}


[variant baseline]
fun test::__lambda__2__eq3($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
     # abort state: {returns,aborts}
     # live vars: $t0
     # refs: []
     #
  0: $t2 := infer($t0)
     # abort state: {returns,aborts}
     # live vars: $t2
     # refs: []
     #
  1: $t3 := 2
     # abort state: {returns,aborts}
     # live vars: $t2, $t3
     # refs: []
     #
  2: $t1 := +($t2, $t3)
     # abort state: {returns}
     # live vars: $t1
     # refs: []
     #
  3: return $t1
}


[variant baseline]
fun test::__lambda__1__eq4($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
     # abort state: {returns,aborts}
     # live vars: $t0
     # refs: []
     #
  0: $t2 := infer($t0)
     # abort state: {returns,aborts}
     # live vars: $t2
     # refs: []
     #
  1: $t3 := 1
     # abort state: {returns,aborts}
     # live vars: $t2, $t3
     # refs: []
     #
  2: $t1 := +($t2, $t3)
     # abort state: {returns}
     # live vars: $t1
     # refs: []
     #
  3: return $t1
}


[variant baseline]
fun test::__lambda__2__eq4($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
     # abort state: {returns,aborts}
     # live vars: $t0
     # refs: []
     #
  0: $t2 := infer($t0)
     # abort state: {returns,aborts}
     # live vars: $t2
     # refs: []
     #
  1: $t3 := 2
     # abort state: {returns,aborts}
     # live vars: $t2, $t3
     # refs: []
     #
  2: $t1 := +($t2, $t3)
     # abort state: {returns}
     # live vars: $t1
     # refs: []
     #
  3: return $t1
}

============ after AbilityProcessor: ================

[variant baseline]
fun test::eq1(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop
     var $t5: bool
     var $t6: &0x1::test::Work
     var $t7: &0x1::test::Work
  0: $t2 := closure#0 test::__lambda__1__eq1()
  1: $t1 := pack 0x1::test::Work($t2)
  2: $t4 := closure#0 test::__lambda__2__eq1()
  3: $t3 := pack 0x1::test::Work($t4)
  4: $t6 := borrow_local($t1)
  5: $t7 := borrow_local($t3)
  6: $t5 := ==($t6, $t7)
  7: if ($t5) goto 8 else goto 11
  8: label L0
  9: $t0 := move($t1)
 10: goto 13
 11: label L1
 12: $t0 := move($t3)
 13: label L2
 14: return $t0
}


[variant baseline]
fun test::eq2(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop
     var $t5: bool
     var $t6: &0x1::test::Work
     var $t7: &0x1::test::Work
  0: $t2 := closure#0 test::__lambda__1__eq2()
  1: $t1 := pack 0x1::test::Work($t2)
  2: $t4 := closure#0 test::__lambda__2__eq2()
  3: $t3 := pack 0x1::test::Work($t4)
  4: $t6 := borrow_local($t1)
  5: $t7 := borrow_local($t3)
  6: $t5 := ==($t6, $t7)
  7: if ($t5) goto 8 else goto 11
  8: label L0
  9: $t0 := move($t1)
 10: goto 13
 11: label L1
 12: $t0 := move($t3)
 13: label L2
 14: return $t0
}


[variant baseline]
fun test::eq3(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop
     var $t5: bool
     var $t6: u64
     var $t7: u64
     var $t8: |u64|u64 has copy + drop
     var $t9: u64
     var $t10: u64
     var $t11: |u64|u64 has copy + drop
  0: $t2 := closure#0 test::__lambda__1__eq3()
  1: $t1 := pack 0x1::test::Work($t2)
  2: $t4 := closure#0 test::__lambda__2__eq3()
  3: $t3 := pack 0x1::test::Work($t4)
  4: $t7 := 2
  5: $t8 := unpack 0x1::test::Work($t1)
  6: $t6 := invoke($t7, $t8)
  7: $t10 := 1
  8: $t11 := unpack 0x1::test::Work($t3)
  9: $t9 := invoke($t10, $t11)
 10: $t5 := ==($t6, $t9)
 11: if ($t5) goto 12 else goto 15
 12: label L0
 13: $t0 := move($t1)
 14: goto 17
 15: label L1
 16: $t0 := move($t3)
 17: label L2
 18: return $t0
}


[variant baseline]
fun test::eq4(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop
     var $t5: bool
     var $t6: &u64
     var $t7: u64
     var $t8: u64
     var $t9: |u64|u64 has copy + drop
     var $t10: &u64
     var $t11: u64
     var $t12: u64
     var $t13: |u64|u64 has copy + drop
  0: $t2 := closure#0 test::__lambda__1__eq4()
  1: $t1 := pack 0x1::test::Work($t2)
  2: $t4 := closure#0 test::__lambda__2__eq4()
  3: $t3 := pack 0x1::test::Work($t4)
  4: $t8 := 2
  5: $t9 := unpack 0x1::test::Work($t1)
  6: $t7 := invoke($t8, $t9)
  7: $t6 := borrow_local($t7)
  8: $t12 := 1
  9: $t13 := unpack 0x1::test::Work($t3)
 10: $t11 := invoke($t12, $t13)
 11: $t10 := borrow_local($t11)
 12: $t5 := ==($t6, $t10)
 13: if ($t5) goto 14 else goto 17
 14: label L0
 15: $t0 := move($t1)
 16: goto 19
 17: label L1
 18: $t0 := move($t3)
 19: label L2
 20: return $t0
}


[variant baseline]
fun test::__lambda__1__eq1($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
  0: $t2 := move($t0)
  1: $t3 := 1
  2: $t1 := +($t2, $t3)
  3: return $t1
}


[variant baseline]
fun test::__lambda__2__eq1($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
  0: $t2 := move($t0)
  1: $t3 := 2
  2: $t1 := +($t2, $t3)
  3: return $t1
}


[variant baseline]
fun test::__lambda__1__eq2($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
  0: $t2 := move($t0)
  1: $t3 := 1
  2: $t1 := +($t2, $t3)
  3: return $t1
}


[variant baseline]
fun test::__lambda__2__eq2($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
  0: $t2 := move($t0)
  1: $t3 := 2
  2: $t1 := +($t2, $t3)
  3: return $t1
}


[variant baseline]
fun test::__lambda__1__eq3($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
  0: $t2 := move($t0)
  1: $t3 := 1
  2: $t1 := +($t2, $t3)
  3: return $t1
}


[variant baseline]
fun test::__lambda__2__eq3($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
  0: $t2 := move($t0)
  1: $t3 := 2
  2: $t1 := +($t2, $t3)
  3: return $t1
}


[variant baseline]
fun test::__lambda__1__eq4($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
  0: $t2 := move($t0)
  1: $t3 := 1
  2: $t1 := +($t2, $t3)
  3: return $t1
}


[variant baseline]
fun test::__lambda__2__eq4($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
  0: $t2 := move($t0)
  1: $t3 := 2
  2: $t1 := +($t2, $t3)
  3: return $t1
}

============ after ControlFlowGraphSimplifier: ================

[variant baseline]
fun test::eq1(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop
     var $t5: bool
     var $t6: &0x1::test::Work
     var $t7: &0x1::test::Work
  0: $t2 := closure#0 test::__lambda__1__eq1()
  1: $t1 := pack 0x1::test::Work($t2)
  2: $t4 := closure#0 test::__lambda__2__eq1()
  3: $t3 := pack 0x1::test::Work($t4)
  4: $t6 := borrow_local($t1)
  5: $t7 := borrow_local($t3)
  6: $t5 := ==($t6, $t7)
  7: if ($t5) goto 8 else goto 12
  8: label L0
  9: $t0 := move($t1)
 10: label L2
 11: return $t0
 12: label L1
 13: $t0 := move($t3)
 14: goto 10
}


[variant baseline]
fun test::eq2(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop
     var $t5: bool
     var $t6: &0x1::test::Work
     var $t7: &0x1::test::Work
  0: $t2 := closure#0 test::__lambda__1__eq2()
  1: $t1 := pack 0x1::test::Work($t2)
  2: $t4 := closure#0 test::__lambda__2__eq2()
  3: $t3 := pack 0x1::test::Work($t4)
  4: $t6 := borrow_local($t1)
  5: $t7 := borrow_local($t3)
  6: $t5 := ==($t6, $t7)
  7: if ($t5) goto 8 else goto 12
  8: label L0
  9: $t0 := move($t1)
 10: label L2
 11: return $t0
 12: label L1
 13: $t0 := move($t3)
 14: goto 10
}


[variant baseline]
fun test::eq3(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop
     var $t5: bool
     var $t6: u64
     var $t7: u64
     var $t8: |u64|u64 has copy + drop
     var $t9: u64
     var $t10: u64
     var $t11: |u64|u64 has copy + drop
  0: $t2 := closure#0 test::__lambda__1__eq3()
  1: $t1 := pack 0x1::test::Work($t2)
  2: $t4 := closure#0 test::__lambda__2__eq3()
  3: $t3 := pack 0x1::test::Work($t4)
  4: $t7 := 2
  5: $t8 := unpack 0x1::test::Work($t1)
  6: $t6 := invoke($t7, $t8)
  7: $t10 := 1
  8: $t11 := unpack 0x1::test::Work($t3)
  9: $t9 := invoke($t10, $t11)
 10: $t5 := ==($t6, $t9)
 11: if ($t5) goto 12 else goto 16
 12: label L0
 13: $t0 := move($t1)
 14: label L2
 15: return $t0
 16: label L1
 17: $t0 := move($t3)
 18: goto 14
}


[variant baseline]
fun test::eq4(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop
     var $t5: bool
     var $t6: &u64
     var $t7: u64
     var $t8: u64
     var $t9: |u64|u64 has copy + drop
     var $t10: &u64
     var $t11: u64
     var $t12: u64
     var $t13: |u64|u64 has copy + drop
  0: $t2 := closure#0 test::__lambda__1__eq4()
  1: $t1 := pack 0x1::test::Work($t2)
  2: $t4 := closure#0 test::__lambda__2__eq4()
  3: $t3 := pack 0x1::test::Work($t4)
  4: $t8 := 2
  5: $t9 := unpack 0x1::test::Work($t1)
  6: $t7 := invoke($t8, $t9)
  7: $t6 := borrow_local($t7)
  8: $t12 := 1
  9: $t13 := unpack 0x1::test::Work($t3)
 10: $t11 := invoke($t12, $t13)
 11: $t10 := borrow_local($t11)
 12: $t5 := ==($t6, $t10)
 13: if ($t5) goto 14 else goto 18
 14: label L0
 15: $t0 := move($t1)
 16: label L2
 17: return $t0
 18: label L1
 19: $t0 := move($t3)
 20: goto 16
}


[variant baseline]
fun test::__lambda__1__eq1($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
  0: $t2 := move($t0)
  1: $t3 := 1
  2: $t1 := +($t2, $t3)
  3: return $t1
}


[variant baseline]
fun test::__lambda__2__eq1($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
  0: $t2 := move($t0)
  1: $t3 := 2
  2: $t1 := +($t2, $t3)
  3: return $t1
}


[variant baseline]
fun test::__lambda__1__eq2($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
  0: $t2 := move($t0)
  1: $t3 := 1
  2: $t1 := +($t2, $t3)
  3: return $t1
}


[variant baseline]
fun test::__lambda__2__eq2($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
  0: $t2 := move($t0)
  1: $t3 := 2
  2: $t1 := +($t2, $t3)
  3: return $t1
}


[variant baseline]
fun test::__lambda__1__eq3($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
  0: $t2 := move($t0)
  1: $t3 := 1
  2: $t1 := +($t2, $t3)
  3: return $t1
}


[variant baseline]
fun test::__lambda__2__eq3($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
  0: $t2 := move($t0)
  1: $t3 := 2
  2: $t1 := +($t2, $t3)
  3: return $t1
}


[variant baseline]
fun test::__lambda__1__eq4($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
  0: $t2 := move($t0)
  1: $t3 := 1
  2: $t1 := +($t2, $t3)
  3: return $t1
}


[variant baseline]
fun test::__lambda__2__eq4($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
  0: $t2 := move($t0)
  1: $t3 := 2
  2: $t1 := +($t2, $t3)
  3: return $t1
}

============ after SplitCriticalEdgesProcessor: ================

[variant baseline]
fun test::eq1(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop
     var $t5: bool
     var $t6: &0x1::test::Work
     var $t7: &0x1::test::Work
  0: $t2 := closure#0 test::__lambda__1__eq1()
  1: $t1 := pack 0x1::test::Work($t2)
  2: $t4 := closure#0 test::__lambda__2__eq1()
  3: $t3 := pack 0x1::test::Work($t4)
  4: $t6 := borrow_local($t1)
  5: $t7 := borrow_local($t3)
  6: $t5 := ==($t6, $t7)
  7: if ($t5) goto 8 else goto 12
  8: label L0
  9: $t0 := move($t1)
 10: label L2
 11: return $t0
 12: label L1
 13: $t0 := move($t3)
 14: goto 10
}


[variant baseline]
fun test::eq2(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop
     var $t5: bool
     var $t6: &0x1::test::Work
     var $t7: &0x1::test::Work
  0: $t2 := closure#0 test::__lambda__1__eq2()
  1: $t1 := pack 0x1::test::Work($t2)
  2: $t4 := closure#0 test::__lambda__2__eq2()
  3: $t3 := pack 0x1::test::Work($t4)
  4: $t6 := borrow_local($t1)
  5: $t7 := borrow_local($t3)
  6: $t5 := ==($t6, $t7)
  7: if ($t5) goto 8 else goto 12
  8: label L0
  9: $t0 := move($t1)
 10: label L2
 11: return $t0
 12: label L1
 13: $t0 := move($t3)
 14: goto 10
}


[variant baseline]
fun test::eq3(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop
     var $t5: bool
     var $t6: u64
     var $t7: u64
     var $t8: |u64|u64 has copy + drop
     var $t9: u64
     var $t10: u64
     var $t11: |u64|u64 has copy + drop
  0: $t2 := closure#0 test::__lambda__1__eq3()
  1: $t1 := pack 0x1::test::Work($t2)
  2: $t4 := closure#0 test::__lambda__2__eq3()
  3: $t3 := pack 0x1::test::Work($t4)
  4: $t7 := 2
  5: $t8 := unpack 0x1::test::Work($t1)
  6: $t6 := invoke($t7, $t8)
  7: $t10 := 1
  8: $t11 := unpack 0x1::test::Work($t3)
  9: $t9 := invoke($t10, $t11)
 10: $t5 := ==($t6, $t9)
 11: if ($t5) goto 12 else goto 16
 12: label L0
 13: $t0 := move($t1)
 14: label L2
 15: return $t0
 16: label L1
 17: $t0 := move($t3)
 18: goto 14
}


[variant baseline]
fun test::eq4(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop
     var $t5: bool
     var $t6: &u64
     var $t7: u64
     var $t8: u64
     var $t9: |u64|u64 has copy + drop
     var $t10: &u64
     var $t11: u64
     var $t12: u64
     var $t13: |u64|u64 has copy + drop
  0: $t2 := closure#0 test::__lambda__1__eq4()
  1: $t1 := pack 0x1::test::Work($t2)
  2: $t4 := closure#0 test::__lambda__2__eq4()
  3: $t3 := pack 0x1::test::Work($t4)
  4: $t8 := 2
  5: $t9 := unpack 0x1::test::Work($t1)
  6: $t7 := invoke($t8, $t9)
  7: $t6 := borrow_local($t7)
  8: $t12 := 1
  9: $t13 := unpack 0x1::test::Work($t3)
 10: $t11 := invoke($t12, $t13)
 11: $t10 := borrow_local($t11)
 12: $t5 := ==($t6, $t10)
 13: if ($t5) goto 14 else goto 18
 14: label L0
 15: $t0 := move($t1)
 16: label L2
 17: return $t0
 18: label L1
 19: $t0 := move($t3)
 20: goto 16
}


[variant baseline]
fun test::__lambda__1__eq1($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
  0: $t2 := move($t0)
  1: $t3 := 1
  2: $t1 := +($t2, $t3)
  3: return $t1
}


[variant baseline]
fun test::__lambda__2__eq1($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
  0: $t2 := move($t0)
  1: $t3 := 2
  2: $t1 := +($t2, $t3)
  3: return $t1
}


[variant baseline]
fun test::__lambda__1__eq2($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
  0: $t2 := move($t0)
  1: $t3 := 1
  2: $t1 := +($t2, $t3)
  3: return $t1
}


[variant baseline]
fun test::__lambda__2__eq2($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
  0: $t2 := move($t0)
  1: $t3 := 2
  2: $t1 := +($t2, $t3)
  3: return $t1
}


[variant baseline]
fun test::__lambda__1__eq3($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
  0: $t2 := move($t0)
  1: $t3 := 1
  2: $t1 := +($t2, $t3)
  3: return $t1
}


[variant baseline]
fun test::__lambda__2__eq3($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
  0: $t2 := move($t0)
  1: $t3 := 2
  2: $t1 := +($t2, $t3)
  3: return $t1
}


[variant baseline]
fun test::__lambda__1__eq4($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
  0: $t2 := move($t0)
  1: $t3 := 1
  2: $t1 := +($t2, $t3)
  3: return $t1
}


[variant baseline]
fun test::__lambda__2__eq4($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
  0: $t2 := move($t0)
  1: $t3 := 2
  2: $t1 := +($t2, $t3)
  3: return $t1
}

============ after UnreachableCodeProcessor: ================

[variant baseline]
fun test::eq1(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop
     var $t5: bool
     var $t6: &0x1::test::Work
     var $t7: &0x1::test::Work
     # maybe
  0: $t2 := closure#0 test::__lambda__1__eq1()
     # maybe
  1: $t1 := pack 0x1::test::Work($t2)
     # maybe
  2: $t4 := closure#0 test::__lambda__2__eq1()
     # maybe
  3: $t3 := pack 0x1::test::Work($t4)
     # maybe
  4: $t6 := borrow_local($t1)
     # maybe
  5: $t7 := borrow_local($t3)
     # maybe
  6: $t5 := ==($t6, $t7)
     # maybe
  7: if ($t5) goto 8 else goto 12
     # maybe
  8: label L0
     # maybe
  9: $t0 := move($t1)
     # maybe
 10: label L2
     # maybe
 11: return $t0
     # maybe
 12: label L1
     # maybe
 13: $t0 := move($t3)
     # maybe
 14: goto 10
}


[variant baseline]
fun test::eq2(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop
     var $t5: bool
     var $t6: &0x1::test::Work
     var $t7: &0x1::test::Work
     # maybe
  0: $t2 := closure#0 test::__lambda__1__eq2()
     # maybe
  1: $t1 := pack 0x1::test::Work($t2)
     # maybe
  2: $t4 := closure#0 test::__lambda__2__eq2()
     # maybe
  3: $t3 := pack 0x1::test::Work($t4)
     # maybe
  4: $t6 := borrow_local($t1)
     # maybe
  5: $t7 := borrow_local($t3)
     # maybe
  6: $t5 := ==($t6, $t7)
     # maybe
  7: if ($t5) goto 8 else goto 12
     # maybe
  8: label L0
     # maybe
  9: $t0 := move($t1)
     # maybe
 10: label L2
     # maybe
 11: return $t0
     # maybe
 12: label L1
     # maybe
 13: $t0 := move($t3)
     # maybe
 14: goto 10
}


[variant baseline]
fun test::eq3(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop
     var $t5: bool
     var $t6: u64
     var $t7: u64
     var $t8: |u64|u64 has copy + drop
     var $t9: u64
     var $t10: u64
     var $t11: |u64|u64 has copy + drop
     # maybe
  0: $t2 := closure#0 test::__lambda__1__eq3()
     # maybe
  1: $t1 := pack 0x1::test::Work($t2)
     # maybe
  2: $t4 := closure#0 test::__lambda__2__eq3()
     # maybe
  3: $t3 := pack 0x1::test::Work($t4)
     # maybe
  4: $t7 := 2
     # maybe
  5: $t8 := unpack 0x1::test::Work($t1)
     # maybe
  6: $t6 := invoke($t7, $t8)
     # maybe
  7: $t10 := 1
     # maybe
  8: $t11 := unpack 0x1::test::Work($t3)
     # maybe
  9: $t9 := invoke($t10, $t11)
     # maybe
 10: $t5 := ==($t6, $t9)
     # maybe
 11: if ($t5) goto 12 else goto 16
     # maybe
 12: label L0
     # maybe
 13: $t0 := move($t1)
     # maybe
 14: label L2
     # maybe
 15: return $t0
     # maybe
 16: label L1
     # maybe
 17: $t0 := move($t3)
     # maybe
 18: goto 14
}


[variant baseline]
fun test::eq4(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop
     var $t5: bool
     var $t6: &u64
     var $t7: u64
     var $t8: u64
     var $t9: |u64|u64 has copy + drop
     var $t10: &u64
     var $t11: u64
     var $t12: u64
     var $t13: |u64|u64 has copy + drop
     # maybe
  0: $t2 := closure#0 test::__lambda__1__eq4()
     # maybe
  1: $t1 := pack 0x1::test::Work($t2)
     # maybe
  2: $t4 := closure#0 test::__lambda__2__eq4()
     # maybe
  3: $t3 := pack 0x1::test::Work($t4)
     # maybe
  4: $t8 := 2
     # maybe
  5: $t9 := unpack 0x1::test::Work($t1)
     # maybe
  6: $t7 := invoke($t8, $t9)
     # maybe
  7: $t6 := borrow_local($t7)
     # maybe
  8: $t12 := 1
     # maybe
  9: $t13 := unpack 0x1::test::Work($t3)
     # maybe
 10: $t11 := invoke($t12, $t13)
     # maybe
 11: $t10 := borrow_local($t11)
     # maybe
 12: $t5 := ==($t6, $t10)
     # maybe
 13: if ($t5) goto 14 else goto 18
     # maybe
 14: label L0
     # maybe
 15: $t0 := move($t1)
     # maybe
 16: label L2
     # maybe
 17: return $t0
     # maybe
 18: label L1
     # maybe
 19: $t0 := move($t3)
     # maybe
 20: goto 16
}


[variant baseline]
fun test::__lambda__1__eq1($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
     # maybe
  0: $t2 := move($t0)
     # maybe
  1: $t3 := 1
     # maybe
  2: $t1 := +($t2, $t3)
     # maybe
  3: return $t1
}


[variant baseline]
fun test::__lambda__2__eq1($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
     # maybe
  0: $t2 := move($t0)
     # maybe
  1: $t3 := 2
     # maybe
  2: $t1 := +($t2, $t3)
     # maybe
  3: return $t1
}


[variant baseline]
fun test::__lambda__1__eq2($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
     # maybe
  0: $t2 := move($t0)
     # maybe
  1: $t3 := 1
     # maybe
  2: $t1 := +($t2, $t3)
     # maybe
  3: return $t1
}


[variant baseline]
fun test::__lambda__2__eq2($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
     # maybe
  0: $t2 := move($t0)
     # maybe
  1: $t3 := 2
     # maybe
  2: $t1 := +($t2, $t3)
     # maybe
  3: return $t1
}


[variant baseline]
fun test::__lambda__1__eq3($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
     # maybe
  0: $t2 := move($t0)
     # maybe
  1: $t3 := 1
     # maybe
  2: $t1 := +($t2, $t3)
     # maybe
  3: return $t1
}


[variant baseline]
fun test::__lambda__2__eq3($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
     # maybe
  0: $t2 := move($t0)
     # maybe
  1: $t3 := 2
     # maybe
  2: $t1 := +($t2, $t3)
     # maybe
  3: return $t1
}


[variant baseline]
fun test::__lambda__1__eq4($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
     # maybe
  0: $t2 := move($t0)
     # maybe
  1: $t3 := 1
     # maybe
  2: $t1 := +($t2, $t3)
     # maybe
  3: return $t1
}


[variant baseline]
fun test::__lambda__2__eq4($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
     # maybe
  0: $t2 := move($t0)
     # maybe
  1: $t3 := 2
     # maybe
  2: $t1 := +($t2, $t3)
     # maybe
  3: return $t1
}

============ after UnreachableCodeRemover: ================

[variant baseline]
fun test::eq1(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop
     var $t5: bool
     var $t6: &0x1::test::Work
     var $t7: &0x1::test::Work
  0: $t2 := closure#0 test::__lambda__1__eq1()
  1: $t1 := pack 0x1::test::Work($t2)
  2: $t4 := closure#0 test::__lambda__2__eq1()
  3: $t3 := pack 0x1::test::Work($t4)
  4: $t6 := borrow_local($t1)
  5: $t7 := borrow_local($t3)
  6: $t5 := ==($t6, $t7)
  7: if ($t5) goto 8 else goto 12
  8: label L0
  9: $t0 := move($t1)
 10: label L2
 11: return $t0
 12: label L1
 13: $t0 := move($t3)
 14: goto 10
}


[variant baseline]
fun test::eq2(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop
     var $t5: bool
     var $t6: &0x1::test::Work
     var $t7: &0x1::test::Work
  0: $t2 := closure#0 test::__lambda__1__eq2()
  1: $t1 := pack 0x1::test::Work($t2)
  2: $t4 := closure#0 test::__lambda__2__eq2()
  3: $t3 := pack 0x1::test::Work($t4)
  4: $t6 := borrow_local($t1)
  5: $t7 := borrow_local($t3)
  6: $t5 := ==($t6, $t7)
  7: if ($t5) goto 8 else goto 12
  8: label L0
  9: $t0 := move($t1)
 10: label L2
 11: return $t0
 12: label L1
 13: $t0 := move($t3)
 14: goto 10
}


[variant baseline]
fun test::eq3(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop
     var $t5: bool
     var $t6: u64
     var $t7: u64
     var $t8: |u64|u64 has copy + drop
     var $t9: u64
     var $t10: u64
     var $t11: |u64|u64 has copy + drop
  0: $t2 := closure#0 test::__lambda__1__eq3()
  1: $t1 := pack 0x1::test::Work($t2)
  2: $t4 := closure#0 test::__lambda__2__eq3()
  3: $t3 := pack 0x1::test::Work($t4)
  4: $t7 := 2
  5: $t8 := unpack 0x1::test::Work($t1)
  6: $t6 := invoke($t7, $t8)
  7: $t10 := 1
  8: $t11 := unpack 0x1::test::Work($t3)
  9: $t9 := invoke($t10, $t11)
 10: $t5 := ==($t6, $t9)
 11: if ($t5) goto 12 else goto 16
 12: label L0
 13: $t0 := move($t1)
 14: label L2
 15: return $t0
 16: label L1
 17: $t0 := move($t3)
 18: goto 14
}


[variant baseline]
fun test::eq4(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop
     var $t5: bool
     var $t6: &u64
     var $t7: u64
     var $t8: u64
     var $t9: |u64|u64 has copy + drop
     var $t10: &u64
     var $t11: u64
     var $t12: u64
     var $t13: |u64|u64 has copy + drop
  0: $t2 := closure#0 test::__lambda__1__eq4()
  1: $t1 := pack 0x1::test::Work($t2)
  2: $t4 := closure#0 test::__lambda__2__eq4()
  3: $t3 := pack 0x1::test::Work($t4)
  4: $t8 := 2
  5: $t9 := unpack 0x1::test::Work($t1)
  6: $t7 := invoke($t8, $t9)
  7: $t6 := borrow_local($t7)
  8: $t12 := 1
  9: $t13 := unpack 0x1::test::Work($t3)
 10: $t11 := invoke($t12, $t13)
 11: $t10 := borrow_local($t11)
 12: $t5 := ==($t6, $t10)
 13: if ($t5) goto 14 else goto 18
 14: label L0
 15: $t0 := move($t1)
 16: label L2
 17: return $t0
 18: label L1
 19: $t0 := move($t3)
 20: goto 16
}


[variant baseline]
fun test::__lambda__1__eq1($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
  0: $t2 := move($t0)
  1: $t3 := 1
  2: $t1 := +($t2, $t3)
  3: return $t1
}


[variant baseline]
fun test::__lambda__2__eq1($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
  0: $t2 := move($t0)
  1: $t3 := 2
  2: $t1 := +($t2, $t3)
  3: return $t1
}


[variant baseline]
fun test::__lambda__1__eq2($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
  0: $t2 := move($t0)
  1: $t3 := 1
  2: $t1 := +($t2, $t3)
  3: return $t1
}


[variant baseline]
fun test::__lambda__2__eq2($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
  0: $t2 := move($t0)
  1: $t3 := 2
  2: $t1 := +($t2, $t3)
  3: return $t1
}


[variant baseline]
fun test::__lambda__1__eq3($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
  0: $t2 := move($t0)
  1: $t3 := 1
  2: $t1 := +($t2, $t3)
  3: return $t1
}


[variant baseline]
fun test::__lambda__2__eq3($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
  0: $t2 := move($t0)
  1: $t3 := 2
  2: $t1 := +($t2, $t3)
  3: return $t1
}


[variant baseline]
fun test::__lambda__1__eq4($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
  0: $t2 := move($t0)
  1: $t3 := 1
  2: $t1 := +($t2, $t3)
  3: return $t1
}


[variant baseline]
fun test::__lambda__2__eq4($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
  0: $t2 := move($t0)
  1: $t3 := 2
  2: $t1 := +($t2, $t3)
  3: return $t1
}

============ after LiveVarAnalysisProcessor: ================

[variant baseline]
fun test::eq1(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop
     var $t5: bool
     var $t6: &0x1::test::Work
     var $t7: &0x1::test::Work
     # live vars:
  0: $t2 := closure#0 test::__lambda__1__eq1()
     # live vars: $t2
  1: $t1 := pack 0x1::test::Work($t2)
     # live vars: $t1
  2: $t4 := closure#0 test::__lambda__2__eq1()
     # live vars: $t1, $t4
  3: $t3 := pack 0x1::test::Work($t4)
     # live vars: $t1, $t3
  4: $t6 := borrow_local($t1)
     # live vars: $t1, $t3, $t6
  5: $t7 := borrow_local($t3)
     # live vars: $t1, $t3, $t6, $t7
  6: $t5 := ==($t6, $t7)
     # live vars: $t1, $t3, $t5
  7: if ($t5) goto 8 else goto 12
     # live vars: $t1, $t3
  8: label L0
     # live vars: $t1
  9: $t0 := move($t1)
     # live vars: $t0
 10: label L2
     # live vars: $t0
 11: return $t0
     # live vars: $t1, $t3
 12: label L1
     # live vars: $t3
 13: $t0 := move($t3)
     # live vars: $t0
 14: goto 10
}


[variant baseline]
fun test::eq2(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop
     var $t5: bool
     var $t6: &0x1::test::Work
     var $t7: &0x1::test::Work
     # live vars:
  0: $t2 := closure#0 test::__lambda__1__eq2()
     # live vars: $t2
  1: $t1 := pack 0x1::test::Work($t2)
     # live vars: $t1
  2: $t4 := closure#0 test::__lambda__2__eq2()
     # live vars: $t1, $t4
  3: $t3 := pack 0x1::test::Work($t4)
     # live vars: $t1, $t3
  4: $t6 := borrow_local($t1)
     # live vars: $t1, $t3, $t6
  5: $t7 := borrow_local($t3)
     # live vars: $t1, $t3, $t6, $t7
  6: $t5 := ==($t6, $t7)
     # live vars: $t1, $t3, $t5
  7: if ($t5) goto 8 else goto 12
     # live vars: $t1, $t3
  8: label L0
     # live vars: $t1
  9: $t0 := move($t1)
     # live vars: $t0
 10: label L2
     # live vars: $t0
 11: return $t0
     # live vars: $t1, $t3
 12: label L1
     # live vars: $t3
 13: $t0 := move($t3)
     # live vars: $t0
 14: goto 10
}


[variant baseline]
fun test::eq3(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop
     var $t5: bool
     var $t6: u64
     var $t7: u64
     var $t8: |u64|u64 has copy + drop
     var $t9: u64
     var $t10: u64
     var $t11: |u64|u64 has copy + drop
     # live vars:
  0: $t2 := closure#0 test::__lambda__1__eq3()
     # live vars: $t2
  1: $t1 := pack 0x1::test::Work($t2)
     # live vars: $t1
  2: $t4 := closure#0 test::__lambda__2__eq3()
     # live vars: $t1, $t4
  3: $t3 := pack 0x1::test::Work($t4)
     # live vars: $t1, $t3
  4: $t7 := 2
     # live vars: $t1, $t3, $t7
  5: $t8 := unpack 0x1::test::Work($t1)
     # live vars: $t1, $t3, $t7, $t8
  6: $t6 := invoke($t7, $t8)
     # live vars: $t1, $t3, $t6
  7: $t10 := 1
     # live vars: $t1, $t3, $t6, $t10
  8: $t11 := unpack 0x1::test::Work($t3)
     # live vars: $t1, $t3, $t6, $t10, $t11
  9: $t9 := invoke($t10, $t11)
     # live vars: $t1, $t3, $t6, $t9
 10: $t5 := ==($t6, $t9)
     # live vars: $t1, $t3, $t5
 11: if ($t5) goto 12 else goto 16
     # live vars: $t1, $t3
 12: label L0
     # live vars: $t1
 13: $t0 := move($t1)
     # live vars: $t0
 14: label L2
     # live vars: $t0
 15: return $t0
     # live vars: $t1, $t3
 16: label L1
     # live vars: $t3
 17: $t0 := move($t3)
     # live vars: $t0
 18: goto 14
}


[variant baseline]
fun test::eq4(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop
     var $t5: bool
     var $t6: &u64
     var $t7: u64
     var $t8: u64
     var $t9: |u64|u64 has copy + drop
     var $t10: &u64
     var $t11: u64
     var $t12: u64
     var $t13: |u64|u64 has copy + drop
     # live vars:
  0: $t2 := closure#0 test::__lambda__1__eq4()
     # live vars: $t2
  1: $t1 := pack 0x1::test::Work($t2)
     # live vars: $t1
  2: $t4 := closure#0 test::__lambda__2__eq4()
     # live vars: $t1, $t4
  3: $t3 := pack 0x1::test::Work($t4)
     # live vars: $t1, $t3
  4: $t8 := 2
     # live vars: $t1, $t3, $t8
  5: $t9 := unpack 0x1::test::Work($t1)
     # live vars: $t1, $t3, $t8, $t9
  6: $t7 := invoke($t8, $t9)
     # live vars: $t1, $t3, $t7
  7: $t6 := borrow_local($t7)
     # live vars: $t1, $t3, $t6
  8: $t12 := 1
     # live vars: $t1, $t3, $t6, $t12
  9: $t13 := unpack 0x1::test::Work($t3)
     # live vars: $t1, $t3, $t6, $t12, $t13
 10: $t11 := invoke($t12, $t13)
     # live vars: $t1, $t3, $t6, $t11
 11: $t10 := borrow_local($t11)
     # live vars: $t1, $t3, $t6, $t10
 12: $t5 := ==($t6, $t10)
     # live vars: $t1, $t3, $t5
 13: if ($t5) goto 14 else goto 18
     # live vars: $t1, $t3
 14: label L0
     # live vars: $t1
 15: $t0 := move($t1)
     # live vars: $t0
 16: label L2
     # live vars: $t0
 17: return $t0
     # live vars: $t1, $t3
 18: label L1
     # live vars: $t3
 19: $t0 := move($t3)
     # live vars: $t0
 20: goto 16
}


[variant baseline]
fun test::__lambda__1__eq1($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
     # live vars: $t0
  0: $t2 := move($t0)
     # live vars: $t2
  1: $t3 := 1
     # live vars: $t2, $t3
  2: $t1 := +($t2, $t3)
     # live vars: $t1
  3: return $t1
}


[variant baseline]
fun test::__lambda__2__eq1($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
     # live vars: $t0
  0: $t2 := move($t0)
     # live vars: $t2
  1: $t3 := 2
     # live vars: $t2, $t3
  2: $t1 := +($t2, $t3)
     # live vars: $t1
  3: return $t1
}


[variant baseline]
fun test::__lambda__1__eq2($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
     # live vars: $t0
  0: $t2 := move($t0)
     # live vars: $t2
  1: $t3 := 1
     # live vars: $t2, $t3
  2: $t1 := +($t2, $t3)
     # live vars: $t1
  3: return $t1
}


[variant baseline]
fun test::__lambda__2__eq2($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
     # live vars: $t0
  0: $t2 := move($t0)
     # live vars: $t2
  1: $t3 := 2
     # live vars: $t2, $t3
  2: $t1 := +($t2, $t3)
     # live vars: $t1
  3: return $t1
}


[variant baseline]
fun test::__lambda__1__eq3($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
     # live vars: $t0
  0: $t2 := move($t0)
     # live vars: $t2
  1: $t3 := 1
     # live vars: $t2, $t3
  2: $t1 := +($t2, $t3)
     # live vars: $t1
  3: return $t1
}


[variant baseline]
fun test::__lambda__2__eq3($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
     # live vars: $t0
  0: $t2 := move($t0)
     # live vars: $t2
  1: $t3 := 2
     # live vars: $t2, $t3
  2: $t1 := +($t2, $t3)
     # live vars: $t1
  3: return $t1
}


[variant baseline]
fun test::__lambda__1__eq4($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
     # live vars: $t0
  0: $t2 := move($t0)
     # live vars: $t2
  1: $t3 := 1
     # live vars: $t2, $t3
  2: $t1 := +($t2, $t3)
     # live vars: $t1
  3: return $t1
}


[variant baseline]
fun test::__lambda__2__eq4($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
     # live vars: $t0
  0: $t2 := move($t0)
     # live vars: $t2
  1: $t3 := 2
     # live vars: $t2, $t3
  2: $t1 := +($t2, $t3)
     # live vars: $t1
  3: return $t1
}

============ after DeadStoreElimination: ================

[variant baseline]
fun test::eq1(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop
     var $t5: bool
     var $t6: &0x1::test::Work
     var $t7: &0x1::test::Work
  0: $t2 := closure#0 test::__lambda__1__eq1()
  1: $t1 := pack 0x1::test::Work($t2)
  2: $t4 := closure#0 test::__lambda__2__eq1()
  3: $t3 := pack 0x1::test::Work($t4)
  4: $t6 := borrow_local($t1)
  5: $t7 := borrow_local($t3)
  6: $t5 := ==($t6, $t7)
  7: if ($t5) goto 8 else goto 12
  8: label L0
  9: $t0 := move($t1)
 10: label L2
 11: return $t0
 12: label L1
 13: $t0 := move($t3)
 14: goto 10
}


[variant baseline]
fun test::eq2(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop
     var $t5: bool
     var $t6: &0x1::test::Work
     var $t7: &0x1::test::Work
  0: $t2 := closure#0 test::__lambda__1__eq2()
  1: $t1 := pack 0x1::test::Work($t2)
  2: $t4 := closure#0 test::__lambda__2__eq2()
  3: $t3 := pack 0x1::test::Work($t4)
  4: $t6 := borrow_local($t1)
  5: $t7 := borrow_local($t3)
  6: $t5 := ==($t6, $t7)
  7: if ($t5) goto 8 else goto 12
  8: label L0
  9: $t0 := move($t1)
 10: label L2
 11: return $t0
 12: label L1
 13: $t0 := move($t3)
 14: goto 10
}


[variant baseline]
fun test::eq3(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop
     var $t5: bool
     var $t6: u64
     var $t7: u64
     var $t8: |u64|u64 has copy + drop
     var $t9: u64
     var $t10: u64
     var $t11: |u64|u64 has copy + drop
  0: $t2 := closure#0 test::__lambda__1__eq3()
  1: $t1 := pack 0x1::test::Work($t2)
  2: $t4 := closure#0 test::__lambda__2__eq3()
  3: $t3 := pack 0x1::test::Work($t4)
  4: $t7 := 2
  5: $t8 := unpack 0x1::test::Work($t1)
  6: $t6 := invoke($t7, $t8)
  7: $t10 := 1
  8: $t11 := unpack 0x1::test::Work($t3)
  9: $t9 := invoke($t10, $t11)
 10: $t5 := ==($t6, $t9)
 11: if ($t5) goto 12 else goto 16
 12: label L0
 13: $t0 := move($t1)
 14: label L2
 15: return $t0
 16: label L1
 17: $t0 := move($t3)
 18: goto 14
}


[variant baseline]
fun test::eq4(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop
     var $t5: bool
     var $t6: &u64
     var $t7: u64
     var $t8: u64
     var $t9: |u64|u64 has copy + drop
     var $t10: &u64
     var $t11: u64
     var $t12: u64
     var $t13: |u64|u64 has copy + drop
  0: $t2 := closure#0 test::__lambda__1__eq4()
  1: $t1 := pack 0x1::test::Work($t2)
  2: $t4 := closure#0 test::__lambda__2__eq4()
  3: $t3 := pack 0x1::test::Work($t4)
  4: $t8 := 2
  5: $t9 := unpack 0x1::test::Work($t1)
  6: $t7 := invoke($t8, $t9)
  7: $t6 := borrow_local($t7)
  8: $t12 := 1
  9: $t13 := unpack 0x1::test::Work($t3)
 10: $t11 := invoke($t12, $t13)
 11: $t10 := borrow_local($t11)
 12: $t5 := ==($t6, $t10)
 13: if ($t5) goto 14 else goto 18
 14: label L0
 15: $t0 := move($t1)
 16: label L2
 17: return $t0
 18: label L1
 19: $t0 := move($t3)
 20: goto 16
}


[variant baseline]
fun test::__lambda__1__eq1($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
  0: $t2 := move($t0)
  1: $t3 := 1
  2: $t1 := +($t2, $t3)
  3: return $t1
}


[variant baseline]
fun test::__lambda__2__eq1($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
  0: $t2 := move($t0)
  1: $t3 := 2
  2: $t1 := +($t2, $t3)
  3: return $t1
}


[variant baseline]
fun test::__lambda__1__eq2($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
  0: $t2 := move($t0)
  1: $t3 := 1
  2: $t1 := +($t2, $t3)
  3: return $t1
}


[variant baseline]
fun test::__lambda__2__eq2($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
  0: $t2 := move($t0)
  1: $t3 := 2
  2: $t1 := +($t2, $t3)
  3: return $t1
}


[variant baseline]
fun test::__lambda__1__eq3($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
  0: $t2 := move($t0)
  1: $t3 := 1
  2: $t1 := +($t2, $t3)
  3: return $t1
}


[variant baseline]
fun test::__lambda__2__eq3($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
  0: $t2 := move($t0)
  1: $t3 := 2
  2: $t1 := +($t2, $t3)
  3: return $t1
}


[variant baseline]
fun test::__lambda__1__eq4($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
  0: $t2 := move($t0)
  1: $t3 := 1
  2: $t1 := +($t2, $t3)
  3: return $t1
}


[variant baseline]
fun test::__lambda__2__eq4($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
  0: $t2 := move($t0)
  1: $t3 := 2
  2: $t1 := +($t2, $t3)
  3: return $t1
}

============ after LiveVarAnalysisProcessor: ================

[variant baseline]
fun test::eq1(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop
     var $t5: bool
     var $t6: &0x1::test::Work
     var $t7: &0x1::test::Work
     # live vars:
  0: $t2 := closure#0 test::__lambda__1__eq1()
     # live vars: $t2
  1: $t1 := pack 0x1::test::Work($t2)
     # live vars: $t1
  2: $t4 := closure#0 test::__lambda__2__eq1()
     # live vars: $t1, $t4
  3: $t3 := pack 0x1::test::Work($t4)
     # live vars: $t1, $t3
  4: $t6 := borrow_local($t1)
     # live vars: $t1, $t3, $t6
  5: $t7 := borrow_local($t3)
     # live vars: $t1, $t3, $t6, $t7
  6: $t5 := ==($t6, $t7)
     # live vars: $t1, $t3, $t5
  7: if ($t5) goto 8 else goto 12
     # live vars: $t1, $t3
  8: label L0
     # live vars: $t1
  9: $t0 := move($t1)
     # live vars: $t0
 10: label L2
     # live vars: $t0
 11: return $t0
     # live vars: $t1, $t3
 12: label L1
     # live vars: $t3
 13: $t0 := move($t3)
     # live vars: $t0
 14: goto 10
}


[variant baseline]
fun test::eq2(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop
     var $t5: bool
     var $t6: &0x1::test::Work
     var $t7: &0x1::test::Work
     # live vars:
  0: $t2 := closure#0 test::__lambda__1__eq2()
     # live vars: $t2
  1: $t1 := pack 0x1::test::Work($t2)
     # live vars: $t1
  2: $t4 := closure#0 test::__lambda__2__eq2()
     # live vars: $t1, $t4
  3: $t3 := pack 0x1::test::Work($t4)
     # live vars: $t1, $t3
  4: $t6 := borrow_local($t1)
     # live vars: $t1, $t3, $t6
  5: $t7 := borrow_local($t3)
     # live vars: $t1, $t3, $t6, $t7
  6: $t5 := ==($t6, $t7)
     # live vars: $t1, $t3, $t5
  7: if ($t5) goto 8 else goto 12
     # live vars: $t1, $t3
  8: label L0
     # live vars: $t1
  9: $t0 := move($t1)
     # live vars: $t0
 10: label L2
     # live vars: $t0
 11: return $t0
     # live vars: $t1, $t3
 12: label L1
     # live vars: $t3
 13: $t0 := move($t3)
     # live vars: $t0
 14: goto 10
}


[variant baseline]
fun test::eq3(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop
     var $t5: bool
     var $t6: u64
     var $t7: u64
     var $t8: |u64|u64 has copy + drop
     var $t9: u64
     var $t10: u64
     var $t11: |u64|u64 has copy + drop
     # live vars:
  0: $t2 := closure#0 test::__lambda__1__eq3()
     # live vars: $t2
  1: $t1 := pack 0x1::test::Work($t2)
     # live vars: $t1
  2: $t4 := closure#0 test::__lambda__2__eq3()
     # live vars: $t1, $t4
  3: $t3 := pack 0x1::test::Work($t4)
     # live vars: $t1, $t3
  4: $t7 := 2
     # live vars: $t1, $t3, $t7
  5: $t8 := unpack 0x1::test::Work($t1)
     # live vars: $t1, $t3, $t7, $t8
  6: $t6 := invoke($t7, $t8)
     # live vars: $t1, $t3, $t6
  7: $t10 := 1
     # live vars: $t1, $t3, $t6, $t10
  8: $t11 := unpack 0x1::test::Work($t3)
     # live vars: $t1, $t3, $t6, $t10, $t11
  9: $t9 := invoke($t10, $t11)
     # live vars: $t1, $t3, $t6, $t9
 10: $t5 := ==($t6, $t9)
     # live vars: $t1, $t3, $t5
 11: if ($t5) goto 12 else goto 16
     # live vars: $t1, $t3
 12: label L0
     # live vars: $t1
 13: $t0 := move($t1)
     # live vars: $t0
 14: label L2
     # live vars: $t0
 15: return $t0
     # live vars: $t1, $t3
 16: label L1
     # live vars: $t3
 17: $t0 := move($t3)
     # live vars: $t0
 18: goto 14
}


[variant baseline]
fun test::eq4(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop
     var $t5: bool
     var $t6: &u64
     var $t7: u64
     var $t8: u64
     var $t9: |u64|u64 has copy + drop
     var $t10: &u64
     var $t11: u64
     var $t12: u64
     var $t13: |u64|u64 has copy + drop
     # live vars:
  0: $t2 := closure#0 test::__lambda__1__eq4()
     # live vars: $t2
  1: $t1 := pack 0x1::test::Work($t2)
     # live vars: $t1
  2: $t4 := closure#0 test::__lambda__2__eq4()
     # live vars: $t1, $t4
  3: $t3 := pack 0x1::test::Work($t4)
     # live vars: $t1, $t3
  4: $t8 := 2
     # live vars: $t1, $t3, $t8
  5: $t9 := unpack 0x1::test::Work($t1)
     # live vars: $t1, $t3, $t8, $t9
  6: $t7 := invoke($t8, $t9)
     # live vars: $t1, $t3, $t7
  7: $t6 := borrow_local($t7)
     # live vars: $t1, $t3, $t6
  8: $t12 := 1
     # live vars: $t1, $t3, $t6, $t12
  9: $t13 := unpack 0x1::test::Work($t3)
     # live vars: $t1, $t3, $t6, $t12, $t13
 10: $t11 := invoke($t12, $t13)
     # live vars: $t1, $t3, $t6, $t11
 11: $t10 := borrow_local($t11)
     # live vars: $t1, $t3, $t6, $t10
 12: $t5 := ==($t6, $t10)
     # live vars: $t1, $t3, $t5
 13: if ($t5) goto 14 else goto 18
     # live vars: $t1, $t3
 14: label L0
     # live vars: $t1
 15: $t0 := move($t1)
     # live vars: $t0
 16: label L2
     # live vars: $t0
 17: return $t0
     # live vars: $t1, $t3
 18: label L1
     # live vars: $t3
 19: $t0 := move($t3)
     # live vars: $t0
 20: goto 16
}


[variant baseline]
fun test::__lambda__1__eq1($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
     # live vars: $t0
  0: $t2 := move($t0)
     # live vars: $t2
  1: $t3 := 1
     # live vars: $t2, $t3
  2: $t1 := +($t2, $t3)
     # live vars: $t1
  3: return $t1
}


[variant baseline]
fun test::__lambda__2__eq1($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
     # live vars: $t0
  0: $t2 := move($t0)
     # live vars: $t2
  1: $t3 := 2
     # live vars: $t2, $t3
  2: $t1 := +($t2, $t3)
     # live vars: $t1
  3: return $t1
}


[variant baseline]
fun test::__lambda__1__eq2($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
     # live vars: $t0
  0: $t2 := move($t0)
     # live vars: $t2
  1: $t3 := 1
     # live vars: $t2, $t3
  2: $t1 := +($t2, $t3)
     # live vars: $t1
  3: return $t1
}


[variant baseline]
fun test::__lambda__2__eq2($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
     # live vars: $t0
  0: $t2 := move($t0)
     # live vars: $t2
  1: $t3 := 2
     # live vars: $t2, $t3
  2: $t1 := +($t2, $t3)
     # live vars: $t1
  3: return $t1
}


[variant baseline]
fun test::__lambda__1__eq3($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
     # live vars: $t0
  0: $t2 := move($t0)
     # live vars: $t2
  1: $t3 := 1
     # live vars: $t2, $t3
  2: $t1 := +($t2, $t3)
     # live vars: $t1
  3: return $t1
}


[variant baseline]
fun test::__lambda__2__eq3($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
     # live vars: $t0
  0: $t2 := move($t0)
     # live vars: $t2
  1: $t3 := 2
     # live vars: $t2, $t3
  2: $t1 := +($t2, $t3)
     # live vars: $t1
  3: return $t1
}


[variant baseline]
fun test::__lambda__1__eq4($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
     # live vars: $t0
  0: $t2 := move($t0)
     # live vars: $t2
  1: $t3 := 1
     # live vars: $t2, $t3
  2: $t1 := +($t2, $t3)
     # live vars: $t1
  3: return $t1
}


[variant baseline]
fun test::__lambda__2__eq4($t0: u64): u64 {
     var $t1: u64
     var $t2: u64
     var $t3: u64
     # live vars: $t0
  0: $t2 := move($t0)
     # live vars: $t2
  1: $t3 := 2
     # live vars: $t2, $t3
  2: $t1 := +($t2, $t3)
     # live vars: $t1
  3: return $t1
}

============ after VariableCoalescingTransformer: ================

[variant baseline]
fun test::eq1(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop [unused]
     var $t5: bool
     var $t6: &0x1::test::Work
     var $t7: &0x1::test::Work
  0: $t2 := closure#0 test::__lambda__1__eq1()
  1: $t1 := pack 0x1::test::Work($t2)
  2: $t2 := closure#0 test::__lambda__2__eq1()
  3: $t3 := pack 0x1::test::Work($t2)
  4: $t6 := borrow_local($t1)
  5: $t7 := borrow_local($t3)
  6: $t5 := ==($t6, $t7)
  7: if ($t5) goto 8 else goto 12
  8: label L0
  9: $t0 := move($t1)
 10: label L2
 11: return $t0
 12: label L1
 13: $t0 := move($t3)
 14: goto 10
}


[variant baseline]
fun test::eq2(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop [unused]
     var $t5: bool
     var $t6: &0x1::test::Work
     var $t7: &0x1::test::Work
  0: $t2 := closure#0 test::__lambda__1__eq2()
  1: $t1 := pack 0x1::test::Work($t2)
  2: $t2 := closure#0 test::__lambda__2__eq2()
  3: $t3 := pack 0x1::test::Work($t2)
  4: $t6 := borrow_local($t1)
  5: $t7 := borrow_local($t3)
  6: $t5 := ==($t6, $t7)
  7: if ($t5) goto 8 else goto 12
  8: label L0
  9: $t0 := move($t1)
 10: label L2
 11: return $t0
 12: label L1
 13: $t0 := move($t3)
 14: goto 10
}


[variant baseline]
fun test::eq3(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop [unused]
     var $t5: bool
     var $t6: u64 [unused]
     var $t7: u64
     var $t8: |u64|u64 has copy + drop [unused]
     var $t9: u64 [unused]
     var $t10: u64
     var $t11: |u64|u64 has copy + drop [unused]
  0: $t2 := closure#0 test::__lambda__1__eq3()
  1: $t1 := pack 0x1::test::Work($t2)
  2: $t2 := closure#0 test::__lambda__2__eq3()
  3: $t3 := pack 0x1::test::Work($t2)
  4: $t7 := 2
  5: $t2 := unpack 0x1::test::Work($t1)
  6: $t7 := invoke($t7, $t2)
  7: $t10 := 1
  8: $t2 := unpack 0x1::test::Work($t3)
  9: $t10 := invoke($t10, $t2)
 10: $t5 := ==($t7, $t10)
 11: if ($t5) goto 12 else goto 16
 12: label L0
 13: $t0 := move($t1)
 14: label L2
 15: return $t0
 16: label L1
 17: $t0 := move($t3)
 18: goto 14
}


[variant baseline]
fun test::eq4(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop [unused]
     var $t5: bool
     var $t6: &u64
     var $t7: u64
     var $t8: u64
     var $t9: |u64|u64 has copy + drop [unused]
     var $t10: &u64
     var $t11: u64
     var $t12: u64 [unused]
     var $t13: |u64|u64 has copy + drop [unused]
  0: $t2 := closure#0 test::__lambda__1__eq4()
  1: $t1 := pack 0x1::test::Work($t2)
  2: $t2 := closure#0 test::__lambda__2__eq4()
  3: $t3 := pack 0x1::test::Work($t2)
  4: $t8 := 2
  5: $t2 := unpack 0x1::test::Work($t1)
  6: $t7 := invoke($t8, $t2)
  7: $t6 := borrow_local($t7)
  8: $t8 := 1
  9: $t2 := unpack 0x1::test::Work($t3)
 10: $t11 := invoke($t8, $t2)
 11: $t10 := borrow_local($t11)
 12: $t5 := ==($t6, $t10)
 13: if ($t5) goto 14 else goto 18
 14: label L0
 15: $t0 := move($t1)
 16: label L2
 17: return $t0
 18: label L1
 19: $t0 := move($t3)
 20: goto 16
}


[variant baseline]
fun test::__lambda__1__eq1($t0: u64): u64 {
     var $t1: u64 [unused]
     var $t2: u64 [unused]
     var $t3: u64
  0: $t0 := move($t0)
  1: $t3 := 1
  2: $t0 := +($t0, $t3)
  3: return $t0
}


[variant baseline]
fun test::__lambda__2__eq1($t0: u64): u64 {
     var $t1: u64 [unused]
     var $t2: u64 [unused]
     var $t3: u64
  0: $t0 := move($t0)
  1: $t3 := 2
  2: $t0 := +($t0, $t3)
  3: return $t0
}


[variant baseline]
fun test::__lambda__1__eq2($t0: u64): u64 {
     var $t1: u64 [unused]
     var $t2: u64 [unused]
     var $t3: u64
  0: $t0 := move($t0)
  1: $t3 := 1
  2: $t0 := +($t0, $t3)
  3: return $t0
}


[variant baseline]
fun test::__lambda__2__eq2($t0: u64): u64 {
     var $t1: u64 [unused]
     var $t2: u64 [unused]
     var $t3: u64
  0: $t0 := move($t0)
  1: $t3 := 2
  2: $t0 := +($t0, $t3)
  3: return $t0
}


[variant baseline]
fun test::__lambda__1__eq3($t0: u64): u64 {
     var $t1: u64 [unused]
     var $t2: u64 [unused]
     var $t3: u64
  0: $t0 := move($t0)
  1: $t3 := 1
  2: $t0 := +($t0, $t3)
  3: return $t0
}


[variant baseline]
fun test::__lambda__2__eq3($t0: u64): u64 {
     var $t1: u64 [unused]
     var $t2: u64 [unused]
     var $t3: u64
  0: $t0 := move($t0)
  1: $t3 := 2
  2: $t0 := +($t0, $t3)
  3: return $t0
}


[variant baseline]
fun test::__lambda__1__eq4($t0: u64): u64 {
     var $t1: u64 [unused]
     var $t2: u64 [unused]
     var $t3: u64
  0: $t0 := move($t0)
  1: $t3 := 1
  2: $t0 := +($t0, $t3)
  3: return $t0
}


[variant baseline]
fun test::__lambda__2__eq4($t0: u64): u64 {
     var $t1: u64 [unused]
     var $t2: u64 [unused]
     var $t3: u64
  0: $t0 := move($t0)
  1: $t3 := 2
  2: $t0 := +($t0, $t3)
  3: return $t0
}

============ after LiveVarAnalysisProcessor: ================

[variant baseline]
fun test::eq1(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop [unused]
     var $t5: bool
     var $t6: &0x1::test::Work
     var $t7: &0x1::test::Work
     # live vars:
  0: $t2 := closure#0 test::__lambda__1__eq1()
     # live vars: $t2
  1: $t1 := pack 0x1::test::Work($t2)
     # live vars: $t1
  2: $t2 := closure#0 test::__lambda__2__eq1()
     # live vars: $t1, $t2
  3: $t3 := pack 0x1::test::Work($t2)
     # live vars: $t1, $t3
  4: $t6 := borrow_local($t1)
     # live vars: $t1, $t3, $t6
  5: $t7 := borrow_local($t3)
     # live vars: $t1, $t3, $t6, $t7
  6: $t5 := ==($t6, $t7)
     # live vars: $t1, $t3, $t5
  7: if ($t5) goto 8 else goto 12
     # live vars: $t1, $t3
  8: label L0
     # live vars: $t1
  9: $t0 := move($t1)
     # live vars: $t0
 10: label L2
     # live vars: $t0
 11: return $t0
     # live vars: $t1, $t3
 12: label L1
     # live vars: $t3
 13: $t0 := move($t3)
     # live vars: $t0
 14: goto 10
}


[variant baseline]
fun test::eq2(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop [unused]
     var $t5: bool
     var $t6: &0x1::test::Work
     var $t7: &0x1::test::Work
     # live vars:
  0: $t2 := closure#0 test::__lambda__1__eq2()
     # live vars: $t2
  1: $t1 := pack 0x1::test::Work($t2)
     # live vars: $t1
  2: $t2 := closure#0 test::__lambda__2__eq2()
     # live vars: $t1, $t2
  3: $t3 := pack 0x1::test::Work($t2)
     # live vars: $t1, $t3
  4: $t6 := borrow_local($t1)
     # live vars: $t1, $t3, $t6
  5: $t7 := borrow_local($t3)
     # live vars: $t1, $t3, $t6, $t7
  6: $t5 := ==($t6, $t7)
     # live vars: $t1, $t3, $t5
  7: if ($t5) goto 8 else goto 12
     # live vars: $t1, $t3
  8: label L0
     # live vars: $t1
  9: $t0 := move($t1)
     # live vars: $t0
 10: label L2
     # live vars: $t0
 11: return $t0
     # live vars: $t1, $t3
 12: label L1
     # live vars: $t3
 13: $t0 := move($t3)
     # live vars: $t0
 14: goto 10
}


[variant baseline]
fun test::eq3(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop [unused]
     var $t5: bool
     var $t6: u64 [unused]
     var $t7: u64
     var $t8: |u64|u64 has copy + drop [unused]
     var $t9: u64 [unused]
     var $t10: u64
     var $t11: |u64|u64 has copy + drop [unused]
     # live vars:
  0: $t2 := closure#0 test::__lambda__1__eq3()
     # live vars: $t2
  1: $t1 := pack 0x1::test::Work($t2)
     # live vars: $t1
  2: $t2 := closure#0 test::__lambda__2__eq3()
     # live vars: $t1, $t2
  3: $t3 := pack 0x1::test::Work($t2)
     # live vars: $t1, $t3
  4: $t7 := 2
     # live vars: $t1, $t3, $t7
  5: $t2 := unpack 0x1::test::Work($t1)
     # live vars: $t1, $t2, $t3, $t7
  6: $t7 := invoke($t7, $t2)
     # live vars: $t1, $t3, $t7
  7: $t10 := 1
     # live vars: $t1, $t3, $t7, $t10
  8: $t2 := unpack 0x1::test::Work($t3)
     # live vars: $t1, $t2, $t3, $t7, $t10
  9: $t10 := invoke($t10, $t2)
     # live vars: $t1, $t3, $t7, $t10
 10: $t5 := ==($t7, $t10)
     # live vars: $t1, $t3, $t5
 11: if ($t5) goto 12 else goto 16
     # live vars: $t1, $t3
 12: label L0
     # live vars: $t1
 13: $t0 := move($t1)
     # live vars: $t0
 14: label L2
     # live vars: $t0
 15: return $t0
     # live vars: $t1, $t3
 16: label L1
     # live vars: $t3
 17: $t0 := move($t3)
     # live vars: $t0
 18: goto 14
}


[variant baseline]
fun test::eq4(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop [unused]
     var $t5: bool
     var $t6: &u64
     var $t7: u64
     var $t8: u64
     var $t9: |u64|u64 has copy + drop [unused]
     var $t10: &u64
     var $t11: u64
     var $t12: u64 [unused]
     var $t13: |u64|u64 has copy + drop [unused]
     # live vars:
  0: $t2 := closure#0 test::__lambda__1__eq4()
     # live vars: $t2
  1: $t1 := pack 0x1::test::Work($t2)
     # live vars: $t1
  2: $t2 := closure#0 test::__lambda__2__eq4()
     # live vars: $t1, $t2
  3: $t3 := pack 0x1::test::Work($t2)
     # live vars: $t1, $t3
  4: $t8 := 2
     # live vars: $t1, $t3, $t8
  5: $t2 := unpack 0x1::test::Work($t1)
     # live vars: $t1, $t2, $t3, $t8
  6: $t7 := invoke($t8, $t2)
     # live vars: $t1, $t3, $t7
  7: $t6 := borrow_local($t7)
     # live vars: $t1, $t3, $t6
  8: $t8 := 1
     # live vars: $t1, $t3, $t6, $t8
  9: $t2 := unpack 0x1::test::Work($t3)
     # live vars: $t1, $t2, $t3, $t6, $t8
 10: $t11 := invoke($t8, $t2)
     # live vars: $t1, $t3, $t6, $t11
 11: $t10 := borrow_local($t11)
     # live vars: $t1, $t3, $t6, $t10
 12: $t5 := ==($t6, $t10)
     # live vars: $t1, $t3, $t5
 13: if ($t5) goto 14 else goto 18
     # live vars: $t1, $t3
 14: label L0
     # live vars: $t1
 15: $t0 := move($t1)
     # live vars: $t0
 16: label L2
     # live vars: $t0
 17: return $t0
     # live vars: $t1, $t3
 18: label L1
     # live vars: $t3
 19: $t0 := move($t3)
     # live vars: $t0
 20: goto 16
}


[variant baseline]
fun test::__lambda__1__eq1($t0: u64): u64 {
     var $t1: u64 [unused]
     var $t2: u64 [unused]
     var $t3: u64
     # live vars: $t0
  0: $t0 := move($t0)
     # live vars: $t0
  1: $t3 := 1
     # live vars: $t0, $t3
  2: $t0 := +($t0, $t3)
     # live vars: $t0
  3: return $t0
}


[variant baseline]
fun test::__lambda__2__eq1($t0: u64): u64 {
     var $t1: u64 [unused]
     var $t2: u64 [unused]
     var $t3: u64
     # live vars: $t0
  0: $t0 := move($t0)
     # live vars: $t0
  1: $t3 := 2
     # live vars: $t0, $t3
  2: $t0 := +($t0, $t3)
     # live vars: $t0
  3: return $t0
}


[variant baseline]
fun test::__lambda__1__eq2($t0: u64): u64 {
     var $t1: u64 [unused]
     var $t2: u64 [unused]
     var $t3: u64
     # live vars: $t0
  0: $t0 := move($t0)
     # live vars: $t0
  1: $t3 := 1
     # live vars: $t0, $t3
  2: $t0 := +($t0, $t3)
     # live vars: $t0
  3: return $t0
}


[variant baseline]
fun test::__lambda__2__eq2($t0: u64): u64 {
     var $t1: u64 [unused]
     var $t2: u64 [unused]
     var $t3: u64
     # live vars: $t0
  0: $t0 := move($t0)
     # live vars: $t0
  1: $t3 := 2
     # live vars: $t0, $t3
  2: $t0 := +($t0, $t3)
     # live vars: $t0
  3: return $t0
}


[variant baseline]
fun test::__lambda__1__eq3($t0: u64): u64 {
     var $t1: u64 [unused]
     var $t2: u64 [unused]
     var $t3: u64
     # live vars: $t0
  0: $t0 := move($t0)
     # live vars: $t0
  1: $t3 := 1
     # live vars: $t0, $t3
  2: $t0 := +($t0, $t3)
     # live vars: $t0
  3: return $t0
}


[variant baseline]
fun test::__lambda__2__eq3($t0: u64): u64 {
     var $t1: u64 [unused]
     var $t2: u64 [unused]
     var $t3: u64
     # live vars: $t0
  0: $t0 := move($t0)
     # live vars: $t0
  1: $t3 := 2
     # live vars: $t0, $t3
  2: $t0 := +($t0, $t3)
     # live vars: $t0
  3: return $t0
}


[variant baseline]
fun test::__lambda__1__eq4($t0: u64): u64 {
     var $t1: u64 [unused]
     var $t2: u64 [unused]
     var $t3: u64
     # live vars: $t0
  0: $t0 := move($t0)
     # live vars: $t0
  1: $t3 := 1
     # live vars: $t0, $t3
  2: $t0 := +($t0, $t3)
     # live vars: $t0
  3: return $t0
}


[variant baseline]
fun test::__lambda__2__eq4($t0: u64): u64 {
     var $t1: u64 [unused]
     var $t2: u64 [unused]
     var $t3: u64
     # live vars: $t0
  0: $t0 := move($t0)
     # live vars: $t0
  1: $t3 := 2
     # live vars: $t0, $t3
  2: $t0 := +($t0, $t3)
     # live vars: $t0
  3: return $t0
}

============ after DeadStoreElimination: ================

[variant baseline]
fun test::eq1(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop [unused]
     var $t5: bool
     var $t6: &0x1::test::Work
     var $t7: &0x1::test::Work
  0: $t2 := closure#0 test::__lambda__1__eq1()
  1: $t1 := pack 0x1::test::Work($t2)
  2: $t2 := closure#0 test::__lambda__2__eq1()
  3: $t3 := pack 0x1::test::Work($t2)
  4: $t6 := borrow_local($t1)
  5: $t7 := borrow_local($t3)
  6: $t5 := ==($t6, $t7)
  7: if ($t5) goto 8 else goto 12
  8: label L0
  9: $t0 := move($t1)
 10: label L2
 11: return $t0
 12: label L1
 13: $t0 := move($t3)
 14: goto 10
}


[variant baseline]
fun test::eq2(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop [unused]
     var $t5: bool
     var $t6: &0x1::test::Work
     var $t7: &0x1::test::Work
  0: $t2 := closure#0 test::__lambda__1__eq2()
  1: $t1 := pack 0x1::test::Work($t2)
  2: $t2 := closure#0 test::__lambda__2__eq2()
  3: $t3 := pack 0x1::test::Work($t2)
  4: $t6 := borrow_local($t1)
  5: $t7 := borrow_local($t3)
  6: $t5 := ==($t6, $t7)
  7: if ($t5) goto 8 else goto 12
  8: label L0
  9: $t0 := move($t1)
 10: label L2
 11: return $t0
 12: label L1
 13: $t0 := move($t3)
 14: goto 10
}


[variant baseline]
fun test::eq3(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop [unused]
     var $t5: bool
     var $t6: u64 [unused]
     var $t7: u64
     var $t8: |u64|u64 has copy + drop [unused]
     var $t9: u64 [unused]
     var $t10: u64
     var $t11: |u64|u64 has copy + drop [unused]
  0: $t2 := closure#0 test::__lambda__1__eq3()
  1: $t1 := pack 0x1::test::Work($t2)
  2: $t2 := closure#0 test::__lambda__2__eq3()
  3: $t3 := pack 0x1::test::Work($t2)
  4: $t7 := 2
  5: $t2 := unpack 0x1::test::Work($t1)
  6: $t7 := invoke($t7, $t2)
  7: $t10 := 1
  8: $t2 := unpack 0x1::test::Work($t3)
  9: $t10 := invoke($t10, $t2)
 10: $t5 := ==($t7, $t10)
 11: if ($t5) goto 12 else goto 16
 12: label L0
 13: $t0 := move($t1)
 14: label L2
 15: return $t0
 16: label L1
 17: $t0 := move($t3)
 18: goto 14
}


[variant baseline]
fun test::eq4(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop [unused]
     var $t5: bool
     var $t6: &u64
     var $t7: u64
     var $t8: u64
     var $t9: |u64|u64 has copy + drop [unused]
     var $t10: &u64
     var $t11: u64
     var $t12: u64 [unused]
     var $t13: |u64|u64 has copy + drop [unused]
  0: $t2 := closure#0 test::__lambda__1__eq4()
  1: $t1 := pack 0x1::test::Work($t2)
  2: $t2 := closure#0 test::__lambda__2__eq4()
  3: $t3 := pack 0x1::test::Work($t2)
  4: $t8 := 2
  5: $t2 := unpack 0x1::test::Work($t1)
  6: $t7 := invoke($t8, $t2)
  7: $t6 := borrow_local($t7)
  8: $t8 := 1
  9: $t2 := unpack 0x1::test::Work($t3)
 10: $t11 := invoke($t8, $t2)
 11: $t10 := borrow_local($t11)
 12: $t5 := ==($t6, $t10)
 13: if ($t5) goto 14 else goto 18
 14: label L0
 15: $t0 := move($t1)
 16: label L2
 17: return $t0
 18: label L1
 19: $t0 := move($t3)
 20: goto 16
}


[variant baseline]
fun test::__lambda__1__eq1($t0: u64): u64 {
     var $t1: u64 [unused]
     var $t2: u64 [unused]
     var $t3: u64
  0: $t0 := move($t0)
  1: $t3 := 1
  2: $t0 := +($t0, $t3)
  3: return $t0
}


[variant baseline]
fun test::__lambda__2__eq1($t0: u64): u64 {
     var $t1: u64 [unused]
     var $t2: u64 [unused]
     var $t3: u64
  0: $t0 := move($t0)
  1: $t3 := 2
  2: $t0 := +($t0, $t3)
  3: return $t0
}


[variant baseline]
fun test::__lambda__1__eq2($t0: u64): u64 {
     var $t1: u64 [unused]
     var $t2: u64 [unused]
     var $t3: u64
  0: $t0 := move($t0)
  1: $t3 := 1
  2: $t0 := +($t0, $t3)
  3: return $t0
}


[variant baseline]
fun test::__lambda__2__eq2($t0: u64): u64 {
     var $t1: u64 [unused]
     var $t2: u64 [unused]
     var $t3: u64
  0: $t0 := move($t0)
  1: $t3 := 2
  2: $t0 := +($t0, $t3)
  3: return $t0
}


[variant baseline]
fun test::__lambda__1__eq3($t0: u64): u64 {
     var $t1: u64 [unused]
     var $t2: u64 [unused]
     var $t3: u64
  0: $t0 := move($t0)
  1: $t3 := 1
  2: $t0 := +($t0, $t3)
  3: return $t0
}


[variant baseline]
fun test::__lambda__2__eq3($t0: u64): u64 {
     var $t1: u64 [unused]
     var $t2: u64 [unused]
     var $t3: u64
  0: $t0 := move($t0)
  1: $t3 := 2
  2: $t0 := +($t0, $t3)
  3: return $t0
}


[variant baseline]
fun test::__lambda__1__eq4($t0: u64): u64 {
     var $t1: u64 [unused]
     var $t2: u64 [unused]
     var $t3: u64
  0: $t0 := move($t0)
  1: $t3 := 1
  2: $t0 := +($t0, $t3)
  3: return $t0
}


[variant baseline]
fun test::__lambda__2__eq4($t0: u64): u64 {
     var $t1: u64 [unused]
     var $t2: u64 [unused]
     var $t3: u64
  0: $t0 := move($t0)
  1: $t3 := 2
  2: $t0 := +($t0, $t3)
  3: return $t0
}

============ after LiveVarAnalysisProcessor: ================

[variant baseline]
fun test::eq1(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop [unused]
     var $t5: bool
     var $t6: &0x1::test::Work
     var $t7: &0x1::test::Work
     # live vars:
  0: $t2 := closure#0 test::__lambda__1__eq1()
     # live vars: $t2
  1: $t1 := pack 0x1::test::Work($t2)
     # live vars: $t1
  2: $t2 := closure#0 test::__lambda__2__eq1()
     # live vars: $t1, $t2
  3: $t3 := pack 0x1::test::Work($t2)
     # live vars: $t1, $t3
  4: $t6 := borrow_local($t1)
     # live vars: $t1, $t3, $t6
  5: $t7 := borrow_local($t3)
     # live vars: $t1, $t3, $t6, $t7
  6: $t5 := ==($t6, $t7)
     # live vars: $t1, $t3, $t5
  7: if ($t5) goto 8 else goto 12
     # live vars: $t1, $t3
  8: label L0
     # live vars: $t1
  9: $t0 := move($t1)
     # live vars: $t0
 10: label L2
     # live vars: $t0
 11: return $t0
     # live vars: $t1, $t3
 12: label L1
     # live vars: $t3
 13: $t0 := move($t3)
     # live vars: $t0
 14: goto 10
}


[variant baseline]
fun test::eq2(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop [unused]
     var $t5: bool
     var $t6: &0x1::test::Work
     var $t7: &0x1::test::Work
     # live vars:
  0: $t2 := closure#0 test::__lambda__1__eq2()
     # live vars: $t2
  1: $t1 := pack 0x1::test::Work($t2)
     # live vars: $t1
  2: $t2 := closure#0 test::__lambda__2__eq2()
     # live vars: $t1, $t2
  3: $t3 := pack 0x1::test::Work($t2)
     # live vars: $t1, $t3
  4: $t6 := borrow_local($t1)
     # live vars: $t1, $t3, $t6
  5: $t7 := borrow_local($t3)
     # live vars: $t1, $t3, $t6, $t7
  6: $t5 := ==($t6, $t7)
     # live vars: $t1, $t3, $t5
  7: if ($t5) goto 8 else goto 12
     # live vars: $t1, $t3
  8: label L0
     # live vars: $t1
  9: $t0 := move($t1)
     # live vars: $t0
 10: label L2
     # live vars: $t0
 11: return $t0
     # live vars: $t1, $t3
 12: label L1
     # live vars: $t3
 13: $t0 := move($t3)
     # live vars: $t0
 14: goto 10
}


[variant baseline]
fun test::eq3(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop [unused]
     var $t5: bool
     var $t6: u64 [unused]
     var $t7: u64
     var $t8: |u64|u64 has copy + drop [unused]
     var $t9: u64 [unused]
     var $t10: u64
     var $t11: |u64|u64 has copy + drop [unused]
     # live vars:
  0: $t2 := closure#0 test::__lambda__1__eq3()
     # live vars: $t2
  1: $t1 := pack 0x1::test::Work($t2)
     # live vars: $t1
  2: $t2 := closure#0 test::__lambda__2__eq3()
     # live vars: $t1, $t2
  3: $t3 := pack 0x1::test::Work($t2)
     # live vars: $t1, $t3
  4: $t7 := 2
     # live vars: $t1, $t3, $t7
  5: $t2 := unpack 0x1::test::Work($t1)
     # live vars: $t1, $t2, $t3, $t7
  6: $t7 := invoke($t7, $t2)
     # live vars: $t1, $t3, $t7
  7: $t10 := 1
     # live vars: $t1, $t3, $t7, $t10
  8: $t2 := unpack 0x1::test::Work($t3)
     # live vars: $t1, $t2, $t3, $t7, $t10
  9: $t10 := invoke($t10, $t2)
     # live vars: $t1, $t3, $t7, $t10
 10: $t5 := ==($t7, $t10)
     # live vars: $t1, $t3, $t5
 11: if ($t5) goto 12 else goto 16
     # live vars: $t1, $t3
 12: label L0
     # live vars: $t1
 13: $t0 := move($t1)
     # live vars: $t0
 14: label L2
     # live vars: $t0
 15: return $t0
     # live vars: $t1, $t3
 16: label L1
     # live vars: $t3
 17: $t0 := move($t3)
     # live vars: $t0
 18: goto 14
}


[variant baseline]
fun test::eq4(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop [unused]
     var $t5: bool
     var $t6: &u64
     var $t7: u64
     var $t8: u64
     var $t9: |u64|u64 has copy + drop [unused]
     var $t10: &u64
     var $t11: u64
     var $t12: u64 [unused]
     var $t13: |u64|u64 has copy + drop [unused]
     # live vars:
  0: $t2 := closure#0 test::__lambda__1__eq4()
     # live vars: $t2
  1: $t1 := pack 0x1::test::Work($t2)
     # live vars: $t1
  2: $t2 := closure#0 test::__lambda__2__eq4()
     # live vars: $t1, $t2
  3: $t3 := pack 0x1::test::Work($t2)
     # live vars: $t1, $t3
  4: $t8 := 2
     # live vars: $t1, $t3, $t8
  5: $t2 := unpack 0x1::test::Work($t1)
     # live vars: $t1, $t2, $t3, $t8
  6: $t7 := invoke($t8, $t2)
     # live vars: $t1, $t3, $t7
  7: $t6 := borrow_local($t7)
     # live vars: $t1, $t3, $t6
  8: $t8 := 1
     # live vars: $t1, $t3, $t6, $t8
  9: $t2 := unpack 0x1::test::Work($t3)
     # live vars: $t1, $t2, $t3, $t6, $t8
 10: $t11 := invoke($t8, $t2)
     # live vars: $t1, $t3, $t6, $t11
 11: $t10 := borrow_local($t11)
     # live vars: $t1, $t3, $t6, $t10
 12: $t5 := ==($t6, $t10)
     # live vars: $t1, $t3, $t5
 13: if ($t5) goto 14 else goto 18
     # live vars: $t1, $t3
 14: label L0
     # live vars: $t1
 15: $t0 := move($t1)
     # live vars: $t0
 16: label L2
     # live vars: $t0
 17: return $t0
     # live vars: $t1, $t3
 18: label L1
     # live vars: $t3
 19: $t0 := move($t3)
     # live vars: $t0
 20: goto 16
}


[variant baseline]
fun test::__lambda__1__eq1($t0: u64): u64 {
     var $t1: u64 [unused]
     var $t2: u64 [unused]
     var $t3: u64
     # live vars: $t0
  0: $t0 := move($t0)
     # live vars: $t0
  1: $t3 := 1
     # live vars: $t0, $t3
  2: $t0 := +($t0, $t3)
     # live vars: $t0
  3: return $t0
}


[variant baseline]
fun test::__lambda__2__eq1($t0: u64): u64 {
     var $t1: u64 [unused]
     var $t2: u64 [unused]
     var $t3: u64
     # live vars: $t0
  0: $t0 := move($t0)
     # live vars: $t0
  1: $t3 := 2
     # live vars: $t0, $t3
  2: $t0 := +($t0, $t3)
     # live vars: $t0
  3: return $t0
}


[variant baseline]
fun test::__lambda__1__eq2($t0: u64): u64 {
     var $t1: u64 [unused]
     var $t2: u64 [unused]
     var $t3: u64
     # live vars: $t0
  0: $t0 := move($t0)
     # live vars: $t0
  1: $t3 := 1
     # live vars: $t0, $t3
  2: $t0 := +($t0, $t3)
     # live vars: $t0
  3: return $t0
}


[variant baseline]
fun test::__lambda__2__eq2($t0: u64): u64 {
     var $t1: u64 [unused]
     var $t2: u64 [unused]
     var $t3: u64
     # live vars: $t0
  0: $t0 := move($t0)
     # live vars: $t0
  1: $t3 := 2
     # live vars: $t0, $t3
  2: $t0 := +($t0, $t3)
     # live vars: $t0
  3: return $t0
}


[variant baseline]
fun test::__lambda__1__eq3($t0: u64): u64 {
     var $t1: u64 [unused]
     var $t2: u64 [unused]
     var $t3: u64
     # live vars: $t0
  0: $t0 := move($t0)
     # live vars: $t0
  1: $t3 := 1
     # live vars: $t0, $t3
  2: $t0 := +($t0, $t3)
     # live vars: $t0
  3: return $t0
}


[variant baseline]
fun test::__lambda__2__eq3($t0: u64): u64 {
     var $t1: u64 [unused]
     var $t2: u64 [unused]
     var $t3: u64
     # live vars: $t0
  0: $t0 := move($t0)
     # live vars: $t0
  1: $t3 := 2
     # live vars: $t0, $t3
  2: $t0 := +($t0, $t3)
     # live vars: $t0
  3: return $t0
}


[variant baseline]
fun test::__lambda__1__eq4($t0: u64): u64 {
     var $t1: u64 [unused]
     var $t2: u64 [unused]
     var $t3: u64
     # live vars: $t0
  0: $t0 := move($t0)
     # live vars: $t0
  1: $t3 := 1
     # live vars: $t0, $t3
  2: $t0 := +($t0, $t3)
     # live vars: $t0
  3: return $t0
}


[variant baseline]
fun test::__lambda__2__eq4($t0: u64): u64 {
     var $t1: u64 [unused]
     var $t2: u64 [unused]
     var $t3: u64
     # live vars: $t0
  0: $t0 := move($t0)
     # live vars: $t0
  1: $t3 := 2
     # live vars: $t0, $t3
  2: $t0 := +($t0, $t3)
     # live vars: $t0
  3: return $t0
}

============ after FlushWritesProcessor: ================

[variant baseline]
fun test::eq1(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop [unused]
     var $t5: bool
     var $t6: &0x1::test::Work
     var $t7: &0x1::test::Work
     # live vars:
  0: $t2 := closure#0 test::__lambda__1__eq1()
     # flush: $t1
     # live vars: $t2
  1: $t1 := pack 0x1::test::Work($t2)
     # live vars: $t1
  2: $t2 := closure#0 test::__lambda__2__eq1()
     # flush: $t3
     # live vars: $t1, $t2
  3: $t3 := pack 0x1::test::Work($t2)
     # live vars: $t1, $t3
  4: $t6 := borrow_local($t1)
     # live vars: $t1, $t3, $t6
  5: $t7 := borrow_local($t3)
     # live vars: $t1, $t3, $t6, $t7
  6: $t5 := ==($t6, $t7)
     # live vars: $t1, $t3, $t5
  7: if ($t5) goto 8 else goto 12
     # live vars: $t1, $t3
  8: label L0
     # flush: $t0
     # live vars: $t1
  9: $t0 := move($t1)
     # live vars: $t0
 10: label L2
     # live vars: $t0
 11: return $t0
     # live vars: $t1, $t3
 12: label L1
     # flush: $t0
     # live vars: $t3
 13: $t0 := move($t3)
     # live vars: $t0
 14: goto 10
}


[variant baseline]
fun test::eq2(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop [unused]
     var $t5: bool
     var $t6: &0x1::test::Work
     var $t7: &0x1::test::Work
     # live vars:
  0: $t2 := closure#0 test::__lambda__1__eq2()
     # flush: $t1
     # live vars: $t2
  1: $t1 := pack 0x1::test::Work($t2)
     # live vars: $t1
  2: $t2 := closure#0 test::__lambda__2__eq2()
     # flush: $t3
     # live vars: $t1, $t2
  3: $t3 := pack 0x1::test::Work($t2)
     # live vars: $t1, $t3
  4: $t6 := borrow_local($t1)
     # live vars: $t1, $t3, $t6
  5: $t7 := borrow_local($t3)
     # live vars: $t1, $t3, $t6, $t7
  6: $t5 := ==($t6, $t7)
     # live vars: $t1, $t3, $t5
  7: if ($t5) goto 8 else goto 12
     # live vars: $t1, $t3
  8: label L0
     # flush: $t0
     # live vars: $t1
  9: $t0 := move($t1)
     # live vars: $t0
 10: label L2
     # live vars: $t0
 11: return $t0
     # live vars: $t1, $t3
 12: label L1
     # flush: $t0
     # live vars: $t3
 13: $t0 := move($t3)
     # live vars: $t0
 14: goto 10
}


[variant baseline]
fun test::eq3(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop [unused]
     var $t5: bool
     var $t6: u64 [unused]
     var $t7: u64
     var $t8: |u64|u64 has copy + drop [unused]
     var $t9: u64 [unused]
     var $t10: u64
     var $t11: |u64|u64 has copy + drop [unused]
     # live vars:
  0: $t2 := closure#0 test::__lambda__1__eq3()
     # flush: $t1
     # live vars: $t2
  1: $t1 := pack 0x1::test::Work($t2)
     # live vars: $t1
  2: $t2 := closure#0 test::__lambda__2__eq3()
     # flush: $t3
     # live vars: $t1, $t2
  3: $t3 := pack 0x1::test::Work($t2)
     # live vars: $t1, $t3
  4: $t7 := 2
     # live vars: $t1, $t3, $t7
  5: $t2 := unpack 0x1::test::Work($t1)
     # live vars: $t1, $t2, $t3, $t7
  6: $t7 := invoke($t7, $t2)
     # live vars: $t1, $t3, $t7
  7: $t10 := 1
     # live vars: $t1, $t3, $t7, $t10
  8: $t2 := unpack 0x1::test::Work($t3)
     # live vars: $t1, $t2, $t3, $t7, $t10
  9: $t10 := invoke($t10, $t2)
     # live vars: $t1, $t3, $t7, $t10
 10: $t5 := ==($t7, $t10)
     # live vars: $t1, $t3, $t5
 11: if ($t5) goto 12 else goto 16
     # live vars: $t1, $t3
 12: label L0
     # flush: $t0
     # live vars: $t1
 13: $t0 := move($t1)
     # live vars: $t0
 14: label L2
     # live vars: $t0
 15: return $t0
     # live vars: $t1, $t3
 16: label L1
     # flush: $t0
     # live vars: $t3
 17: $t0 := move($t3)
     # live vars: $t0
 18: goto 14
}


[variant baseline]
fun test::eq4(): 0x1::test::Work {
     var $t0: 0x1::test::Work
     var $t1: 0x1::test::Work
     var $t2: |u64|u64 has copy + drop
     var $t3: 0x1::test::Work
     var $t4: |u64|u64 has copy + drop [unused]
     var $t5: bool
     var $t6: &u64
     var $t7: u64
     var $t8: u64
     var $t9: |u64|u64 has copy + drop [unused]
     var $t10: &u64
     var $t11: u64
     var $t12: u64 [unused]
     var $t13: |u64|u64 has copy + drop [unused]
     # live vars:
  0: $t2 := closure#0 test::__lambda__1__eq4()
     # flush: $t1
     # live vars: $t2
  1: $t1 := pack 0x1::test::Work($t2)
     # live vars: $t1
  2: $t2 := closure#0 test::__lambda__2__eq4()
     # flush: $t3
     # live vars: $t1, $t2
  3: $t3 := pack 0x1::test::Work($t2)
     # live vars: $t1, $t3
  4: $t8 := 2
     # live vars: $t1, $t3, $t8
  5: $t2 := unpack 0x1::test::Work($t1)
     # live vars: $t1, $t2, $t3, $t8
  6: $t7 := invoke($t8, $t2)
     # live vars: $t1, $t3, $t7
  7: $t6 := borrow_local($t7)
     # live vars: $t1, $t3, $t6
  8: $t8 := 1
     # live vars: $t1, $t3, $t6, $t8
  9: $t2 := unpack 0x1::test::Work($t3)
     # live vars: $t1, $t2, $t3, $t6, $t8
 10: $t11 := invoke($t8, $t2)
     # live vars: $t1, $t3, $t6, $t11
 11: $t10 := borrow_local($t11)
     # live vars: $t1, $t3, $t6, $t10
 12: $t5 := ==($t6, $t10)
     # live vars: $t1, $t3, $t5
 13: if ($t5) goto 14 else goto 18
     # live vars: $t1, $t3
 14: label L0
     # flush: $t0
     # live vars: $t1
 15: $t0 := move($t1)
     # live vars: $t0
 16: label L2
     # live vars: $t0
 17: return $t0
     # live vars: $t1, $t3
 18: label L1
     # flush: $t0
     # live vars: $t3
 19: $t0 := move($t3)
     # live vars: $t0
 20: goto 16
}


[variant baseline]
fun test::__lambda__1__eq1($t0: u64): u64 {
     var $t1: u64 [unused]
     var $t2: u64 [unused]
     var $t3: u64
     # live vars: $t0
  0: $t0 := move($t0)
     # live vars: $t0
  1: $t3 := 1
     # live vars: $t0, $t3
  2: $t0 := +($t0, $t3)
     # live vars: $t0
  3: return $t0
}


[variant baseline]
fun test::__lambda__2__eq1($t0: u64): u64 {
     var $t1: u64 [unused]
     var $t2: u64 [unused]
     var $t3: u64
     # live vars: $t0
  0: $t0 := move($t0)
     # live vars: $t0
  1: $t3 := 2
     # live vars: $t0, $t3
  2: $t0 := +($t0, $t3)
     # live vars: $t0
  3: return $t0
}


[variant baseline]
fun test::__lambda__1__eq2($t0: u64): u64 {
     var $t1: u64 [unused]
     var $t2: u64 [unused]
     var $t3: u64
     # live vars: $t0
  0: $t0 := move($t0)
     # live vars: $t0
  1: $t3 := 1
     # live vars: $t0, $t3
  2: $t0 := +($t0, $t3)
     # live vars: $t0
  3: return $t0
}


[variant baseline]
fun test::__lambda__2__eq2($t0: u64): u64 {
     var $t1: u64 [unused]
     var $t2: u64 [unused]
     var $t3: u64
     # live vars: $t0
  0: $t0 := move($t0)
     # live vars: $t0
  1: $t3 := 2
     # live vars: $t0, $t3
  2: $t0 := +($t0, $t3)
     # live vars: $t0
  3: return $t0
}


[variant baseline]
fun test::__lambda__1__eq3($t0: u64): u64 {
     var $t1: u64 [unused]
     var $t2: u64 [unused]
     var $t3: u64
     # live vars: $t0
  0: $t0 := move($t0)
     # live vars: $t0
  1: $t3 := 1
     # live vars: $t0, $t3
  2: $t0 := +($t0, $t3)
     # live vars: $t0
  3: return $t0
}


[variant baseline]
fun test::__lambda__2__eq3($t0: u64): u64 {
     var $t1: u64 [unused]
     var $t2: u64 [unused]
     var $t3: u64
     # live vars: $t0
  0: $t0 := move($t0)
     # live vars: $t0
  1: $t3 := 2
     # live vars: $t0, $t3
  2: $t0 := +($t0, $t3)
     # live vars: $t0
  3: return $t0
}


[variant baseline]
fun test::__lambda__1__eq4($t0: u64): u64 {
     var $t1: u64 [unused]
     var $t2: u64 [unused]
     var $t3: u64
     # live vars: $t0
  0: $t0 := move($t0)
     # live vars: $t0
  1: $t3 := 1
     # live vars: $t0, $t3
  2: $t0 := +($t0, $t3)
     # live vars: $t0
  3: return $t0
}


[variant baseline]
fun test::__lambda__2__eq4($t0: u64): u64 {
     var $t1: u64 [unused]
     var $t2: u64 [unused]
     var $t3: u64
     # live vars: $t0
  0: $t0 := move($t0)
     # live vars: $t0
  1: $t3 := 2
     # live vars: $t0, $t3
  2: $t0 := +($t0, $t3)
     # live vars: $t0
  3: return $t0
}


============ disassembled file-format ==================
// Move bytecode v8
module 1.test {
struct Work has copy, drop {
	_0: |u64|u64 has copy + drop
}

eq1(): Work /* def_idx: 0 */ {
L0:	work1: Work
L1:	work2: Work
L2:	return: Work
B0:
	0: PackClosure#0 __lambda__1__eq1(u64): u64
	1: Pack[0](Work)
	2: StLoc[0](work1: Work)
	3: PackClosure#0 __lambda__2__eq1(u64): u64
	4: Pack[0](Work)
	5: StLoc[1](work2: Work)
	6: ImmBorrowLoc[0](work1: Work)
	7: ImmBorrowLoc[1](work2: Work)
	8: Eq
	9: BrFalse(14)
B1:
	10: MoveLoc[0](work1: Work)
	11: StLoc[2](return: Work)
B2:
	12: MoveLoc[2](return: Work)
	13: Ret
B3:
	14: MoveLoc[1](work2: Work)
	15: StLoc[2](return: Work)
	16: Branch(12)
}
eq2(): Work /* def_idx: 1 */ {
L0:	work1: Work
L1:	work2: Work
L2:	return: Work
B0:
	0: PackClosure#0 __lambda__1__eq2(u64): u64
	1: Pack[0](Work)
	2: StLoc[0](work1: Work)
	3: PackClosure#0 __lambda__2__eq2(u64): u64
	4: Pack[0](Work)
	5: StLoc[1](work2: Work)
	6: ImmBorrowLoc[0](work1: Work)
	7: ImmBorrowLoc[1](work2: Work)
	8: Eq
	9: BrFalse(14)
B1:
	10: MoveLoc[0](work1: Work)
	11: StLoc[2](return: Work)
B2:
	12: MoveLoc[2](return: Work)
	13: Ret
B3:
	14: MoveLoc[1](work2: Work)
	15: StLoc[2](return: Work)
	16: Branch(12)
}
eq3(): Work /* def_idx: 2 */ {
L0:	work1: Work
L1:	work2: Work
L2:	return: Work
B0:
	0: PackClosure#0 __lambda__1__eq3(u64): u64
	1: Pack[0](Work)
	2: StLoc[0](work1: Work)
	3: PackClosure#0 __lambda__2__eq3(u64): u64
	4: Pack[0](Work)
	5: StLoc[1](work2: Work)
	6: LdU64(2)
	7: CopyLoc[0](work1: Work)
	8: Unpack[0](Work)
	9: CallClosure(|u64|u64 has copy + drop)
	10: LdU64(1)
	11: CopyLoc[1](work2: Work)
	12: Unpack[0](Work)
	13: CallClosure(|u64|u64 has copy + drop)
	14: Eq
	15: BrFalse(20)
B1:
	16: MoveLoc[0](work1: Work)
	17: StLoc[2](return: Work)
B2:
	18: MoveLoc[2](return: Work)
	19: Ret
B3:
	20: MoveLoc[1](work2: Work)
	21: StLoc[2](return: Work)
	22: Branch(18)
}
eq4(): Work /* def_idx: 3 */ {
L0:	work1: Work
L1:	work2: Work
L2:	$t7: u64
L3:	$t11: u64
L4:	return: Work
B0:
	0: PackClosure#0 __lambda__1__eq4(u64): u64
	1: Pack[0](Work)
	2: StLoc[0](work1: Work)
	3: PackClosure#0 __lambda__2__eq4(u64): u64
	4: Pack[0](Work)
	5: StLoc[1](work2: Work)
	6: LdU64(2)
	7: CopyLoc[0](work1: Work)
	8: Unpack[0](Work)
	9: CallClosure(|u64|u64 has copy + drop)
	10: StLoc[2]($t7: u64)
	11: ImmBorrowLoc[2]($t7: u64)
	12: LdU64(1)
	13: CopyLoc[1](work2: Work)
	14: Unpack[0](Work)
	15: CallClosure(|u64|u64 has copy + drop)
	16: StLoc[3]($t11: u64)
	17: ImmBorrowLoc[3]($t11: u64)
	18: Eq
	19: BrFalse(24)
B1:
	20: MoveLoc[0](work1: Work)
	21: StLoc[4](return: Work)
B2:
	22: MoveLoc[4](return: Work)
	23: Ret
B3:
	24: MoveLoc[1](work2: Work)
	25: StLoc[4](return: Work)
	26: Branch(22)
}
__lambda__1__eq1(x: u64): u64 /* def_idx: 4 */ {
B0:
	0: MoveLoc[0](x: u64)
	1: LdU64(1)
	2: Add
	3: Ret
}
__lambda__2__eq1(x: u64): u64 /* def_idx: 5 */ {
B0:
	0: MoveLoc[0](x: u64)
	1: LdU64(2)
	2: Add
	3: Ret
}
__lambda__1__eq2(x: u64): u64 /* def_idx: 6 */ {
B0:
	0: MoveLoc[0](x: u64)
	1: LdU64(1)
	2: Add
	3: Ret
}
__lambda__2__eq2(x: u64): u64 /* def_idx: 7 */ {
B0:
	0: MoveLoc[0](x: u64)
	1: LdU64(2)
	2: Add
	3: Ret
}
__lambda__1__eq3(x: u64): u64 /* def_idx: 8 */ {
B0:
	0: MoveLoc[0](x: u64)
	1: LdU64(1)
	2: Add
	3: Ret
}
__lambda__2__eq3(x: u64): u64 /* def_idx: 9 */ {
B0:
	0: MoveLoc[0](x: u64)
	1: LdU64(2)
	2: Add
	3: Ret
}
__lambda__1__eq4(x: u64): u64 /* def_idx: 10 */ {
B0:
	0: MoveLoc[0](x: u64)
	1: LdU64(1)
	2: Add
	3: Ret
}
__lambda__2__eq4(x: u64): u64 /* def_idx: 11 */ {
B0:
	0: MoveLoc[0](x: u64)
	1: LdU64(2)
	2: Add
	3: Ret
}
}
============ bytecode verification succeeded ========
